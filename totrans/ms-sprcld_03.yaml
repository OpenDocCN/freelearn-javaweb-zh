- en: Spring Cloud Overview
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In [Chapter 1](33ddbb93-e658-4d91-97f5-06d6167ef89e.xhtml), *Introduction to
    Microservices*, I mentioned the cloud-native development style and also that Spring
    Cloud helps you in the easy adoption of the best practices associated with this
    concept. The most commonly used best practices have been collected together in
    an interesting initiative called **The Twelve-Factor App**. As you might read
    on their website ([https://12factor.net/](https://12factor.net/)), this is a methodology
    for building **Software as a Service** (**SaaS**) modern applications, which must
    be scalable, easily deployable on cloud platforms, and delivered in the continuous
    deployment process. It is worth being familiar with these principles, especially
    if you are a developer who builds applications running as a service. Spring Boot
    and Spring Cloud provide features and components that make your application compliant
    with *Twelve-Factor rules*. We can distinguish some typical features that the
    most modern distributed systems usually use. Every opinionated framework should
    provide them and there is no difference for Spring Cloud. Those features are as
    follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Distributed/versioned configuration
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Service registration and discovery
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Routing
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Service-to-service calls
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Load balancing
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Circuit breakers
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Distributed messaging
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Beginning with the basics
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s go back to the previous chapter for a moment. There I have already described
    in detail the structure of a Spring Boot project. Configuration should be provided
    in YAML or a properties file with the application or the `application-{profile}`
    name. In contrast to a standard Spring Boot application, Spring Cloud is based
    on the configuration taken from a remote server. However, minimal settings are
    needed inside the application; for example, its name and config server address.
    That''s why a Spring Cloud application creates a bootstrap context, which is responsible
    for loading properties from the external sources. Bootstrap properties are added
    with the highest priority and they cannot be overridden by local configuration.
    Bootstrap context, which is a parent for the main application context, uses `bootstrap.yml`
    instead of `application.yml`. Usually, we put the application name and Spring
    Cloud Config settings, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'Bootstrap context startup can be easily disabled by setting the `spring.cloud.bootstrap.enabled` property
    to `false`. We can also change the name of the bootstrap configuration file using
    the `spring.cloud.bootstrap.name` property or even changing the location by setting
    `spring.cloud.bootstrap.location`. The profile mechanisms are also available here,
    so we are allowed to create, for example, `bootstrap-development.yml`, which is
    loaded on an active development profile. This and some other features are available
    in the Spring Cloud Context library, which is added as a parent dependency to
    the project classpath together with any other Spring Cloud library. One of these
    features is some additional management endpoints included with the Spring Boot
    Actuator:'
  prefs: []
  type: TYPE_NORMAL
- en: '`env`: A new `POST` method for `Environment`, log levels update, and `@ConfigurationProperties`
    rebind'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`refresh`: This reloads bootstrap context and refreshes all beans annotated
    with `@RefreshScope`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`restart`: This restarts Spring `ApplicationContext`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`pause`: This stops Spring `ApplicationContext`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`resume`: This starts Spring `ApplicationContext`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The next library together with Spring Cloud Context, which is included as a
    parent dependency with Spring Cloud projects, is Spring Cloud Commons. It provides
    a common abstraction layer for mechanisms such as service discovery, load balancing, and
    circuit breakers. These include, among other things, frequently used annotations
    such as `@EnableDiscoveryClient` or `@LoadBalanced`. I'll present more details
    about them in the following chapters.
  prefs: []
  type: TYPE_NORMAL
- en: Netflix OSS
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: On reading the first two chapters, you have probably noticed the appearance
    of many keywords related to microservice architecture. For some of you, it might
    be a new term, for others, it is well known. But so far, one important word to
    the microservices community has not been mentioned yet. It is definitely known
    by most of you, this word is *Netflix*. Well, I also like their TV shows and other
    productions, but for developers, they are famous for another reason. This reason
    is microservices. Netflix is one of the earliest pioneers of migration from a
    traditional development model where we created monolithic applications for a cloud-native
    microservices development approach. This company shares their expertise with the
    community by pushing a great part of the source code into the public repository,
    speaking in conference presentations, and publishing blog posts. Netflix has been
    so successful with its architecture concept that they became a role model for
    other large organizations and their IT architects such as Adrian Cockcroft are
    now prominent evangelists for microservices. In turn, many open source frameworks
    based their libraries on the solutions available under the code shared by Netflix.
    It is no different for Spring Cloud, which provides integrations with the most
    popular Netflix OSS features such as Eureka, Hystrix, Ribbon, or Zuul.
  prefs: []
  type: TYPE_NORMAL
- en: 'By the way, I don''t know if you have been following Netflix, but they shed
    some light on the reasons why they decided to open source much of their code. I
    think it is worth quoting because that partly explains the success and unwaning
    popularity of their solutions in the IT world:'
  prefs: []
  type: TYPE_NORMAL
- en: '"When we said we were going to move all of Netflix to the cloud everyone said
    we were completely crazy. They didn''t believe we were actually doing that, they
    thought we were just making stuff up."'
  prefs: []
  type: TYPE_NORMAL
- en: Service discovery with Eureka
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The first pattern provided by Spring Cloud Netflix is the service discovery
    with Eureka. This package is divided into client and server.
  prefs: []
  type: TYPE_NORMAL
- en: To include a Eureka Client in your project you should use the `spring-cloud-starter-eureka` starter.
    The client is always a part of an application and is responsible for connecting
    to a remote discovery server. Once the connection is established it should send
    a registration message with a service name and network location. In case the current
    microservice has to call an endpoint from another microservice, the client should
    retrieve the newest configuration with a list of registered services from the server.
    The server can be configured and run as an independent Spring Boot application
    and it is supposed to be highly available with each server replicating its state
    to other nodes. To include a Eureka Server in your project you need to use the
    `spring-cloud-starter-eureka-server` starter.
  prefs: []
  type: TYPE_NORMAL
- en: Routing with Zuul
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The next popular pattern available under the Spring Cloud Netflix project is
    intelligent routing with Zuul. It is not only a JVM-based router but it also acts
    as a server-side load balancer and/or performs some filtering. It can also have
    a wide variety of applications. Netflix uses it for cases such as authentication,
    load shedding, static response handling, or stress testing. It is the same as
    Eureka Server in that it can be configured and run as an independent Spring Boot
    application.
  prefs: []
  type: TYPE_NORMAL
- en: To include Zuul in your project use the `spring-cloud-starter-zuul` starter.
    In the microservices architecture, Zuul has a vital role of the API gateway, which
    is an entry point to the whole system. It needs to have knowledge of the network
    location of each service, so it is able to interact with the Eureka Server by
    including the discovery client to the classpath.
  prefs: []
  type: TYPE_NORMAL
- en: Load balancing with Ribbon
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We cannot ignore the next Spring Cloud Netflix feature used for client-side
    load balancing—Ribbon. It supports the most popular protocols such as TCP, UDP,
    and HTTP. It can be used not only for synchronous REST calls, but also in asynchronous
    and reactive models. In addition to load balancing, it provides integration with
    service discovery, caching, batching, and fault tolerance. Ribbon is the next
    abstraction level over basic HTTP and TCP clients.
  prefs: []
  type: TYPE_NORMAL
- en: To include it in your project use the `spring-cloud-starter-ribbon` starter. Ribbon
    supports round robin, availability filtering, and weighted response time load
    balancing rules out-of-the-box and can be easily extended with custom defined
    rules. It is based on the *named client* concept, where servers included for the
    load balancing should be provided with a name.
  prefs: []
  type: TYPE_NORMAL
- en: Writing Java HTTP clients
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Feign is a slightly less popular Netflix OSS package. It is a declarative REST
    client, which helps us in writing web service clients more easily. With Feign,
    a developer only needs to declare and annotate an interface while the actual implementation
    will be generated at runtime.
  prefs: []
  type: TYPE_NORMAL
- en: To include Feign in your project you need to use the `spring-cloud-starter-feign` starter.
    It integrates with the Ribbon client, so it supports, by default, load balancing
    and other Ribbon features including communication with the discovery service.
  prefs: []
  type: TYPE_NORMAL
- en: Latency and fault tolerance with Hystrix
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: I have already mentioned the circuit breaker pattern in [Chapter 1](33ddbb93-e658-4d91-97f5-06d6167ef89e.xhtml),
    *Introduction to Microservices*, and Spring Cloud provides a library that implements
    this pattern. It is based on the Hystrix package created by Netflix as a circuit
    breaker implementation. Hystrix is by default integrated with the Ribbon and Feign
    clients. Fallback is closely related to the circuit breaker concept. With Spring
    Cloud libraries you can easily configure fallback logic, which should be performed
    if there is a read or circuit breaker timeout. To include Hystrix in your project
    you should use the `spring-cloud-starter-hystrix` starter.
  prefs: []
  type: TYPE_NORMAL
- en: Configuration management with Archaius
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The last important feature provided under the Spring Cloud Netflix project is
    Archaius. Personally, I haven't touched this library, but it might be useful in
    some cases. The Spring Cloud reference Archaius is an extension of the Apache
    Commons Configuration project. It allows updating the configuration by either
    polling a source for changes or pushing changes to the client.
  prefs: []
  type: TYPE_NORMAL
- en: Discovery and distributed configuration
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Service discovery and distributed configuration management are vital parts of
    the microservices architecture. The technical implementation of these two different
    mechanisms is pretty similar. It comes down to storing parameters under specific
    keys in a flexible key-value storage. Actually, there are several interesting
    solutions available on the market which provide both of these functionalities.
    Spring Cloud integrates with the most popular of them. But there is also one exception
    where Spring Cloud has its own implementation created only for distributed configuration.
    This feature is available under the Spring Cloud Config project. In contrast,
    Spring Cloud does not provide its own implementation for service registration
    and discovery.
  prefs: []
  type: TYPE_NORMAL
- en: As usual, we can divide this project into the server and client-side support. The
    server is the one, central place where all of the external properties for applications
    are managed across all of the environments. Configuration can be maintained simultaneously
    in several versions and profiles. This is achieved by using Git as a storage backend.
    The mechanism is really smart and we will discuss it in detail in [Chapter 5](37142825-02d0-48a0-99df-1a1a88a1bbd4.xhtml), *Distributed
    Configuration with Spring Cloud Config*. The Git backend is not the only one option
    for storing properties. The config files could also be located on a file system
    or server classpath. The next option is to use Vault as a backend. Vault is an
    open source tool for managing secrets such as tokens, passwords, or certificates
    released by HashiCorp. I know that many organizations pay particular attention
    to security issues such as storing credentials in a secure place, so it could
    be the right solution for them. Generally, we can also manage security on the
    configuration server access level. No matter which backend is used for storing
    properties, Spring Cloud Config Server exposes an HTTP, resource-based API which
    provides easy access to them. By default, this API is secured with basic authentication,
    but it is also available to set an SSL connection with private/public key authentication.
  prefs: []
  type: TYPE_NORMAL
- en: A server can be run as an independent Spring Boot application with properties
    exposed over the REST API. To enable it for our project we should add the `spring-cloud-config-server`
    dependency. There is also support on the client-side. Every microservice that
    uses a configuration server as a properties source needs to connect to it just
    after startup, before creating any Spring beans. Interestingly, the Spring Cloud
    Config Server can be used by non Spring applications. There are some popular microservice
    frameworks that integrate with it on the client side. To enable Spring Cloud Config
    Client for your application you need to include the `spring-cloud-config-starter`
    dependency.
  prefs: []
  type: TYPE_NORMAL
- en: An alternative – Consul
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: An interesting alternative for Netflix discovery and Spring distributed configuration seems
    to be Consul created by Hashicorp. Spring Cloud provides integrations with this
    popular tool for discovering and configuring services in your infrastructure.
    As usual, this integration can be enabled using a few simple common annotations
    and the only difference in comparison with an earlier presented solution is in
    configuration settings. In order to establish communication with a Consul server,
    its agent needs to be available for the application. It has to be able to run
    as a separated process, which is available by default at the `http://localhost:8500`
    address. Consul also provides REST API, which can be directly used for registration,
    collecting a list of services, or configuration of properties.
  prefs: []
  type: TYPE_NORMAL
- en: To activate Consul Service Discovery we need to use the `spring-cloud-starter-consul-discovery` starter.
    After application startup and registration, a client would query Consul in order
    to locate other services. It supports both the client-side load balancer with
    Netflix Ribbon and dynamic router and filter with Netflix Zuul.
  prefs: []
  type: TYPE_NORMAL
- en: Apache Zookeeper
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The next popular solution within this area supported by Spring Cloud is Apache
    Zookeeper. Following its documentation, it is a centralized service for maintaining
    configuration, naming, which also provides distributed synchronization, and is
    able to group services. Everything that has previously applied to Consul regarding
    support in Spring Cloud is also true for Zookeeper. I'm thinking here about simple
    common annotations, which have to be used to enable integration, configuration
    though properties inside settings files and auto-configuration for interacting
    with Ribbon or Zuul. To enable service discovery with Zookeeper on the client
    side we need not only include `spring-cloud-starter-zookeeper-discovery`, but
    also Apache Curator. It provides an API framework and utilities to make integration
    easy and more reliable. It is not needed for distributed configuration clients
    where we only have to include the `spring-cloud-starter-zookeeper-config` for
    our project dependencies.
  prefs: []
  type: TYPE_NORMAL
- en: Miscellaneous projects
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: It is worth mentioning two other projects, which are now in the incubation stage.
    All such projects are available in the GitHub repository, [https://github.com/spring-cloud-incubator](https://github.com/spring-cloud-incubator).
    Some of them will probably be officially attached to the Spring Cloud package
    in the short term. The first of them is Spring Cloud Kubernetes, which provides
    integration with this very popular tool. We could talk about it for a long time,
    but let's try to introduce it in a few words. It is a system for automating deployment,
    scaling, and management of containerized applications originally designed by Google.
    It is used for container orchestration and has many interesting features including
    service discovery, configuration management, and load balancing. In some cases,
    it might be treated as Spring Cloud's competition. The configuration is provided
    with the usage of YAML files.
  prefs: []
  type: TYPE_NORMAL
- en: Important features from the Spring Cloud point of view are service discovery
    and distributed configuration mechanisms, which are available on the Kubernetes
    platform. To use them in your application you should include `spring-cloud-starter-kubernetes`
    starter.
  prefs: []
  type: TYPE_NORMAL
- en: The second interesting project at the incubation stage is Spring Cloud Etcd.
    Exactly the same as before, its main features are distributed configuration, service
    registration, and discovery. Etcd is not a powerful tool like Kubernetes. It just
    provides a distributed key-value store with a reliable way to store data in a
    clustered environment. And a little trivia—Etcd is the backend for service discovery,
    cluster state, and configuration management in Kubernetes.
  prefs: []
  type: TYPE_NORMAL
- en: Distributed tracing with Sleuth
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Another one of Spring Cloud's essential functionalities is distributed tracing.
    It is implemented in the Spring Cloud Sleuth library. Its primary purpose is to
    associate subsequent requests dispatched between different microservices under
    processing single input request. As in most cases, these are HTTP requests that
    implement tracing mechanisms based on HTTP headers. The implementation is built
    over Slf4j and MDC. Slf4j provides facade and abstraction for specific logging
    frameworks such as logback, log4j, or `java.util.logging`. **MDC** or **mapped
    diagnostic context** in full, is a solution for distinguishing log output from
    different sources and enriching them with additional information that could be
    not available in the actual scope.
  prefs: []
  type: TYPE_NORMAL
- en: Spring Cloud Sleuth adds trace and span IDs to the Slf4J MDC, so that we are
    able to extract all of the logs with a given trace or span. It also adds some
    other entries such as application name or exportable flag. It integrates with
    the most popular messaging solutions such as Spring REST template, Feign client,
    Zuul filters, Hystrix, or Spring Integration message channels. It can also be
    used together with RxJava or scheduled tasks. To enable it in your project you
    should add the `spring-cloud-starter-sleuth` dependency. The usage of basic span
    and trace IDs mechanisms is completely transparent for a developer.
  prefs: []
  type: TYPE_NORMAL
- en: Adding tracing headers is not the only feature of Spring Cloud Sleuth. It is
    also responsible for recording timing information, which is useful in latency
    analysis. Such statistics can be exported to Zipkin, a tool that can be used for
    querying and visualization timing data.
  prefs: []
  type: TYPE_NORMAL
- en: Zipkin is a distributing tracing system specially designed for analyzing latency
    problems inside microservices architecture. It exposes HTTP endpoints used for
    collecting input data. To enable generating and sending traces to Zipkin we should
    include the `spring-cloud-starter-zipkin` dependency to the project.
  prefs: []
  type: TYPE_NORMAL
- en: Frequently, there is no need to analyze everything; the input traffic volume
    is so high that we would need to collect only a certain percentage of data. For
    that purpose, Spring Cloud Sleuth provides a sampling policy, where we can decide
    how much input traffic is sent to Zipkin. The second smart solution to the big
    data problem is to send statistics using the message broker instead of the default
    HTTP endpoint. To enable this feature we have to include the `spring-cloud-sleuth-stream` dependency,
    which allows your application to become a producer of messages sent to Apache
    Kafka or RabbitMQ.
  prefs: []
  type: TYPE_NORMAL
- en: Messaging and integration
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: I have already mentioned messaging brokers and their usage for communication
    between your application and Zipkin server. Generally, Spring Cloud supports two
    types of communications via synchronous/asynchronous HTTP and with messaging brokers.
    The first project from this area is Spring Cloud Bus. It allows you to send broadcast
    events to applications informing them about state changes such as configuration
    property updates or other management commands. Actually, we might want to use
    starters for AMQP with a RabbitMQ broker or for Apache Kafka. As usual, we only
    need to include `spring-cloud-starter-bus-amqp` or `spring-cloud-starter-bus-kafka`
    to the dependency management and all other necessary operations are performed
    through auto-configuration.
  prefs: []
  type: TYPE_NORMAL
- en: Spring Cloud Bus is a rather small project allowing you to use distributed messaging
    features for common operations such as broadcasting configuration change events.
    The right framework for building a system consisting of message-driven microservices
    is the Spring Cloud Stream. This is a really powerful framework and one of the
    biggest Spring Cloud projects, to which I have dedicated an entire chapter, [Chapter
    11](554c4049-1dc9-430d-8fe7-19f3b9ac99a3.xhtml), *Message Driven Microservices*,
    of the book. The same as for Spring Cloud Bus, there are two binders available,
    first for AMQP with RabbitMQ, and second for Apache Kafka. Spring Cloud Stream
    is based on Spring Integration, which is another large project part of Spring.
    It provides a programming model, supporting most Enterprise Integration Patterns
    such as endpoint, channel, aggregator, or transformer. The applications included
    in the whole microservice system communicate with each other through the Spring
    Cloud Stream input and output channels. The main communication model between them
    is Publish/Subscribe, where messages are broadcast through shared topics. Additionally,
    it is important to support multi instances of every microservice. In most cases,
    a message should be processed only by a single instance, which is not supported
    in a Publish/Subscribe model. That's why Spring Cloud Stream introduces grouping
    mechanisms where only one member of the group receives a message from a destination.
    The same as earlier, these are two starters that can include a project depending
    on the binder type `spring-cloud-starter-stream-kafka` or `spring-cloud-starter-stream-rabbit`.
  prefs: []
  type: TYPE_NORMAL
- en: There are two more projects related to Spring Cloud Stream. First, Spring Cloud
    Stream App Starters defines a set of Spring Cloud Stream applications that can
    be run independently or using the second project, Spring Cloud Data Flow. Among
    these applications, we can distinguish connectors, adapters for network protocols,
    and generic protocols. Spring Cloud Data Flow is another extensive and powerful
    Spring Cloud toolkit. It simplifies development and deployment by providing a
    smart solution for building data integration and real-time data processing pipelines.
    The orchestration of microservice-based data pipelines is achieved with simple
    DSL, a drag-and-drop UI dashboard, and REST APIs together.
  prefs: []
  type: TYPE_NORMAL
- en: Cloud platform support
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Pivotal Cloud Foundry is a cloud-native platform for deploying and managing
    modern applications. Pivotal Software, as some of you probably already know, is
    an owner of the Spring framework trademark. The patronage of a large, commercial
    platform is one of the important reasons for Spring''s growing popularity. What
    is obvious is that PCF fully supports both Spring Boot''s executable JAR files,
    and all of Spring Cloud microservices patterns such as Config Server, service
    registry, and circuit breaker. These types of tools can be easily run and configured
    using the marketplace available on the UI dashboard or client command line. Development
    for PCF is even simpler than with standard Spring Cloud application. The only
    thing we have to do is to include the right starters to project dependencies:'
  prefs: []
  type: TYPE_NORMAL
- en: '`spring-cloud-services-starter-circuit-breaker`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`spring-cloud-services-starter-config-client`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`spring-cloud-services-starter-service-registry`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'It''s difficult to find an opinionated cloud framework that does not have support
    for AWS. The same is true for Spring Cloud. Spring Cloud for Amazon Web Services
    provides integration with the most popular web tools available there. This includes
    modules for communication with **Simple Queueing Service** (**SQS**),  **Simple
    Notification Service** (**SNS**), **ElasticCache**, and **Relational Database
    Service** (**RDS**) that offer engines such as Aurora, MySQL, or Oracle. The remote
    resources can be accessed using their name defined in the CloudFormation stack.
    Everything is opaque in well-known Spring convention and patterns. There are four
    main modules available:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Spring Cloud AWS Core**: Included using the `spring-cloud-starter-aws` starter,
    provides core components enabling direct access to the EC2 instance'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Spring Cloud AWS Context**: Delivers access to the Simple Storage Service,
    Simple E-mail Service, and caching service'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Spring Cloud AWS JDBC**: Included using starter `spring-cloud-starter-aws-jdbc` starter, provides data
    source lookup and configuration, which can be used with any data access technology
    supported by Spring'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Spring Cloud AWS Messaging**: Included using `starter spring-cloud-starter-aws-messaging`
    starter, allows an application to send and receive messages with SQS (point-to-point)
    or SNS (Publish/Subscribe)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: There is another project that is worth mentioning although it is still at an
    early stage of development. That is Spring Cloud Function, which offers support
    for serverless architecture. Serverless is also known as **FaaS** (**Function-as-a-Service**),
    where a developer creates only very small modules that are deployed on containers fully
    managed by a third-party provider. Actually, Spring Cloud Functions implemented
    adapters for AWS Lambda and Apache OpenWhisk, the most popular FaaS providers.
    I will be following the development of this project designed for supporting a
    serverless approach.
  prefs: []
  type: TYPE_NORMAL
- en: In this section, we should not forget about the Spring Cloud Connectors project, formerly
    known as **Spring Cloud**. It provides an abstraction for JVM-based applications
    deployed on a cloud platform. Actually, it has support for Heroku and Cloud Foundry,
    where our application could connect SMTP, RabbitMQ, Redis, or one of the available
    relational databases using one of the Spring Cloud Heroku Connectors and Spring
    Cloud Foundry Connector modules.
  prefs: []
  type: TYPE_NORMAL
- en: Other useful libraries
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: There are some important aspects surrounding microservices architecture, which
    can't be considered its core features, but are also very important. The first
    of them is security.
  prefs: []
  type: TYPE_NORMAL
- en: Security
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The big part of standard implementation for securing APIs with mechanisms such
    as OAuth2, JWT, or basic authentication is available in Spring Security and Spring
    Web projects. Spring Cloud Security uses those libraries to allow us to easily
    create systems that implement common patterns such as single sign-on and token
    relay. To enable security management for our application we should include the `spring-cloud-starter-security`
    starter.
  prefs: []
  type: TYPE_NORMAL
- en: Automated testing
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The next important area in microservices development is automated testing.
    For microservices architecture, contact tests are growing in importance. Martin
    Fowler gave the following definition:'
  prefs: []
  type: TYPE_NORMAL
- en: '"An integration contract test is a test at the boundary of an external service
    verifying that it meets the contract expected by a consuming service."'
  prefs: []
  type: TYPE_NORMAL
- en: Spring Cloud has a very interesting implementation for that approach to unit
    testing, Spring Cloud Contract. It uses WireMock for traffic recording and Maven
    plugin for generating stubs.
  prefs: []
  type: TYPE_NORMAL
- en: It is also possible that you get the opportunity to use Spring Cloud Task. It
    helps a developer to create short lived microservices using Spring Cloud, and
    run them locally or in the cloud environment. To enable it in the project we should
    include the `spring-cloud-starter-task` starter.
  prefs: []
  type: TYPE_NORMAL
- en: Cluster features
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Finally, the last project, Spring Cloud Cluster. It provides a solution for
    the leadership election and common stateful patterns with an abstraction and implementation
    for Zookeeper, Redis, Hazelcast, and Consul.
  prefs: []
  type: TYPE_NORMAL
- en: Projects overview
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'As you can see, Spring Cloud contains many subprojects providing integration
    with lots of different tools and solutions. I think it is easy to lose track,
    especially if you are using Spring Cloud for the first time. In accordance with
    the principle that one diagram might express things better than a thousand words,
    I''m presenting the most important projects divided into categories as shown in
    the following diagram:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/b90c6536-0be0-4d4c-89ea-0aabea5a5eec.png)'
  prefs: []
  type: TYPE_IMG
- en: Release trains
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'As we can see in the preceding diagram, there are many projects inside Spring
    Cloud and there are many relationships between them. By definition, these are
    all independent projects with different release cascades and version numbers.
    In a situation like this, dependency management in our application might be problematic
    and that will require knowledge about relationships between versions of all projects.
    To help make it easier, Spring Cloud introduced the starter mechanism, which we
    have already discussed, and release trains. The release trains are identified
    by names, not versions, to avoid confusion with the subprojects. What is interesting
    is that they are named after London tube stations and they are alphabetically
    ordered. The first release was Angel,  the second was Brixton, and so on. The
    whole mechanism of dependency management is based on **BOM** (**bill of materials**),
    which is a standard Maven concept for managing artifacts versioned independently.
    Here''s an actual table with Spring Cloud project versions assigned to release
    trains. Names with the suffix M[*X*], where [*X*] is the version number, means
    **milestone**, SR[*X*] means **service release**, which refers to changes that
    fix critical bugs. As you can see in the following table, Spring Cloud Stream
    has it own release trains, which groups its subprojects using the same rules as
    Spring Cloud project:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Component** | **Camden.SR7** | **Dalston.SR4** | **Edgware.M1** | **Finchley.M2**
    | **Finchley.BUILD-SNAPSHOT** |'
  prefs: []
  type: TYPE_TB
- en: '| `spring-cloud-aws` | 1.1.4.RELEASE | 1.2.1.RELEASE | 1.2.1.RELEASE | 2.0.0.M1
    | 2.0.0.BUILD-SNAPSHOT |'
  prefs: []
  type: TYPE_TB
- en: '| `spring-cloud-bus` | 1.2.2.RELEASE | 1.3.1.RELEASE | 1.3.1.RELEASE | 2.0.0.M1
    | 2.0.0.BUILD-SNAPSHOT |'
  prefs: []
  type: TYPE_TB
- en: '| `spring-cloud-cli` | 1.2.4.RELEASE | 1.3.4.RELEASE | 1.4.0.M1 | 2.0.0.M1
    | 2.0.0.BUILD-SNAPSHOT |'
  prefs: []
  type: TYPE_TB
- en: '| `spring-cloud-commons` | 1.1.9.RELEASE | 1.2.4.RELEASE | 1.3.0.M1 | 2.0.0.M2
    | 2.0.0.BUILD-SNAPSHOT |'
  prefs: []
  type: TYPE_TB
- en: '| `spring-cloud-contract` | 1.0.5.RELEASE | 1.1.4.RELEASE | 1.2.0.M1 | 2.0.0.M2
    | 2.0.0.BUILD-SNAPSHOT |'
  prefs: []
  type: TYPE_TB
- en: '| `spring-cloud-config` | 1.2.3.RELEASE | 1.3.3.RELEASE | 1.4.0.M1 | 2.0.0.M2
    | 2.0.0.BUILD-SNAPSHOT |'
  prefs: []
  type: TYPE_TB
- en: '| `spring-cloud-netflix` | 1.2.7.RELEASE | 1.3.5.RELEASE | 1.4.0.M1 | 2.0.0.M2
    | 2.0.0.BUILD-SNAPSHOT |'
  prefs: []
  type: TYPE_TB
- en: '| `spring-cloud-security` | 1.1.4.RELEASE | 1.2.1.RELEASE | 1.2.1.RELEASE |
    2.0.0.M1 | 2.0.0.BUILD-SNAPSHOT |'
  prefs: []
  type: TYPE_TB
- en: '| `spring-cloud-cloudfoundry` | 1.0.1.RELEASE | 1.1.0.RELEASE | 1.1.0.RELEASE
    | 2.0.0.M1 | 2.0.0.BUILD-SNAPSHOT |'
  prefs: []
  type: TYPE_TB
- en: '| `spring-cloud-consul` | 1.1.4.RELEASE | 1.2.1.RELEASE | 1.2.1.RELEASE | 2.0.0.M1
    | 2.0.0.BUILD-SNAPSHOT |'
  prefs: []
  type: TYPE_TB
- en: '| `spring-cloud-sleuth` | 1.1.3.RELEASE | 1.2.5.RELEASE | 1.3.0.M1 | 2.0.0.M2
    | 2.0.0.BUILD-SNAPSHOT |'
  prefs: []
  type: TYPE_TB
- en: '| `spring-cloud-stream` | Brooklyn.SR3 | Chelsea.SR2 | Ditmars.M2 | Elmhurst.M1
    | Elmhurst.BUILD-SNAPSHOT |'
  prefs: []
  type: TYPE_TB
- en: '| `spring-cloud-zookeeper` | 1.0.4.RELEASE | 1.1.2.RELEASE | 1.2.0.M1 | 2.0.0.M1
    | 2.0.0.BUILD-SNAPSHOT |'
  prefs: []
  type: TYPE_TB
- en: '| `spring-boot` | 1.4.5.RELEASE | 1.5.4.RELEASE | 1.5.6.RELEASE | 2.0.0.M3
    | 2.0.0.M3 |'
  prefs: []
  type: TYPE_TB
- en: '| `spring-cloud-task` | 1.0.3.RELEASE | 1.1.2.RELEASE | 1.2.0.RELEASE | 2.0.0.M1
    | 2.0.0.RELEASE |'
  prefs: []
  type: TYPE_TB
- en: 'Now, all we need to do is provide the right release train name in the dependency
    management section in the Maven `pom.xml` and then include projects using starters:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'Here''s the same sample for Gradle:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, I have introduced the most important projects that are part
    of Spring Cloud. I have pointed out several areas to which I assigned each of
    those projects. After reading this chapter, you should be able to recognize which
    library has to be included in your application to able to implement patterns such
    as service discovery, distributed configuration, circuit breaker, or load balancer.
    You should also recognize the differences between application context, and bootstrap
    context and understand how to include dependencies in the project using dependency
    management based on the release trains concept. The last thing I wanted to draw
    your attention to in this chapter were some tools integrated with Spring Cloud
    such as Consul, Zookeeper, RabbitMQ, or Zipkin. I described all of them in some
    details. I also pointed out the projects responsible for interaction with those
    tools.
  prefs: []
  type: TYPE_NORMAL
- en: This chapter completes the first part of the book. In this part, the main goal
    was to get you into the basics related to Spring Cloud project. After reading
    it you should be able to recognize the most important elements of microservices-based
    architecture, effectively use Spring Boot to create simple and more advanced microservices,
    and finally, you should also be able to list all of the most popular subprojects
    being that are a part of Spring Cloud. Now, we may proceed to the next part of
    the book and discuss in detail those subprojects, which are responsible for implementing
    common patterns of distributed systems in Spring Cloud. Most of them are based
    on Netflix OSS libraries. We will begin with the solution providing service registry,
    Eureka discovery server.
  prefs: []
  type: TYPE_NORMAL
