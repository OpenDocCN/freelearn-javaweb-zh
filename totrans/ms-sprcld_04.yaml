- en: Service Discovery
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Before we got to this point, we had discussed service discovery many times in
    previous chapters. In fact, it is one of the most popular technical aspects of
    microservice architecture. Such a subject could not have been omitted from the
    Netflix OSS implementation. They did not decide to use any existing tool with
    similar features, but designed and developed a discovery server especially for
    their own needs. Then, it had been open sourced along with several other tools.
    The Netflix OSS discovery server is known as **Eureka**.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
- en: The Spring Cloud library for integration with Eureka consists of two parts,
    the client side and the server side. The server is launched as a separate Spring
    Boot application and exposes an API that allows for the collection of a list of
    registered services and adding a new service with a location address. The server
    can be configured and deployed to be highly available, with each server replicating
    its state with the others. The client is included in the microservice application
    as a dependency. It is responsible for the registration after startup, the deregistration
    before shutdown, and for keeping the registration list up to date by polling the
    Eureka Server.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
- en: 'Here''s a list of topics we will cover in this chapter:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
- en: Developing an application that runs embedded Eureka Server
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Connecting to the Eureka Server from the client-side application
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Advanced discovery client configuration
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Enabling secure communication between client and server
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Configuring failover and peer-to-peer replication mechanisms
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Registering instances of a client-side application in different zones
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Running Eureka on the server side
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Running the Eureka Server within a Spring Boot application is not a difficult
    task. Let''s take a look at how this can be done:'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
- en: 'First, the right dependency has to be included to our project. Obviously, we
    will use a starter for that:'
  id: totrans-12
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE0]'
  id: totrans-13
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Eureka Server should also be enabled on the main application class:'
  id: totrans-14
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE1]'
  id: totrans-15
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'It is interesting that together with the server starter, client''s dependencies
    are also included. They can be useful for us, but only when launching Eureka in
    high availability mode with peer-to-peer communication between discovery instances.
    When running a standalone instance, it doesn''t really get us anywhere except
    printing some errors in the logs during startup. We can either exclude `spring-cloud-netflix-eureka-client`
    from the starter dependencies or disable discovery client using configuration
    properties. I prefer the second choice, and also on this occasion, I changed the
    default server port to something other than `8080`. Here''s the fragment of the `application.yml`
    file:'
  id: totrans-16
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE2]'
  id: totrans-17
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: After completing the preceding steps, we can finally launch our first Spring
    Cloud application. Just run the main class from your IDE or build project with
    Maven; run it using the `java -jar` command and wait for the log line, `Started
    Eureka Server`. It's up. A simple UI dashboard is available as a home page at `http://localhost:8761`
    and HTTP API methods may be called with the `/eureka/*` path. The Eureka dashboard
    does not provide many features; in fact, it is mostly used for checking out the
    list of registered services. This could be found out by calling the REST API `http://localhost:8761/eureka/apps`
    endpoint.
  id: totrans-18
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: So, to conclude, we know how to run a Eureka standalone server with Spring Boot
    and how to check the list of registered microservices using the UI console and
    HTTP methods. But we still don't have any service that is able to register itself
    in discovery, and it's time to change that. An example application with a discovery
    server and client implementation is available on GitHub ([https://github.com/piomin/sample-spring-cloud-netflix.git](https://github.com/piomin/sample-spring-cloud-netflix.git))
    in the `master` branch.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
- en: Enabling Eureka on the client side
  id: totrans-20
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'As on the server side, there is only one dependency that has to be included
    to enable a Eureka Client for the application. So, first include the following
    starter to your project''s dependencies:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  id: totrans-22
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'The example application does nothing more than communicate with the Eureka
    Server. It has to register itself and send metadata information such as host,
    port, health indicator URL, and home page. Eureka receives heartbeat messages
    from each instance belonging to a service. If the heartbeat isn''t received after
    a configured period of time, the instance is removed from the registry. The second
    responsibility of discovery client is fetching data from the server, then caching
    it and periodically asking for changes. It can be enabled by annotating the main
    class with `@EnableDiscoveryClient`. Surprisingly, there is another way to activate
    this feature. You may use an annotation `@EnableEurekaClient`, especially if there
    are multiple implementations of discovery client within the classpath (Consul,
    Eureka, ZooKeeper). While `@EnableDiscoveryClient` lives in `spring-cloud-commons`,
    `@EnableEurekaClient` lives in `spring-cloud-netflix` and only works for Eureka.
    Here''s the main class of the discovery client''s application:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'The discovery server address doesn''t have to be provided in the client''s
    configuration, because it is available on the default host and port. However,
    we could easily imagine that Eureka is not listening on its default `8761` port.
    The fragment of configuration file is visible below. The discovery server network
    address can be overridden with the `EUREKA_URL` parameter, as can the client''s
    listening port with the `PORT` property. The name under which the application
    is registered in the discovery server is taken from the `spring.application.name`
    property:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  id: totrans-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Let''s run two independent instances of our sample client application on localhost.
    To achieve that, the number of the listening port should be overridden for the
    instance on startup like this:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'As you can see in the following screenshot, there are two instances of `client-service`
    registered with the hostname `piomin` and ports `8081 `and `8082`:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/5b172c1a-67fb-4dfe-a0fb-3249d94261e8.png)'
  id: totrans-30
  prefs: []
  type: TYPE_IMG
- en: Deregistration on shutdown
  id: totrans-31
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Checking how a deregistration works with a Eureka Client is a bit more of a
    difficult task. Our application should be shut down gracefully in order to be
    able to intercept a stopped event and send an event to the server. The best way
    for a graceful shutdown is by using the Spring Actuator `/shutdown` endpoint.
    The actuator is a part of Spring Boot and it can be included in the project by
    declaring the `spring-boot-starter-actuator` dependency in `pom.xml`. It is disabled
    by default, so we have to enable it in the configuration properties. For the sake
    of simplicity, it is worth disabling user/password security for that endpoint:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'To shut down the application, we have to call the `POST /shutdown` API method.
    If you receive the response `{"message": "Shutting down, bye..."}`, it means everything
    went well and the procedure has been started. Before the application is disabled,
    some logs starting from the line Shutting down DiscoveryClient ...will be printed
    out. After that, the service will be unregistered from the discovery server and
    it completely disappears from the list of registered services. I decided to shut
    down client instance #2 by calling `http://localhost:8082/shutdown` (you may call
    it using any REST client, for example, Postman), so only the instance running
    on port `8081` is still visible in the dashboard:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/0aea89ae-bdfb-43be-9acc-0e13ebf666f9.png)'
  id: totrans-35
  prefs: []
  type: TYPE_IMG
- en: 'The Eureka Server dashboard also provides a convenient way to check out the
    history of newly created and canceled leases:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/097c33ca-f38d-4501-a15f-1051ccf56d4b.png)'
  id: totrans-37
  prefs: []
  type: TYPE_IMG
- en: Graceful shutdown is obviously the most suitable way of stopping an application,
    but in the real world, we are not always able to achieve it. Many unexpected things
    can happen, such as a server machine restart, application failure, or just network
    problems at the interface between client and server. Such a situation is the same
    from a discovery server point of view as stopping the client application from
    your IDE or killing the process from the command line. If you try to do that,
    you will see that the discovery client shutdown procedure won't be triggered and
    the service is still visible in the Eureka dashboard with the *UP* status. Moreover,
    the lease will never expire.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
- en: 'In order to avoid this situation, the default configuration on the server side
    should be changed. *Why does such a problem appear in the default settings?* Eureka
    provides a special mechanism by which the registry stops expiring entries when
    it detects that an certain number of services didn''t renew their lease in time.
    This should protect the registry from clearing all entries when a part of a network
    failure occurs. That mechanism is called **self-preservation mode** and can be
    disabled using the `enableSelfPreservation` property in `application.yml`. Of
    course, it should not be disabled in production:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Using discovery client programmatically
  id: totrans-41
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'After client application startup, the list of registered services is fetched
    from the Eureka Server automatically. However, it might turn out to be necessary
    to use Eureka''s client API programmatically. We have two possibilities:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
- en: '`com.netflix.discovery.EurekaClient`: It implements all HTTP API methods exposed
    by the Eureka Server, which have been described in the Eureka API section.'
  id: totrans-43
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`org.springframework.cloud.client.discovery.DiscoveryClient`: It is a Spring
    Cloud alternative to the native Netflix `EurekaClient`. It provides a simple,
    generic API useful for all of the discovery clients. There are two methods available, `getServices`
    and `getInstances`:'
  id: totrans-44
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE9]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: There is one interesting thing related to the preceding implementation. If you
    call the `/ping` endpoint just after the service startup, it won't display any
    instances. This is related to the response caching mechanisms and it is described
    in detail in the next section.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
- en: Advanced configuration settings
  id: totrans-47
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Eureka''s configuration settings may be divided into three parts:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
- en: '**Server**: It customizes the server behavior. It includes all of the properties
    with the prefix `eureka.server.*`. The full list of available fields may be found
    in the `EurekaServerConfigBean` class ([https://github.com/spring-cloud/spring-cloud-netflix/blob/master/spring-cloud-netflix-eureka-server/src/main/java/org/springframework/cloud/netflix/eureka/server/EurekaServerConfigBean.java](https://github.com/spring-cloud/spring-cloud-netflix/blob/master/spring-cloud-netflix-eureka-server/src/main/java/org/springframework/cloud/netflix/eureka/server/EurekaServerConfigBean.java)).'
  id: totrans-49
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Client**: It is the first of two available property sections on the Eureka
    Client''s side. It is responsible for the configuration of how the client can
    query the registry in order to locate other services. It includes all of the properties
    with the prefix `eureka.client.*`. For the full list of available fields, you
    may refer to the `EurekaClientConfigBean` class ([https://github.com/spring-cloud/spring-cloud-netflix/blob/master/spring-cloud-netflix-eureka-client/src/main/java/org/springframework/cloud/netflix/eureka/EurekaClientConfigBean.java](https://github.com/spring-cloud/spring-cloud-netflix/blob/master/spring-cloud-netflix-eureka-client/src/main/java/org/springframework/cloud/netflix/eureka/EurekaClientConfigBean.java)).'
  id: totrans-50
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Instance**: It customizes the current instance of the Eureka Client''s behavior,
    such as port or name. It includes all of the properties with the prefix `eureka.instance.*`. For
    the full list of available fields, you may refer to the `EurekaInstanceConfigBean` class ([https://github.com/spring-cloud/spring-cloud-netflix/blob/master/spring-cloud-netflix-eureka-client/src/main/java/org/springframework/cloud/netflix/eureka/EurekaInstanceConfigBean.java](https://github.com/spring-cloud/spring-cloud-netflix/blob/master/spring-cloud-netflix-eureka-client/src/main/java/org/springframework/cloud/netflix/eureka/EurekaInstanceConfigBean.java)).'
  id: totrans-51
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: I have already shown you how to use some of those properties in order to have
    the desired effect. I'm going to talk about some interesting scenarios related
    to configuration settings customization in the next part of this section. It is
    not needed to describe all of the properties. You may read about them in the comments
    included in the source code of all of those classes that were listed previously.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
- en: Refreshing the registry
  id: totrans-53
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s back up for a moment to the previous sample. Self-preservation mode
    has been disabled, but it still takes a long time to wait on the lease cancellation
    by the server. There are several reasons for this. The first is that every client
    service sends heartbeats to the server every 30 seconds (default value), which
    is configurable with the `eureka.instance.leaseRenewalIntervalInSeconds` property. If
    the server doesn''t receive a heartbeat, it waits 90 seconds before removing the
    instance from the registry and thereby cutting off traffic sent to that instance. It
    is configurable with the `eureka.instance.leaseExpirationDurationInSeconds` property.
    Those two parameters are set on the client side. For testing purposes, we define
    small values in seconds:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'There is also one property that should be changed on the server side. Eureka
    runs the evict task in the background, which is responsible for checking whether
    heartbeats from the client are still being received. By default, it is fired every
    60 seconds. So even if the interval of lease renewal and the duration of lease
    expiration are set to relatively low values, the service instance might be removed
    at worst after 60 seconds. The delay between the subsequent timer ticks can be
    configured using the `evictionIntervalTimerInMs` property, which is set, in contrast
    to properties discussed previously, in milliseconds:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'All of the required parameters have been defined on both the client and server
    side. Now, we can run the discovery server again and then three instances of the
    client application on ports `8081`, `8082`, and `8083` using the `-DPORT` VM argument.
    After that, we will shut down the instances on ports `8081 `and `8082` one by
    one, just by killing their processes. What is the result? The disabled instances
    are almost immediately removed from Eureka registry. Here''s the log fragment
    from the Eureka Server:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/9053350f-ae07-434c-ab43-4e1040362e37.png)'
  id: totrans-59
  prefs: []
  type: TYPE_IMG
- en: 'There is still one instance available running on port `8083`. The appropriate
    warning related to the deactivation of the self-preservation mode will be printed
    out on the UI dashboard. Some additional information such as lease expiration
    status or the number of renews during the last minute may also be interesting. By
    manipulating all of those properties, we are able to customize the maintenance
    of the expired lease removal procedure. However, it is important to ensure that
    defined settings would not lack the performance of a system. There are some other
    elements sensitive to the changes of configuration, like load balancers, gateways,
    and circuit breakers. Eureka prints a warning message if you disable the self-preservation
    mode, you can see it in the following screenshot:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/18a93209-3951-4751-a9a2-d1810cbace4e.png)'
  id: totrans-61
  prefs: []
  type: TYPE_IMG
- en: Changing the instance identificator
  id: totrans-62
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Instances registered on Eureka are grouped by name, but each of them must send
    a unique ID, on the basis of which, the server is able to recognize it. Maybe
    you have noticed that `instanceId` is displayed in the dashboard for every service''s
    group in the Status column. Spring Cloud Eureka automatically generates that number
    and it is equal to the combination of the following fields:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'This identificator may be easily overridden with the `eureka.instance.instanceId`
    property. For testing purposes, let''s launch some instances of the client application
    with the following configuration settings and the `-DSEQUENCE_NO=[n]` VM argument,
    where `[n]` is a sequence number starting from `1`. Here''s a sample configuration
    of a client''s application that dynamically sets the listen port and discovery
    `instanceId` based on the `SEQUENCE_NO` parameter:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'The results may be viewed in the Eureka dashboard:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/fdb301da-0900-4cbf-abef-b084cbf557b9.png)'
  id: totrans-68
  prefs: []
  type: TYPE_IMG
- en: Preferring the IP address
  id: totrans-69
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: By default, all instances are registered under their hostname. It is a very
    convenient approach, on the assumption that we have DNS enabled on our network.
    However, it is not uncommon that DNS is not available for a group of servers used
    as the microservice environment in the organization. I just had that kind of situation
    myself. There remains nothing else to do but to add host names and their IP addresses
    to the `/etc/hosts` file on all of the Linux machines. An alternative to this
    solution is to change the registration process configuration settings to advertise
    the IP addresses of services rather than the hostname. To achieve this, the `eureka.instance.preferIpAddress` property should
    be set to `true` on the client side. Every service instance in the registry will
    still be printed out to a Eureka dashboard with `instanceId` containing a hostname,
    but if you click this link the redirection will be performed based on the IP address.
    The Ribbon client that is responsible for calling other services via HTTP will
    also follow the same principle.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
- en: 'If you decide to use an IP address as a primary method of determining the network
    location of the service, you may have a problem. The problem may arise if you
    have more than one network interface assigned to your machine. For example, in
    one organization where I have been working, there were different networks for
    a management mode (a connection from my workstation to the server) and for a production
    mode (a connection between two servers). In consequence, each server machine had
    two network interfaces assigned with different IP prefixes. To select the right
    interface, you can define a list of ignored patterns in the `application.yml`
    configuration file. For example, we would like to ignore all interfaces where
    the name starts with `eth1`:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'There is also another way to get that effect. We can define network addresses
    that should be preferred:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Response cache
  id: totrans-75
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The Eureka Server caches responses by default. The cache is invalidated every
    30 seconds. It can be easily checked by calling the HTTP API endpoint `/eureka/apps`.
    If you call it just after the registration of the client application, you will
    figure out that it is still not returned in the response. Try again after 30 seconds,
    and you will see that the new instance appears. The response cache timeout may
    be overridden with the `responseCacheUpdateIntervalMs` property. Interestingly,
    there is no cache while displaying a list of registered instances using the Eureka
    dashboard. In contrast to the REST API, it bypasses the response cache:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'We should remember that the Eureka registry is also cached on the client side.
    So, even if we changed the cache timeout on the server, it may still take some
    time until it would be refreshed by the client. The registry is periodically refreshed
    in an asynchronous, background task that is scheduled every 30 seconds by default. 
    This setting may be overridden by declaring the `registryFetchIntervalSeconds` property.
    It only fetches the delta in comparison to the last fetch attempt. This option
    may be disabled using the `shouldDisableDelta` property. I defined `3` seconds
    timeouts on both the server and client sides. If you start the sample application
    with such settings, `/eureka/apps` will show the newly registered instance of
    the service, probably at your first attempt. Unless caching on the client side
    makes sense, I''m not sure about the sense of caching on the server side, especially
    since Eureka doesn''t have any backend store. Personally, I have never had any
    need to change the values of those properties, but I guess it can be important,
    for example, if you develop unit tests with Eureka and you need an immediate response
    without caching:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Enabling secure communication between client and server
  id: totrans-80
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Until now, none of the client''s connections were being authenticated by the
    Eureka Server. While in the development mode, security doesn''t really matter
    as much as in the production mode. The lack of it may be a problem. We would like
    to have, as a bare minimum, the discovery server secured with basic authentication
    to prevent unauthorized access to any service that knows its network address.
    Although Spring Cloud reference material claims that *HTTP basic authentication
    will be automatically added to your Eureka Client*, I had to include a starter
    with security to the project dependencies:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Then, we should enable security and set the default credentials by changing
    the configuration settings in the `application.yml` file:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Now, all HTTP API endpoints and the Eureka dashboard are secured. To enable
    the basic authentication mode on the client side, the credentials should be provided
    within the URL connection address, as you can see in the following configuration
    settings. An example application that implements secure discovery is available
    in the same repository ([https://github.com/piomin/sample-spring-cloud-netflix.git](https://github.com/piomin/sample-spring-cloud-netflix.git))
    as the basic example, but you need to switch to the `security` branch ([https://github.com/piomin/sample-spring-cloud-netflix/tree/security](https://github.com/piomin/sample-spring-cloud-netflix/tree/security)).
    Here''s the configuration that enabled HTTP basic authentication on the client
    side:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: For more advanced use, such as secure SSL connection with certificate authentication between
    discovery client and server, we should provide a custom implementation of `DiscoveryClientOptionalArgs`.
    We will discuss such an example in [Chapter 12](b7e73d3e-b31b-4127-bb1a-54f527ac98a8.xhtml),
    *Securing an API*, specifically dedicated to security for Spring Cloud applications.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
- en: Registering a secure service
  id: totrans-88
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Securing the server side is one thing; registering a secure application is
    something else. Let''s look at how we can do this:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
- en: 'To enable SSL for a Spring Boot application, we need to start with generating
    a self-signed certificate. I recommend you use `keytool` for that, which is available
    under your JRE root in the `bin` catalog:'
  id: totrans-90
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE21]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Enter the required data and copy the generated keystore file `keystore.p12`
    to your application''s `src/main/resources` catalog. The next step is to enable
    HTTPS for Spring Boot using configuration properties in `application.yml`:'
  id: totrans-92
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE22]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'After running the application, you should be able to call the secure endpoint
    `https://localhost:8761/info`. We also need to perform some changes in the Eureka
    client instance configuration:'
  id: totrans-94
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE23]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: Eureka API
  id: totrans-96
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Spring Cloud Netflix provides a client written in Java that hides the Eureka
    HTTP API from the developer. In case we use other frameworks than Spring, Netflix
    OSS provides a vanilla Eureka client that can be included as a dependency. However,
    we may imagine a need to call the Eureka API directly, for example, if the application
    is written in another language than Java, or we need such information as a list
    of registered services in the Continuous Delivery process. Here''s a table for
    quick reference:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
- en: '| **HTTP endpoint** | **Description** |'
  id: totrans-98
  prefs: []
  type: TYPE_TB
- en: '| `POST /eureka/apps/appID` | Add a new instance of the service to the registry
    |'
  id: totrans-99
  prefs: []
  type: TYPE_TB
- en: '| `DELETE /eureka/apps/appID/instanceID` | Remove the instance of the service
    from the registry |'
  id: totrans-100
  prefs: []
  type: TYPE_TB
- en: '| `PUT /eureka/apps/appID/instanceID` | Send a heartbeat to the server |'
  id: totrans-101
  prefs: []
  type: TYPE_TB
- en: '| `GET /eureka/apps` | Get details about the list of all registered instances
    of services |'
  id: totrans-102
  prefs: []
  type: TYPE_TB
- en: '| `GET /eureka/apps/appID`  | Get details about the list of all registered
    instances of a specific service |'
  id: totrans-103
  prefs: []
  type: TYPE_TB
- en: '| `GET /eureka/apps/appID/instanceID` | Get details about a single instance
    of the service |'
  id: totrans-104
  prefs: []
  type: TYPE_TB
- en: '| `PUT /eureka/apps/appID/instanceID/metadata?key=value` | Update metadata
    parameters |'
  id: totrans-105
  prefs: []
  type: TYPE_TB
- en: '| `GET /eureka/instances/instanceID` | Get details about all registered instances
    with a specific ID  |'
  id: totrans-106
  prefs: []
  type: TYPE_TB
- en: '| `PUT /eureka/apps/appID/instanceID/status?value=DOWN` | Update the status
    of the instance |'
  id: totrans-107
  prefs: []
  type: TYPE_TB
- en: Replication and high availability
  id: totrans-108
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We have already discussed some useful Eureka settings, but until now we have
    analyzed only a system with a single service discovery server. Such a configuration
    is valid, but only in development mode. For production mode, we would like to
    have at least two discovery servers running in case one of them fails or a network
    problem occurs. Eureka is by definition built for availability and resiliency,
    two primary pillars of development at Netflix. But it does not provide standard
    clustering mechanisms such as leadership election or automatically joining to
    the cluster. It is based on the peer-to-peer replication model. It means that
    all of the servers replicate data and send heartbeats to all of the peers, which
    are set in configuration for the current server node. Such an algorithm is simple
    and effective for containing data, but it also has some drawbacks. It limits scalability,
    because every node has to withstand the entire write load on the server.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
- en: Architecture of the sample solution
  id: totrans-110
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Interestingly, a replication mechanism was one of the major motivations to begin
    work on the new version of the Eureka Server. Eureka 2.0 is still under active
    development. Besides optimized replication, it will also provide some interesting
    features such as a push model from the server to clients for any changes in the
    registration list, auto-scaled servers, and a rich dashboard. This solution seems
    promising, but Spring Cloud Netflix still uses version 1 and to be honest I was
    not able to find any plans for the migration to version 2\. The current Eureka
    version for Dalston.SR4 Release Train is 1.6.2\. The configuration of the clustering
    mechanism on the server side comes down to one thing, the set URL of another discovery
    server using `eureka.client.*` properties section. The selected server would just
    register itself in the other servers, which were chosen to be a part of the created
    cluster. The best way to show how this solution works in practice is of course
    by example.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s begin with the architecture of the example system, which is shown in
    the following diagram. All of our applications will be run locally on different
    ports. At this stage, we have to introduce the example of the API gateway based
    on Netflix Zuul. It would be helpful for the purpose of load balancing tests between
    three instances of a service registered in different zones:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/39bca4a7-e902-4c34-bdd1-b5118fd74640.png)'
  id: totrans-113
  prefs: []
  type: TYPE_IMG
- en: Building the example application
  id: totrans-114
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'For the Eureka Server, all of the required changes may be defined in configuration
    properties. In the `application.yml` file, I defined three different profiles
    for each instance of the discovery service. Now, if you try to run Eureka Server
    embedded in the Spring Boot application, you need to activate the specific profile
    by providing the VM argument `-Dspring.profiles.active=peer[n]`, where `[n]` is
    the instance sequence number:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'After running all three instances of Eureka using different profile names,
    we created a local discovery cluster. If you take a look at the Eureka dashboard
    for any instance just after startup, it always looks the same, we have three instances
    of DISCOVERY-SERVICE visible:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/82c4f7d9-4624-4b6b-ae20-729088d40aff.png)'
  id: totrans-118
  prefs: []
  type: TYPE_IMG
- en: 'The next step is to run the client application. The configuration settings
    in the projects are very similar to those for the application with the Eureka
    Server. The order of addresses provided in the `defaultZone` field determines
    the sequence of connection attempts to different discovery services. If the connection
    to the first server cannot be established, it tries to connect with the second
    one from the list, and so on. The same as earlier, we should set the VM argument `-Dspring.profiles.active=zone[n]` 
    to select the right profile. I also suggest you set the `-Xmx192m` parameter,
    keeping in mind that we test all of the services locally. If you do not provide
    any memory limits for the Spring Cloud application it consumes around 350 MB of
    heap after starting, and about 600 MB of total memory. Unless you have got a lot
    of RAM it may make it difficult to run multiple instances of microservices on
    your local machine:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Let''s take a look at the Eureka dashboard again. We have three instances of
    `client-service` registered everywhere, although the application has been originally
    connected to only one instance of the discovery service. The result is the same
    no matter which discovery service instance''s dashboard we go into to look at.
    It was the exact purpose of this exercise. Now, we create some additional implementation
    only to demonstrate that everything works in accordance with the assumptions:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/8fd6c50b-fd76-4f61-8b37-2459cbbf63f0.png)'
  id: totrans-122
  prefs: []
  type: TYPE_IMG
- en: 'The client application does nothing more than expose a REST endpoint that prints
    the selected profile name. The profile name points to the primary discovery service
    instance for the particular application instance. Here''s a simple `@RestController`
    implementation that prints the name of the current zone:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Finally, we can proceed to the implementation of API gateway. It''s out of
    the scope of this chapter to go into detail about features provided by Zuul, Netflix''s
    API gateway, and router. We will discuss it in the next chapters. Zuul will now
    be helpful in testing our sample solution, because it is able to retrieve the
    list of services registered in the discovery server and perform load balancing
    between all of the running instances of the client application. As you can see
    in the following configuration fragment, we use a discovery server listening on
    port `8763`. All incoming requests with the `/api/client/**` path would be routed
    to `client-service`:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'Let''s move on to the testing. Our application with the Zuul proxy should be
    launched using the `java -jar` command and unlike previous services, there is
    no need to set any additional parameters, including a profile name. It is connected
    by default with discovery service number #3\. To invoke the client API via the
    Zuul proxy, you have to type the following address into your web browser, `http://localhost:8765/api/client/ping`.
    The result is visible in the following screenshot:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/82dce964-212f-4a2b-8fd2-f8aa4db10fdc.png)'
  id: totrans-128
  prefs: []
  type: TYPE_IMG
- en: 'If you retry the request a few times in a row, it should be load balanced between
    all of the existing `client-service` instances in the proportions 1:1:1, although
    our gateway is connected only to discovery #3\. This example fully demonstrates
    how to build service discovery with multiple Eureka instances.'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
- en: The preceding example application is available on GitHub ([https://github.com/piomin/sample-spring-cloud-netflix.git](https://github.com/piomin/sample-spring-cloud-netflix.git))
    in the `cluster` branch ([https://github.com/piomin/sample-spring-cloud-netflix/tree/cluster_no_zones](https://github.com/piomin/sample-spring-cloud-netflix/tree/cluster_no_zones)).
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
- en: Failover
  id: totrans-131
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'You probably wish to ask what''s going to happen if one instance of service
    discovery breaks down? In order to check how the cluster would behave in case
    of failure, we are going to modify the earlier sample a little. Now, Zuul has
    a failover connection to the second service discovery available on port `8762` set
    in its configuration settings. For testing purposes, we shut down the third instance
    of the discovery service available on port `8763`:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'The current situation is illustrated in the following diagram. Testing is performed
    in the same way as earlier, by calling the gateway''s endpoint available under
    the `http://localhost:8765/api/client/ping address`. And the result is also the
    same as for the previous test, load balancing is performed equally among all three
    `client-service` instances as expected. Although discovery service #3 has been
    disabled, two other instances are still able to communicate with each other and
    have information about the network location of the third client application instance
    replicated from instance #3 as long as it was active. Now, even if we restart
    our gateway, it is still able to connect the discovery cluster using the second
    address in order, set inside the `defaultZone` field `http://localhost:8762/eureka`.
    The same applies to the third instance of the client application, which in turn
    has discovery service #1 as a backup connection:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/6a432d7f-3bbb-4afb-89e2-a306aa26fa2d.png)'
  id: totrans-135
  prefs: []
  type: TYPE_IMG
- en: Zones
  id: totrans-136
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'A cluster-based on a peer-to-peer replication model is a good way to go in
    most cases, but not always enough. Eureka has one more interesting feature that
    can be very useful in a clustered environment. A zone mechanism is, in fact, the
    default behavior. Even if we have a single standalone service discovery instance,
    every client''s property has to be set to `eureka.client.serviceUrl.defaultZone`
    in the configuration settings. When will this be useful to us? To analyze it,
    we go back to the example from the previous section. Let''s imagine that now we
    have our environment divided into three different physical networks, or we just
    have three different machines processing the incoming requests. Of course, discovery
    services are still grouped logically in the cluster, but each instance is placed
    in a separated zone. Every client application would be registered in the same
    zone as its main discovery server. Instead of one instance of the Zuul gateway,
    we are going to launch three instances, each one for a single zone. If the request
    comes into a gateway, it should prefer those clients that leverage services within
    the same zone before trying to call services registered in another zone. The current
    system architecture is visualized in the following diagram. Of course, for example
    purposes, the architecture was simplified to be able to run on a single local
    machine. In the real world, like I mentioned before, it would be launched on three
    different machines or even on three different groups of machines, physically separated
    into other networks:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/76b111a0-a8bf-4152-bc6b-da28a8e922c4.png)'
  id: totrans-138
  prefs: []
  type: TYPE_IMG
- en: Zones with a standalone server
  id: totrans-139
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'At this stage, we should emphasize one important thing, the zoning mechanism
    is realized only on the client side. This means that the service discovery instance
    is not assigned to any zone. So the preceding diagram may be slightly confusing,
    but it indicates which Eureka is the default service discovery for all client
    applications and gateways registered in the specific zone. Our purpose is to check
    out the mechanisms in the high availability mode, but we may as well build it
    only with a single discovery server. The following diagram illustrates a similar
    situation as the previous diagram, except that it assumes the existence of only
    a single discovery server for all of the applications:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/d2c54f1c-e08d-48f7-a360-5ae1a1153c36.png)'
  id: totrans-141
  prefs: []
  type: TYPE_IMG
- en: Building an example application
  id: totrans-142
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To enable zone handling, we need to perform some changes in the client''s and
    gateway''s configuration settings. Here''s a modified `application.yml` file from
    the client application:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: The only thing that had to be updated is the `eureka.instance.metadataMap.zone `property,
    where we set the names of the zone and our service had been registered.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
- en: 'More changes have to be made in the gateway configuration. First, we need to
    add three profiles to be able to run an application registered in three different
    zones and three different discovery servers. Now when launching the gateway application,
    we should set the VM argument `-Dspring.profiles.active=zone[n]` to select the
    right profile. Similar to `client-service`, we also had to add the `eureka.instance.metadataMap.zone`
    property within the configuration settings. There is also one property, `eureka.client.preferSameZoneEureka`,
    used for the first time in the example, which had to be equal to `true` if the
    gateway should prefer instances of the client application registered in the same
    zone:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'After launching all of the instances of discovery, client, and gateway applications,
    we can try to call endpoints available under the `http://localhost:8765/api/client/ping`,
    `http://localhost:8766/api/client/ping`, and `http://localhost:8767/api/client/ping`
    addresses. Every one of them would always be communicating with the client instance
    registered in the same zone. So in contrast to tests without a preferred zone,
    for example, the first instance of gateway available under port `8765` always
    prints I''m in zone zone1 while calling the ping endpoint:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/df5918ad-c4b6-477b-a705-6ff4a7ba736d.png)'
  id: totrans-149
  prefs: []
  type: TYPE_IMG
- en: 'What will happen when client #1 is not available? The incoming requests would
    be load balanced 50/50 between two other instances of the client application,
    because they are both in different zones than gateway #1.'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  id: totrans-151
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we had the opportunity to develop applications using Spring
    Cloud for the first time in this book. In my opinion, the best way to start an
    adventure with a framework for microservices is with trying to figure out how
    to implement service discovery properly. Starting with the simplest use cases
    and examples, we have been going through advanced and production-ready features
    provided by the Netflix OSS Eureka project. I have shown you how to create and
    run a basic client and a standalone discovery server in *five minutes*. Based
    on that implementation, I have introduced how to customize the Eureka client and
    server to meet our specific needs, placing the emphasis on negative scenarios
    such as network or application failure. Such features as the REST API or UI dashboard
    have been discussed in detail. Finally, I have shown you how to create a production-ready
    environment using Eureka's mechanisms such as replication, zones, and high availability.
    With that knowledge, you should be able to choose those features of Eureka through
    which you build a service discovery adapted to the specifics of your microservice-based
    architecture.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
- en: Once we have discussed service discovery, we may proceed to the next essential
    element in microservice-based architecture, a configuration server. Both discovery
    and configuration services are usually based on key/value stores, so they may
    be provided with the same products. However, since Eureka is dedicated only to
    discovery, Spring Cloud introduces their own framework for managing distributed
    configurations, Spring Cloud Config.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们讨论了服务发现，我们就可以继续探讨微服务架构中的下一个关键元素：配置服务器。服务和配置服务通常都基于键/值存储，因此它们可能由相同的产品提供。然而，由于Eureka只专注于发现，Spring
    Cloud引入了自己的框架来管理分布式配置，即Spring Cloud Config。
