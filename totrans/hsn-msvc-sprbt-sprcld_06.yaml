- en: Adding an API Description Using OpenAPI/Swagger
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The value of an API, such as a RESTful service, to a large extent depends on
    how easy it is to consume! Good and easily accessible documentation is an important
    part of whether an API is useful. In this chapter, we will learn how we can use
    OpenAPI/Swagger to document APIs that we can make externally accessible from a
    microservice landscape.
  prefs: []
  type: TYPE_NORMAL
- en: As we mentioned in [Chapter 2](7d969006-ea94-4bbb-858d-30dce8177a2c.xhtml), *Introduction
    to Spring Boot*, Swagger is one of the most commonly used specifications when
    it comes to documenting RESTful services, and many of the leading API gateways
    have native support for Swagger. We will learn how to use SpringFox to produce
    such documentation, the kind of changes in source code required to document the
    eternal API using SpringFox. We will try out Swagger documentation, which shows
    how to use an embedded Swagger viewer to both inspect the documentation and to
    try out the API.
  prefs: []
  type: TYPE_NORMAL
- en: By the end of this chapter, we will have Swagger-based API documentation about
    the external API that's exposed by the `product-composite-service` microservice.
    We will be able to use an embedded Swagger viewer to both visualize and test the
    API.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following topics will be covered in this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: Introduction to using SpringFox
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Changes in the source code
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Building and starting the microservice
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Trying out the Swagger documentation
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: All of the commands that are described in this book are run on a MacBook Pro
    using macOS Mojave, but should be straightforward to modify if you want to run
    them on another platform such as Linux or Windows.
  prefs: []
  type: TYPE_NORMAL
- en: No new tools need to be installed before you can work through this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: The source code for this chapter can be found in this book's GitHub repository: [https://github.com/PacktPublishing/Hands-On-Microservices-with-Spring-Boot-and-Spring-Cloud/tree/master/Chapter05](https://github.com/PacktPublishing/Hands-On-Microservices-with-Spring-Boot-and-Spring-Cloud/tree/master/Chapter05).
  prefs: []
  type: TYPE_NORMAL
- en: 'To be able to run the commands that are described in this book, download the
    source code to a folder and set up an environment variable, `$BOOK_HOME`, that
    points to that folder. Some sample commands are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: The Java source code in this book has been written for Java 8 and tested on
    Java 12. This chapter uses Spring Boot 2.1.0 (and Spring 5.1.2), which is the
    latest available version of Spring Boot at the time of writing this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: The code examples in this chapter all come from the source code in `$BOOK_HOME/Chapter05` but
    have been, in many cases, edited to remove irrelevant parts of the source code,
    such as comments, imports, and log statements.
  prefs: []
  type: TYPE_NORMAL
- en: If you want to view the changes that were applied to the source code in this
    chapter, that is, see what it took to create Swagger-based API documentation using
    SpringFox, you can compare it with the source code for [Chapter 4](ce37c0f1-ac54-4258-8cb6-7c6f50f26172.xhtml),
    *Deploying Our Microservices Using Docker*. You can use your favorite `diff` tool
    and compare the two folders, that is, `$BOOK_HOME/Chapter04` and `$BOOK_HOME/Chapter05`.
  prefs: []
  type: TYPE_NORMAL
- en: Introduction to using SpringFox
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: SpringFox makes it possible to keep the documentation of the API together with
    the source code that implements the API. To me, this is an important feature.
    If the API documentation is maintained in a separate life cycle from the Java
    source code, they will diverge from each other over time. In many cases, this
    is sooner than expected (from my experience). As always, it is important to separate
    the interface of a component from its implementation. In terms of documenting
    a RESTful API, we should add the API documentation to the Java interface that
    describes the API, and not to the Java class that implements the API. To simplify
    updating the documentation of the API, we can place parts of the documentation
    in property files instead of in the Java code directly.
  prefs: []
  type: TYPE_NORMAL
- en: In 2015, SmartBear Software donated the Swagger specification to the Linux Foundation
    under the OpenAPI Initiative and created the OpenAPI Specification. To create
    the API documentation, we will use **SpringFox**, which can create Swagger-based
    API documentation at runtime.
  prefs: []
  type: TYPE_NORMAL
- en: 'It does this based on a configuration that we supply and by inspecting annotations
    that have been provided by Spring WebFlux and Swagger:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/4b24888c-15c8-42ed-8f85-99bff144857c.png)'
  prefs: []
  type: TYPE_IMG
- en: Support for OpenAPI has been planned for v3 of SpringFox. SpringFox V3 was still
    under development at the time of writing this chapter, so we will use a snapshot
    version of SpringFox V3 and create the API documentation based on Swagger V2\.
    Once SpringFox V3 has been released, the source code for this book will be updated.
  prefs: []
  type: TYPE_NORMAL
- en: To enable SpringFox so that we can create the API documentation, we will set
    up a base configuration for SpringFox and add annotations to the Java interfaces
    that define the RESTful services.
  prefs: []
  type: TYPE_NORMAL
- en: If parts of the documentation have been placed in property files to simplify
    updating the API documentation, it is important that the property files are handled
    in the same life cycle and under the same version control as the source code,
    otherwise there is a risk that they will start to diverge from the implementation,
    that is, become out of date.
  prefs: []
  type: TYPE_NORMAL
- en: Changes in the source code
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To add Swagger-based documentation about the external API that''s exposed by
    the `product-composite-service` microservice, we need to change the source code
    in two modules:'
  prefs: []
  type: TYPE_NORMAL
- en: '`product-composite-services`: Here, we will set up a SpringFox configuration
    in the Java application class, `ProductCompositeServiceApplication`, and describe
    general information about the API.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`api`: Here, we will add Swagger annotations to the Java interface, `ProductCompositeService`,
    describing each RESTful service. At this stage, we only have one RESTful service, `/product-composite/{productId}`,
    which is used for requesting composite information regarding a specific product.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The actual texts that are used to describe the API operation will be placed
    in the default property file, `application.yml`.
  prefs: []
  type: TYPE_NORMAL
- en: Before we can start using SpringFox, we need to add it as a dependency in the
    Gradle build files. So, let's start with that!
  prefs: []
  type: TYPE_NORMAL
- en: Adding dependencies to the Gradle build files
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'As we mentioned previously, we will use a snapshot version of SpringFox V3\.
    The SpringFox product is divided into a number of modules. The modules that we
    need to specify dependencies are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '`springfox-swagger2`, so that we can create Swagger 2-based documentation'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`springfox-spring-webflux`, so that we can support the use of Spring WebFlux-based
    RESTful operations'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`springfox-swagger-ui`, so that we can embed a Swagger viewer in our microservice'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'We can add these to the Gradle build file, `build.gradle`, for the `product-composite-service` module
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'The `api` project only needs one dependency for the `springfox-swagger2` module,
    and so only the following dependency needs to be added to its `build.gradle` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'The SpringFox project publishes snapshot builds in the Maven repository ([http://oss.jfrog.org/artifactory/oss-snapshot-local/](http://oss.jfrog.org/artifactory/oss-snapshot-local/)),
    so we need to add that as well:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: To be able to build the core modules, that is, `product-service`, `recommendation-service`,
    and `review-service`, we need to add the Maven repository to their Gradle build
    files, `build.gradle`, as well.
  prefs: []
  type: TYPE_NORMAL
- en: Adding configuration and general API documentation to Product Composite Service
    Application
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: To enable SpringFox in the `product-composite-service` microservice, we have
    to add a configuration. To keep the source code compact, we will add it directly
    to the `ProductCompositeServiceApplication` application class.
  prefs: []
  type: TYPE_NORMAL
- en: If you prefer, you can place the configuration of SpringFox in a separate Spring
    configuration class.
  prefs: []
  type: TYPE_NORMAL
- en: First, we need to add the `@EnableSwagger2WebFlux` annotation in order to get
    SpringFox to generate Swagger V2 documentation for our RESTful services, which
    is implemented using Spring WebFlux. Next, we need to define a Spring Bean that
    returns a SpringFox `Docket` bean, which is used to configure SpringFox.
  prefs: []
  type: TYPE_NORMAL
- en: 'The source code that we will be adding to `$BOOK_HOME/Chapter05/microservices/product-composite-service/src/main/java/se/magnus/microservices/composite/product/ProductCompositeServiceApplication.java`
    looks as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'From the preceding code, we can understand the following:'
  prefs: []
  type: TYPE_NORMAL
- en: The `@EnableSwagger2WebFlux` annotation is the starting point for initiating
    SpringFox.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `Docket` bean is initiated to create Swagger V2 documentation.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using the `apis()` and `paths()` methods, we can specify where SpringFox shall
    look for API documentation.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using the `globalResponseMessage()` method, we ask SpringFox not to add any
    default HTTP response codes to the API documentation, such as `401` and `403`,
    which we don't currently use.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The `api*` variables that are used to configure the `Docket` bean with general
    information about the API are initialized from the property file using Spring
    `@Value` annotations. These are as follows:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: After adding a configuration and API documentation, we can now proceed to understand
    how to add an API specific documentation to ProductCompositeService.
  prefs: []
  type: TYPE_NORMAL
- en: Adding API-specific documentation to ProductCompositeService
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: To document the actual API, `ProductCompositeService`, and its RESTful operations,
    we will add an `@Api` annotation to the Java interface declaration so that we
    can provide a general description of the API. For each RESTful operation in the
    API, we will add an `@ApiOperation` annotation, along with `@ApiResponse` annotations
    on the corresponding Java method, to describe the operation and its expected error
    responses.
  prefs: []
  type: TYPE_NORMAL
- en: SpringFox will inspect the `@GetMapping` Spring annotation to understand what
    input argument the operation takes and what the response will look like if a successful response
    is produced.
  prefs: []
  type: TYPE_NORMAL
- en: In the following example, we have extracted the actual text from the `@ApiOperation` annotation to
    a property file. The annotation contains property placeholders that SpringFox
    will use to look up the actual text from the property files at runtime.
  prefs: []
  type: TYPE_NORMAL
- en: 'The documentation of the API on the resource level appears as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'The single API operation is documented as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: For the values specified in the `@ApiOperation` Swagger annotation, we can use
    property placeholders directly, without using Spring `@Value` annotations. For
    the description of the expected `ApiResponses`, that is, the expected error codes,
    SpringFox currently does not support the use of property placeholders, so in this
    case, the actual text describing each error code is placed directly in the Java
    source code.
  prefs: []
  type: TYPE_NORMAL
- en: For details, see `$BOOK_HOME/Chapter05/api/src/main/java/se/magnus/api/composite/product/ProductCompositeService.java`.
  prefs: []
  type: TYPE_NORMAL
- en: Adding textual descriptions of the API to the property file
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Finally, we need to add the textual descriptions of the API to the property
    file, `application.yml`. Here, we have `@Value` annotations, which look as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'For each `@Value` annotation, we need to specify a corresponding property in
    the YAML file; for example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'In the same way, we have Swagger annotations, which look as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'These expect a corresponding property in the YAML file; for example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'If you want to find out more about how a YAML file is constructed, view the
    specification: [https://yaml.org/spec/1.2/spec.html](https://yaml.org/spec/1.2/spec.html).'
  prefs: []
  type: TYPE_NORMAL
- en: 'First, the general description of the API, which is configured in the SpringFox
    `Docket` bean, is described as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, a detailed description of the actual API operation is given:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: Note that SpringFox supports providing a multiline description of an API operation
    using markdown syntax.
  prefs: []
  type: TYPE_NORMAL
- en: For more details, see `$BOOK_HOME/Chapter05/microservices/product-composite-service/src/main/resources/application.yml`.
  prefs: []
  type: TYPE_NORMAL
- en: Building and starting the microservice landscape
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Before we can try out the Swagger documentation, we need to build and start
    the microservice landscape!
  prefs: []
  type: TYPE_NORMAL
- en: 'This can be done with the following commands:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'You may run into an error message regarding port `8080` already being allocated.
    This will look as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'If this is the case, you might have forgotten to bring down the microservice
    landscape from the previous chapter. To find out the names of the executing containers,
    run the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'A sample response when a microservice landscape from the previous chapter is
    still running is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'If you find containers from other chapters in the output from the command,
    for example, from [Chapter 4](ce37c0f1-ac54-4258-8cb6-7c6f50f26172.xhtml), *Deploying
    Our Microservices Using Docker*, as in the preceding example, you need to jump
    over to that chapter and bring down the containers for that chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, you can bring up the missing container for this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'Note that only the missing container, `product-composite`, is started by the
    command since the other ones were already started successfully:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'To wait for the microservice landscape to startup and verify that it works,
    you can run the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: The successful start-up of this microservice helps us understand its landscape
    better and also aids in understanding the Swagger documentation which  we are
    about to study in the next section.
  prefs: []
  type: TYPE_NORMAL
- en: Trying out the Swagger documentation
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To browse the Swagger documentation, we will use the embedded Swagger viewer.
    If we open the `http://localhost:8080/swagger-ui.html` URL in a web browser, we
    will see a web page that looks something like the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/eb92fdb1-5db9-4a87-92d4-7c71147b6608.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Here, we can find the following:'
  prefs: []
  type: TYPE_NORMAL
- en: The general information we specified in the SpringFox `Docket` bean and a link
    to the actual Swagger document, `http://localhost:8080/v2/api-docs`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A list of API resources; in our case, the `product-composite-service` API
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: At the bottom of the page, there is a section where we can inspect the models
    that are used in the API
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'This is how it works:'
  prefs: []
  type: TYPE_NORMAL
- en: Click on the `product-composite-service` API resource to expand it. You will
    get a list of operations that are available on the resource.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'You will only see one operation, /product-composite/{productId}. Click on it
    to expand it. You will see the documentation of the operation that we specified
    in the `ProductCompositeService` Java interface:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/8cfce8b6-7453-449a-a9ef-2e09eaa283fa.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Here, we can see the following:'
  prefs: []
  type: TYPE_NORMAL
- en: The one-line description of the operation.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A section with details regarding the operation, including the input parameters
    it supports. Note how the markdown syntax from the `notes` field in the `@ApiOperation`
    annotation has been nicely rendered!
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'If you scroll down the web page, you will also find documentation regarding
    the expected responses, both a normal 200 response and the various 4xx error responses
    we defined, as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/552a2eb1-0907-4982-9bea-1c27987a129f.png)'
  prefs: []
  type: TYPE_IMG
- en: 'If we scroll back up to the parameter description, we will find the Try it
    out! button. If we click on that, we can fill in actual parameter values and send
    a request to the API by clicking on the Execute button. For example, if we put
    in productId `123`, we will get the following response:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/25e34f7c-852a-407f-a9ad-c7963c7808bb.png)'
  prefs: []
  type: TYPE_IMG
- en: We will get an expected 200 (OK) as the response code and a JSON structure in
    the response body that we already are familiar with!
  prefs: []
  type: TYPE_NORMAL
- en: 'If we enter an incorrect input, such as `-1`, we will get a proper error code
    as the response code and a corresponding JSON-based error description in the response
    body:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/3361c3ba-305c-4950-8454-afea6db7d2e4.png)'
  prefs: []
  type: TYPE_IMG
- en: 'If you want to try out calling the API without using the Swagger UI, you can
    copy the corresponding `curl` command from the response section and run it in
    a Terminal window! Look at the following by way of an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: Great, isn't it?
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Good documenting of an API is essential for its acceptance, and Swagger is one
    of the most commonly used specifications when it comes to documenting RESTful
    services. SpringFox is an opensource project that makes it possible to create
    Swagger-based API documentation on the fly at runtime by inspecting Spring WebFlux
    and Swagger annotations. Textual descriptions of an API can be extracted from
    the annotations in the Java source code and be placed in a property file for ease
    of editing. SpringFox can be configured to bring in an embedded Swagger viewer
    to a microservice, which makes it very easy to read about APIs that have been
    exposed by the microservice and also try them out from the viewer.
  prefs: []
  type: TYPE_NORMAL
- en: Now, what about bringing some life to our microservices by adding persistence,
    that is, the capability to save data in a database? To do this, we need to add
    some more APIs so that we can create and delete the information that's handled
    by the microservices. Head over to the next chapter to find out more!
  prefs: []
  type: TYPE_NORMAL
- en: Questions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: How does SpringFox help us create API documentation for RESTful services?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What specifications for documenting APIs does SpringFox support?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What is the purpose of the SpringFox `Docket` bean?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Name some annotations that SpringFox reads at runtime to create the API documentation
    on the fly!
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'What does `: |` mean in a YAML file?'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How can you repeat a call to an API that was performed using the embedded Swagger
    viewer without using the viewer again?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
