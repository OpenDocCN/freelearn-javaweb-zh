- en: Chapter 4. Message Transformers
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The takeaway from the last chapter was that the message endpoints make the
    handshake transparent and seamless between two heterogeneous components. In this
    chapter, we will get into the details of one of the important concerns in integration—transformation
    of messages so that they can be consumed across a chain. We will cover:'
  prefs: []
  type: TYPE_NORMAL
- en: Message transformers
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Working with XML payload
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Enrichers
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Claim check
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The same set of data can be viewed by different systems in different contexts,
    for example, an employee record is used by the reporting system as well as the
    finance system. However, the usage of the object will be different. Reporting
    systems just dump the employee record—so even if it gets it as a single string,
    it's okay. On the other hand, payroll systems might need to send mail notifications,
    calculate taxes based on state and country, and to carry out other functions for
    which employee data must be presented as a POJO, with information in a separate
    field, say, name, state, country, e-mail, and so on. Similarly, there could be
    cases where additional information must be augmented in the original message,
    it might be needed to encrypt/decrypt or to be converted to some proprietary format—these
    are the scenarios where message transformers make an entry!
  prefs: []
  type: TYPE_NORMAL
- en: Introducing message transformers
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Message transformers are implementations of the **Enterprise Integration Pattern**
    (**EIP)** named **Message Translator**, which deal with parity between data formats
    across endpoints. It's a neat design to decouple message producers and message
    consumers—none of them are required to know the format expected by the other.
    It is almost like the adapter pattern from the core java design principle, which
    acts as an enabler across producers and consumers. Let's take a more generic example,
    we regularly transfer files across Windows and Linux even though the format required
    on these two systems is different, the underlying application takes care of transforming
    from one format to another.
  prefs: []
  type: TYPE_NORMAL
- en: Spring Integration provides a lot of out-of-the-box transformers without taking
    away flexibility to define and extend new transformers. It has provided extensive
    support for the most commonly used message exchange formats such as XML, JSON,
    Collections, and others. Out of these, by and large, XML is the most used language
    when it comes to cross-language and cross-platform communication. Let's take it
    up and explore Spring Integration support for XML before exploring other aspects
    of message transformation.
  prefs: []
  type: TYPE_NORMAL
- en: Working with XML payload
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Two disparate systems might agree to interact via XML formats. This means that
    whenever there is an outgoing communication, the system's data structure needs
    to be converted to XML; while in the case of incoming messages, it needs to be
    converted to a data structure understood by the system. How do we do this? Spring
    provides first-class support to deal with XML via its **OXM** (**Object-to-XML**)
    framework. Marshalling and unmarshalling is done by classes—`org.springframework.oxm.Marshaller`
    and `org.springframework.oxm.Unmarshaller`, respectively. **Marshaller** converts
    an Object to an XML stream, while **unmarshaller** converts an XML stream to Object.
    Spring's Object/XML Mapping support provides several implementations supporting
    marshalling and unmarshalling using JAXB, Castor, and JiBX among others. Spring
    Integration abstracts it further and provides many out-of-the-box components,
    which help to deal with the XML payload. A few of them are *marshalling transformer*,
    *unmarshalling transformer*, and *XPath transformer*. There are many others such
    as Xslt transformer, XPath splitter, and XPath router but we will only cover the
    most used ones.
  prefs: []
  type: TYPE_NORMAL
- en: The marshalling transformer
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'A marshalling transformer is used to convert an object graph into an XML format.
    An optional result type can be provided, which can be a user-defined type, or
    one of the two Spring built-in types: `javax.xml.transform.dom.DOMResult` or `org.springframework.xml.transform.StringResult`.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is an example of a marshalling transformer:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'An explanation of different elements used here is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '`int-xml:marshalling-transformer`: This is the namespace support provided by
    Spring Integration'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`input-channel`: This is the channel from which messages will be read'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`output-channel`: This is the channel on which transformed messages will be
    dropped'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`marshaller`: This is the marshaller instance to be used for marshalling'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`result-type`: This is the type to which results should be marshalled'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'A valid reference of the marshaller is required, for example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'This example uses one of the Spring built-in types, `org.springframework.xml.transform.StringResult`
    as a result type. If `result-type` is not specified, then the default, `DOMResult`,
    is used. A custom result type can also be used here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'Here, `feedsXMLFactory` refers to a class, which implements `org.springframework.integration.xml.result.ResultFactor`
    and overrides the method `createResult`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: The unmarshalling transformer
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Almost all elements are the same as marshaller described earlier, except the
    `unmarshaller` element, which should point to a valid unmarshaller definition
    supported by Spring.
  prefs: []
  type: TYPE_NORMAL
- en: XPath transformers
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Spring integration''s `xpath-transformer` component can be used to parse an
    XML using XPath expressions:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: The XPath expression to be evaluated can be given using the tag `xpath-expression`.
    When an XML payload arrives on an input channel, the transformer parses the XPATH
    value and puts the result onto the output channel.
  prefs: []
  type: TYPE_NORMAL
- en: 'By default, the parsed value is converted to a message with a string payload
    but, if required, simple conversions can be done. The following implicit conversions
    are supported by Spring: `BOOLEAN`, `DOM_OBJECT_MODEL`, `NODE`, `NODESET`, `NUMBER`,
    and `STRING`. All of these are defined in `javax.xml.xpath.XPathConstants`, shown
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: The `evaluation-type` tag is used to introduce the desired conversion.
  prefs: []
  type: TYPE_NORMAL
- en: Validating XML messages
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'While we are discussing XML transformation, it''s relevant to bring up the
    validation aspect of the XML payload. Prevalidation of XML will save the system
    from going in an erroneous condition and can act at the source. Spring Integration
    provides support for XML validation via a filter:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: The `schema-location` element defines the XSD that should be used for validation.
    This is optional and if it has not done so, set it to default `xml-schema`, which
    internally translates to `org.springframework.xml.validation.XmlValidatorFactory#SCHEMA_W3C_XML`.
  prefs: []
  type: TYPE_NORMAL
- en: 'We discussed a lot of inbuilt transformers, primarily dealing with XML payloads.
    Apart from these, Spring Integration provides many out-of-the-box transformers
    for the most common conversions, such as:'
  prefs: []
  type: TYPE_NORMAL
- en: '`object-to-string-transformer`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`payload-serializing-transformer`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`payload-deserializing-transformer`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`object-to-map-transformer`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`map-to-object-transformer`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`json-to-object-transformer`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`object-to-json-transformer` and so on'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Detailing each one is out of the scope of this book, but the concepts are the
    same as mentioned earlier.
  prefs: []
  type: TYPE_NORMAL
- en: Beyond default transformers
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Spring does not restrict us to use the transformer provided by the framework,
    we can define our own transformer and it''s pretty straightforward. All we need
    to do is to define a Java class, which takes a particular input type, coverts
    it to an expected format and puts it onto the output channel. Let''s take an example
    where we want to convert our feed in a format that can be written to DB; we can
    define a class, which takes a *Message* payload of type `com.sun.syndication.feed.synd.SyndEntry`
    and converts it to `com.cpandey.siexample.pojo.SoFeed`, which is a JPA entity:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'A transformer can be declared using the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s define the bean referred to by the `ref` tag:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: As explained earlier, this class has the required method for transformation.
    This bean can be used across transformers and each method can have separate transformation
    logic.
  prefs: []
  type: TYPE_NORMAL
- en: Content enrichers
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: While enabling interaction between heterogeneous systems, it might be necessary
    to augment the message with additional information so that it can be successfully
    processed by the next set of consumers. Let's take an example where in a batch
    processing environment, it might be necessary to attach priority information onto
    the incoming tasks. It is for a message that is put on a file server for external
    consumption—a timestamp indicating the max time for which the file would be kept
    should be added. There could be several such scenarios where the incoming message
    is incomplete and is to be processed by the next endpoint. Content enricher is
    a specialized form of transformer, which can attach additional information to
    the message. In the context of Spring Integration, the message consists of two
    parts—header and message payload. Spring Integration exposes a way to enrich either
    of these components.
  prefs: []
  type: TYPE_NORMAL
- en: Header enrichers
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '**Header** in Spring Integration is an instance of the `MessageHeaders` class,
    which in turn extends `Map<String,?>`. Headers are nothing but key-value pairs
    and their purpose is to provide metadata about the message. Adding an additional
    header is straightforward. Let''s take an example, whenever feed arrives in our
    system and passes the XML validation, we will add a constant indicating that the
    feed is validated:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'What if we want to add some dynamic value, let''s say a timestamp, in a specific
    format? We can leverage bean support for the header enricher and define custom
    enrichment in the bean:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'Where the bean referred to by the `ref` tag is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'The definition of the actual class is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'Apart from a standard Java Bean, we can also use a Groovy script to define
    the custom enricher:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'There are predefined header elements that can also be used; the simplest and
    most commonly used is the error-channel:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: Payload enrichers
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '**Header enrichers** are handy to add metadata information. What if the message
    itself is incomplete? Let''s take an example, when a feed arrives, based on the
    feed category, it might be required to fetch metadata for that category, subscribed
    users for that category, and so on. Other components such as service activators
    and gateways can be used, but for ease of use Spring Integration has exposed payload
    enrichers. **Payload enrichers** are like gateways—they put messages onto a channel
    and then expect a reply for that message. The returned message will be payload
    enriched. For example, let''s say external feeds have a lot of categories for
    Spring such as Spring-mvc, Spring-boot, Spring-roo, and Spring-data, but our system
    has a single category for all of these—Spring. Based on external categories, we
    can enrich the payload to use a single category:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'Here, the configuration elements mean the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '`int:enricher`: This is used as Spring Integration namespace support for the
    enricher.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`input-channel`: This is the channel from which data will be read for enrichment.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`request-channel`: This is the channel to which data will be sent for enriching
    it.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`int:property`: This is a convenient way to set the values on the target payload.
    The property mentioned must be "settable" on the target instance. It can be an
    **SpEL** (**Spring Expression Language**) expression, which is indicated by `expression`
    or it can be a value indicated by a value.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Claim check
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We discussed the usage of header and content enrichers—they add additional
    information. However, in some circumstances, it might be a valid use case to hide
    the data—the simplest one can be a heavy payload. It''s not a good idea to move
    the whole message around while most of the channels might be using just a subset
    or even just a pass-through! Enter a *claim check pattern*, which suggests storing
    data in accessible storage and then passing only the pointers around. Components
    that need the data to process can retrieve it using the pointer. Spring integration
    provides two components to accomplish this: *Incoming claim check transformer*
    and *Outgoing claim check transformer*. The incoming claim check transformer can
    be used to store the data while the outgoing one can be used to retrieve it.'
  prefs: []
  type: TYPE_NORMAL
- en: Incoming claim check transformer
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Incoming **claim check transformer** stores a message in the **message store**
    identified by its message-store tag, and transforms the payload to a pointer to
    the actual message, as can be seen in the following code snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: Once the message is stored in the message store, it is indexed with a generated
    ID, which becomes a claim check for that message. The transformed message is the
    claim check, which is the new payload, and will be sent to the output channel.
    To retrieve this message, an outgoing claim check transformer is required.
  prefs: []
  type: TYPE_NORMAL
- en: Outgoing claim check transformer
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Based on the claim check, this transformer converts the pointer back to the
    original payload and puts it back onto the output channel. What if we want to
    restrict the claim to once only? We can introduce a Boolean value for `remove-message`,
    setting its value to true will delete the message from the message store as soon
    as it has been claimed. The default value is false. The updated code is shown
    in the following code snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We covered the ways in which a message can be enriched and transformed so that
    heterogeneous systems are decoupled from data formats of each other. We also covered
    the claim check concept, which is a special case of transformation and can be
    used for performance, security, and other nonfunctional aspects.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will move on to explore more out-of-the-box components
    provided by Spring Integration, which help with message flow.
  prefs: []
  type: TYPE_NORMAL
