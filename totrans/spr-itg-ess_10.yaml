- en: Chapter 10. An End-to-End Example
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We have covered enough to get up to speed using Spring Integration in real projects.
    Let's build a real application, which will exercise different types of components
    exposed by the Spring Integration module. This will also act as a refresher chapter
    as we will visit all the concepts discussed so far.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s take an example of the feeds aggregator application; it will aggregate
    feeds based on the configured parameters and then relay it to interested parties.
    Here is the outline of problems we will try to solve. These are just for the sake
    of an example, in a real scenario, we might not need the aggregator or splitter,
    or the sequence of processing itself can be different:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Ingesting data can be done by:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Reading RSS feeds
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Reading questions from files on an FTP server
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Filtering data:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Filtering the valid/invalid messages based on completion criteria; for simplicity,
    we will filter out `java` questions
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Aggregating messages: Just to showcase the example, we will aggregate and release
    messages in a group of five'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Splitting a message: The list of aggregated messages will be split and sent
    down the line for further processing'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Transformation:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Converting a message to a format that can be written in DB
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Converting a message in a JMS format that can be put on a messaging queue
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Converting a message in an e-mail format so that it can be sent to a subscribed
    recipient
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Routing a message based on the message type; entity type to database consumer,
    message type to JMS consumer, and e-mail message to e-mail sender
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Integrating with external systems:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Writing to DB
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Putting on JMS
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Using an e-mail adapter to send across mails
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'JMX: Exposing Spring endpoints for management and monitoring'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Prerequisites
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Before we can get started with an example, we will need the following software
    in order to import and run the project:'
  prefs: []
  type: TYPE_NORMAL
- en: A Java IDE (preferably STS, but any other IDE such as Eclipse or NetBeans will
    also do)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: JDK 1.6 and above
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Maven
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: FTP server (this is optional and will only be needed if enabled)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Setting up
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Once we have all the prerequisites, follow these steps to launch the program:'
  prefs: []
  type: TYPE_NORMAL
- en: Check out the project that you've downloaded with the code bundle. It is a Maven
    project, so using the IDE of your choice, import it as a Maven project.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Add settings for the e-mail, JMS, and FTP accounts in `settings.properties`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Keep an FTP and an e-mail account ready.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Run from the main class, that is, `FeedsExample`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Ingesting data
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s start with the first step, ingestion of data. We have configured two
    data sources: RSS feeds and an FTP server, let''s take a look at these.'
  prefs: []
  type: TYPE_NORMAL
- en: Ingesting data from the RSS feed
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: I will show the code and explain what it does, but will not cover each and every
    tag in detail as they have already been covered in the respective chapters.
  prefs: []
  type: TYPE_NORMAL
- en: Ingesting data from an FTP server
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Now, for this to work, you need an FTP server configured. For testing, you
    can always set up an FTP server locally. Depending on your FTP server location
    and configuration parameters, set up a session factory:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'After we have set up the session factory, it can be used to establish a connection
    with the FTP server. The following code will download the new file from the configured
    `remote-directory` of the FTP and put it in the `local-directory`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: Filtering the data
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The feed and FTP adapter fetch the feed and put it on to `fetchedFeedChannel`.
    Let''s configure a filter, which will allow only Java-related questions, while
    reading the feeds. It will read feeds from the channel `fetchedFeedChannel` and
    pass on the filtered feeds to the channel `fetchedFeedChannelForAggregatior`.
    The following code snippet is the Spring configuration:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'Here is the JavaBean class encapsulating the logic of the filter:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: The aggregator
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The aggregator is for showcasing the aggregator usage. An aggregator is plugged
    on the output channel of the filter, that is, `fetchedFeedChannelForAggregatior`.
    We will use all the three components of aggregator: correlation, completion, and
    aggregator. Let''s declare the beans:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'Once we have defined the three vital components of an aggregator, let''s define
    the component, which will aggregate feeds in a group of five and then release
    only on the next channel:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: The correlation bean
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'If you remember, the correlation bean holds the strategy to group "related"
    items. We will simply use the category of feeds to group messages:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: The completion bean
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We have correlated the messages, but for how long will we hold on to the list?
    This will will be decided by the completion criteria. Let''s put a very simple
    criteria that if there are five feeds from the same category, then release it
    for further processing. Here is the class implementing this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: The aggregator bean
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Feeds will be correlated and, after the completion criteria is satisfied, the
    aggregator will return the list on the next endpoint. We have already defined
    the correlation strategy and completion criteria earlier, let''s see the code
    for the aggregator:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: The splitter
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'The JavaBean with the splitter logic:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: Transformation
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Now that we have feeds in the RSS format, let''s transform it to appropriate
    formats so that the endpoints responsible for persisting in the database, putting
    it on the JMS channel, and sending it as a mail, can understand that. The splitter
    will put one message at a time on the channel `splittedFeedChannel`. Let''s declare
    this as a pub-sub channel and attach three endpoints, which will be our transformers.
    Configure the pub-sub channel as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'The configuration for the three transformers that we have used is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: The DB transformer
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Let''s write the transformer component from the Spring Integration and Java
    class that have the transformation logic:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: The JMS transformer
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Here is the code for the JMS transformer component declaration and the corresponding
    JavaBean:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: The mail transformer
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Finally, let''s write the configuration and code for the mail transformer:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: Router
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'After transforming the messages to appropriate formats, the transformers put
    the message on to the channel `transformedChannel`. We have three type of messages
    that will be processed by different endpoints. We can use the payload router that
    will route it to different components based on the payload type:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: Integration
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now is the time for actual integration! Once the router has routed the message
    to the appropriate endpoints, it should be processed by them. For example, it
    can be persisted to a database, sent on a JMS channel, or sent as an e-mail. Depending
    on the payload type, the router will put the message on to one of the channels
    `jdbcChannel`, `jmsChannel`, or `mailChannel`. If it cannot understand the payload,
    it will route it to `logChannel`. Let's start with the endpoint attached to the
    channel `jdbcChannel` that is used for database integration.
  prefs: []
  type: TYPE_NORMAL
- en: Database integration
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this section, we will write code to add and query data from a database. Before
    we write adapters from Spring Integration, let's do the basic setup.
  prefs: []
  type: TYPE_NORMAL
- en: Prerequisites
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'As obvious as it can be, we need a database where we can dump the data. For
    simplicity, we will use the in-memory database. Let''s also configure the ORM
    provider, transaction, and other aspects to be used with the database:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Declaration of the embedded database:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Declaration of the transaction manager:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Declaration of the entity manager factory:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Declaration of the entity manager:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Declaration of the abstract vendor adapter:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Declaration of the actual vendor adapter, in our case, it is hibernate:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The gateway
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Let''s define a gateway, which will insert invoke methods to insert feeds and
    then read them back from the database:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'The bean definition for the gateway is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: The service activator
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'This service activator is plugged in to the `jdbcChannel` channel. When a message
    arrives, its `persistFeedToDb` method is invoked, which uses the preceding gateway
    to persist the feeds:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: Gateways for updating and reading the feeds
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Finally, we plug in the Spring Integration updating and retrieving outbound
    gateways to persist and read back the feed:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: Sending a mail
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We can use the Spring Integration mail outbound channel adapter to send out
    mails. It needs a reference to the mail sender class, which has been configured
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Spring Integration component for sending mail:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: As evident in the preceding configuration, this adapter is plugged in to `mailChannel`—one
    of the other channels where the router routes the message.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'The mail sender used by the preceding component:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Putting messages on to the JMS queue
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Finally, let''s use the outbound channel adapter to put the message on to a
    JMS queue, this polls the channel `jmsChannel` for a message and whenever router
    routes a message here, it puts it on to the `destination` queue:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'To test the message on the queue, let''s plug in a simple service activator:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'As evident in the preceding configuration, we need `destination` and `connection-factory`,
    let''s configure these:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: Exporting as an MBean
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Finally, let''s add code to export the components used as MBeans, which can
    be monitored through JConsole or other JMX tools:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We covered an end-to-end example in this chapter; I hope this was useful and
    served the purpose of refreshing the concept and a complete use case in one place.
    With this, our Spring Integration journey has ended. I hope you enjoyed it!
  prefs: []
  type: TYPE_NORMAL
- en: We covered most common features of the Spring Integration framework and introduced
    enough material to gain momentum. If this book excites you about using Spring
    Integration, the official reference available at [http://docs.spring.io/spring-integration/reference/htmlsingle](http://docs.spring.io/spring-integration/reference/htmlsingle)
    should be your next stop.
  prefs: []
  type: TYPE_NORMAL
