- en: Introduction to Microservices
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Microservices are one of the hottest trends to emerge in the IT world during
    the last few years. It is relatively easy to identify the most important reasons
    for their growing popularity. Both their advantages and disadvantages are well
    known, although what we describe as disadvantages can be easily solved using the
    right tools. The advantages that they offer include scalability, flexibility,
    and independent delivery; these are the reasons for its rapidly growing popularity. There
    are a few earlier IT trends that had some influence over this growth in the popularity
    of microservices. I'm referring to trends such as the usage of common cloud-based
    environments and the migration from relational databases to NoSQL.
  prefs: []
  type: TYPE_NORMAL
- en: 'Before discussing this at length, let''s see the topics we will cover in this
    chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: Cloud-native development with Spring Cloud
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The most important elements in microservices-based architecture
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Models of interservice communication
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Introduction to circuit breakers and fallback patterns
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The blessings of microservices
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The concept of microservices defines an approach to the architecture of IT systems
    that divides an application into a collection of loosely coupled services that
    implement business requirements. In fact, this is a variant of the concept of **service-oriented
    architecture** (**SOA**). One of the most important benefits of a migration to
    microservices-based architecture is an ability to perform continuous delivery
    of large and complex applications.
  prefs: []
  type: TYPE_NORMAL
- en: By now, you have probably had an opportunity to read some books or articles
    about microservices. I think that most of them would have given you a detailed
    description of their advantages and drawbacks. There are many advantages to using
    microservices. The first is that microservices are relatively small and easy to
    understand for a new developer in a project. We usually want to make sure that
    the change in the code performed in one place would not have an unwanted effect
    on all the other modules of our application. With microservices, we can have more
    certainty about this because we implement only a single business area, unlike
    monolithic applications where sometimes even seemingly unrelated functionalities
    are put in the same boat. That is not all. I have noticed that, usually, it is
    easier to maintain expected code quality in small microservices than in a large
    monolith where many developers have introduced their changes.
  prefs: []
  type: TYPE_NORMAL
- en: The second thing I like about microservices architecture concerns division.
    Until now, when I had to deal with complex enterprise systems, I always saw that
    dividing the system into subsystems was done according to other subsystems. For
    example, telecommunication organizations always have a billing subsystem. Then
    you create a subsystem that hides the billing complexity and provides an API.
    Then you find out that you need data that can't be stored in the billing system
    because it is not easily customizable. So you create another subsystem. This leads
    in effect to you building a complicated subsystem mesh, which is not easy to understand,
    especially if you are a new employee in the organization. With microservices,
    you do not have problems such as this. If they are well-designed, every microservice
    should be responsible for an entire selected area. In some cases, those areas
    are similar regardless of the sector in which an organization is active.
  prefs: []
  type: TYPE_NORMAL
- en: Building microservices with Spring Framework
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Although the concept of microservices has been an important topic for some years,
    there are still not many stable frameworks that support all the features needed
    to run full microservices environments. Since the beginning of my adventure with
    microservices, I have been trying to keep up with the latest frameworks and find
    out the features developed towards the needs of microservices. There are some
    other interesting solutions, such as Vert.x or Apache Camel, but none of them
    is a match for Spring Framework.
  prefs: []
  type: TYPE_NORMAL
- en: Spring Cloud implements all proven patterns that are used in microservice-based
    architecture, such as service registries, the configuration server, circuit breakers,
    cloud buses, OAuth2 patterns, and API gateways. It has a strong community, therefore
    new features are released at a high frequency. It is based on Spring's open programming
    model used by millions of Java developers worldwide. It is also well-documented.
    You won't have any problems in finding many available examples of Spring Framework
    usage online.
  prefs: []
  type: TYPE_NORMAL
- en: Cloud-native development
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Microservices are intrinsically linked to cloud-computing platforms, but the
    actual concept of microservices is nothing new. This approach has been applied
    in the IT development world for many years, but now, through the popularity of
    cloud solutions, it has evolved to a higher level. It is not hard to point out
    the reasons for this popularity. The use of a cloud offers you scalability, reliability,
    and low maintenance costs in comparison with on-premises solutions inside the
    organization. This has led to the rise of cloud-native application development
    approaches that are intended to give you the benefits from all of the advantages
    offered by cloud-like elastic scaling, immutable deployments, and disposable instances.
    It all comes down to one thing—decreasing the time and cost that is needed to
    meet new requirements. Today, software systems and applications are being improved
    continuously. If you have a traditional approach to development, based on monoliths,
    a code base grows and becomes too complex for modifications and maintenance. Introducing
    new features, frameworks, and technologies becomes hard, which in turn impacts
    innovations and inhibits new ideas. We can't argue with that.
  prefs: []
  type: TYPE_NORMAL
- en: There is also another side to this coin. Today, practically everyone thinks
    about migration to the cloud, partly because it's trendy. Does everyone need this?
    Certainly not. Those who are not absolutely sure about migrating their applications
    to a remote cloud provider, such as AWS, Azure, or Google, would like to at least
    have an on-premises private cloud or Docker containers. But will it really bring
    them the benefits that compensate for expenses incurred? It is worth answering
    that question before looking at cloud-native development and cloud platforms.
  prefs: []
  type: TYPE_NORMAL
- en: 'I''m not trying to dissuade you from using Spring Cloud—quite the opposite.
    We have to thoroughly understand what cloud-native development is. Here is a really
    fine definition:'
  prefs: []
  type: TYPE_NORMAL
- en: '"A native cloud application is a program that is specifically designed for
    a cloud computing environment as opposed to simply being migrated to the cloud."'
  prefs: []
  type: TYPE_NORMAL
- en: Spring is designed to accelerate your cloud-native development. Building an
    application with Spring Boot is very quick; I'll show you how to do this in detail
    in the next chapter. Spring Cloud implements microservice architecture patterns
    and helps us in using the most popular solutions from that field. Applications
    developed using these frameworks can easily be adapted to be deployed on Pivotal
    Cloud Foundry or Docker containers, but they might as well be launched in the
    traditional way as separated processes on one or more machines, and you would
    have the advantage of a microservices approach. Let's now dive into the microservices
    architecture.
  prefs: []
  type: TYPE_NORMAL
- en: Learning the microservices architecture
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s imagine that a client approaches you, wanting you to design a solution
    for them. They need some kind of banking application that has to guarantee data
    consistency within the whole system. Our client had been using an Oracle database
    until now and has also purchased support from their side. Without thinking too
    much, we decide to design a monolithic application based on a relational data
    model. You can see a simplified diagram of the system''s design here:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/a7bfd463-0994-4cfc-9d65-fe5e5dedb604.png)'
  prefs: []
  type: TYPE_IMG
- en: 'There are four entities that are mapped into the tables in the database:'
  prefs: []
  type: TYPE_NORMAL
- en: The first of them, **Customer**, stores and retrieves the list of active clients
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Every customer could have one or more accounts, which are operated by the **Account**
    entity
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The **Transfer** entity is responsible for performing all transfers of funds
    between accounts within the system
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: There is also the **Product** entity that is created to store information such
    as the deposits and credits assigned to the clients
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Without going into further details, the application exposes the API that provides
    all the necessary operations for realizing actions on the designed database. Of
    course, the implementation is in compliance with the three-layer model.
  prefs: []
  type: TYPE_NORMAL
- en: Consistency is not the most important requirement anymore; it is not even obligatory.
    The client expects a solution, but does not want the development to require the
    redeployment of the whole application. It should be scalable and should easily
    be able to extend new modules and functionalities. Additionally, the client does
    not put pressure on the developer to use Oracle or another relational database—not
    only that, but he would be happy to avoid using it. Are these sufficient reasons
    to decide on migrating to microservices? Let's just assume that they are. We divide
    our monolithic application into four independent microservices, each one of them
    with a dedicated database. In some cases, it can still be a relational database,
    while in others it can be a NoSQL database. Now, our system consists of many services
    that are independently built and run in our environment. Along with an increase
    in the number of microservices, there is a rising level of system complexity.
    We would like to hide that complexity from the external API client, which should
    not be aware that it talks to service *X* but not *Y*. The gateway is responsible
    for dynamically routing all requests to different endpoints. For example, the
    word *dynamically* means that it should be based on entries in the service discovery,
    which I'll talk about later in the section *Understanding the need for service
    discovery*.
  prefs: []
  type: TYPE_NORMAL
- en: 'Hiding invocations of specific services or dynamic routing is not the only
    function of an API gateway. Since it is the entry point to our system, it can
    be a great place to track important data, collect metrics of requests, and count
    other statistics. It can enrich requests or response headers in order to include
    some additional information that is usable by the applications inside the system.
    It should perform some security actions, such as authentication and authorization,
    and should be able to detect the requirements for each resource and reject requests
    that do not satisfy them. Here''s a diagram that illustrates the sample system,
    consisting of four independent microservices, which is hidden from an external
    client behind an API gateway:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/fd59b589-e29e-45b3-9496-2a8380086a2d.png)'
  prefs: []
  type: TYPE_IMG
- en: Understanding the need for service discovery
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s imagine that we have already divided our monolithic application into
    smaller, independent services. From the outside, our system still looks the same
    as before, because its complexity is hidden behind the API gateway. Actually,
    there are not many microservices, but, there may well be many more. Additionally,
    each of them can interact with the others. That means that every microservice
    has to keep information about the others'' network addresses. Maintaining such
    a configuration could be very troublesome, especially when it comes down to manually
    overwriting every configuration. And what if those addresses are changing dynamically
    after restart? The following diagram shows the calling routes between our example
    microservices:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/678ec5f0-b143-418f-a2a5-fc16296b7f3d.png)'
  prefs: []
  type: TYPE_IMG
- en: Service discovery is the automatic detection of devices and services offered
    by these devices on a computer network. In the case of microservice-based architecture,
    this is the necessary mechanism. Every service after startup should register itself
    in one central place that is accessible by all other services. The registration
    key should be the name of a service or an identificator, which has to be unique
    within the whole system in order to enable others to find and call the service
    using that name. Every single key with the given name has some values assigned
    to it. In the most common cases, these attributes indicate the network location
    of the service. To be more accurate, they indicate one of the instances of the
    microservice because it can be multiplied as independent applications running
    on different machines or ports. Sometimes it is possible to send some additional
    information, but it depends on the concrete service discovery provider. However,
    the important thing here is that under the one key, more than one instance of
    the same service may be registered. In addition to registration, each service
    gets a full list of the other services registered on the particular discovery
    server. Not only that, every microservice must be aware of any changes in the
    registration list. This may be achieved by periodically renewing the configuration
    earlier collected from the remote server.
  prefs: []
  type: TYPE_NORMAL
- en: 'Some solutions combine the usage of service discovery with the server configuration
    feature. When it comes right down to it, both approaches are pretty similar. The
    configuration of the server lets you centralize the management of all configuration
    files in your system. Usually, such a configuration is then a server as a REST
    web service. Before startup, every microservice tries to connect to the server
    and get the parameters prepared especially for it. One of the approaches stores
    such a configuration in the version control system—for example, Git. Then the
    configuration server updates its Git working copy and serves all properties as
    a JSON. In another approach, we can use solutions that store key-value pairs and
    fulfill the role of providers during the service discovery procedure. The most
    popular tools for this are Consul and Zookeeper. The following diagram illustrates
    an architecture of a system that consists of some microservices with a database
    backend that are registered in one central service known as a **discovery service**:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/f85f1ca3-e8b1-47ac-8097-785cc2599a49.png)'
  prefs: []
  type: TYPE_IMG
- en: Communication between services
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In order to guarantee the system's reliability, we cannot allow a situation
    where each service would have only one instance running. We usually aim to have
    a minimum of two running instances in case one of them experiences a failure.
    Of course, there could be more, but we'll keep it low for performance reasons.
    Anyway, multiple instances of the same service make it necessary to use load balancing
    for incoming requests. Firstly, the **load balancer** is usually built into an
    API gateway. This load balancer should get the list of registered instances from
    the discovery server. If there is no reason not to, then we usually use a round-robin
    rule that balances incoming traffic 50/50 between all running instances. The same
    rule also applies to load balancers on the microservices side.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following diagram illustrates the most important components that are involved
    in interservice communication between multiple instances of two sample microservices:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/8c6c8970-d0da-44c2-b4c9-ce53c6919bfb.png)'
  prefs: []
  type: TYPE_IMG
- en: Most people, when they hear about microservices, consider it to consist of RESTful
    web services with JSON notation, but that's just one of the possibilities. We
    can use some other interaction styles, which, of course, apply not only to microservices-based
    architecture. The first categorization that should be performed is one-to-one
    or one-to-many communication. In one-to-one interaction, every incoming request
    is processed by exactly one service instance while, in one-to-many, it is processed
    by multiple service instances. But the most popular division criterion is whether
    the call is synchronous or asynchronous. Additionally, asynchronous communication
    can be divided into notifications. When a client sends a request to a service,
    but a reply is not expected, it can just perform a simple asynchronous call, which
    does not block a thread and replies asynchronously.
  prefs: []
  type: TYPE_NORMAL
- en: Furthermore, it is worth mentioning reactive microservices. Now, from version
    5, Spring also supports this type of programming. There are also libraries with
    Reactive support for interaction with NoSQL databases, such as MongoDB or Cassandra.
    The last well-known communication type is publish-subscribe. This is a one-to-many
    interaction type where a client publishes a message that is then consumed by all
    listening services. Typically, this model is realized using message brokers, such
    as Apache Kafka, RabbitMQ, and ActiveMQ.
  prefs: []
  type: TYPE_NORMAL
- en: Failures and circuit breakers
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We have discussed most of the important concepts related to the microservices
    architecture. Such mechanisms, such as service discovery, API gateways, and configuration
    servers, are useful elements that help us to create a reliable and efficient system.
    Even if you have considered many aspects of these while designing your system's
    architecture, you should always be prepared for failures. In many cases, the reasons
    for failures are totally beyond the control of the holder, such as network or
    database problems. Such errors can be particularly severe for microservice-based
    systems, where one input request is processed in many subsequent calls. The first
    good practice is to always use network timeouts when waiting for a response. If
    a single service has a performance problem, we should try to minimize the impact
    on the rest. It is better to send an error response than to wait on a reply for
    a long time, blocking other threads.
  prefs: []
  type: TYPE_NORMAL
- en: An interesting solution for the network timeout problems might be the **circuit
    breaker pattern**. It is a concept closely related to the microservice approach.
    A circuit breaker is responsible for counting successful and failed requests. If
    the error rate exceeds an assumed threshold, it trips and causes all further attempts
    to fail immediately. After a specific period of time, the API client should get
    back to sending requests, and if they succeed, it closes the circuit breaker.
    If there are many instances of each service available and one of them works slower
    than others, the result is that it is overlooked during the load balancing process.
    The second often-used mechanism for dealing with partial network failures is **fallback**.
    This is a logic that has to be performed when a request fails. For example, a
    service can return cached data, a default value, or an empty list of results.
    Personally, I'm not a big fan of this solution. I would prefer to propagate error
    code to other systems than return cached data or default values.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The big advantage of Spring Cloud is that it supports all the patterns and mechanisms
    we have looked at. These are also stable implementations, unlike some other frameworks.
    I'll describe in detail which of the patterns are supported by which Spring Cloud
    project in [Chapter 3](5e461bca-a37d-4f72-b58f-5f14694d055f.xhtml), *Spring Cloud
    Overview*.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we have discussed the most important concepts related to microservices
    architecture, such as cloud-native development, service discovery, distributed
    configuration, API gateways, and the circuit breaker pattern. I have attempted
    to present my point of view about the advantages and drawbacks of this approach
    in the development of enterprise applications. Then, I described the main patterns
    and solutions related to microservices. Some of these are well-known patterns
    that have been around for years and are treated as something new in the IT world.
    In this summary, I would like to turn your attention to some things. Microservices
    are cloud-native by their nature. Frameworks such as Spring Boot and Spring Cloud
    help you to accelerate your cloud-native development. The main motivation of migrating
    to cloud-native development is the ability to implement and deliver applications
    faster while maintaining high quality. In many cases, microservices help us to
    achieve this, but sometimes the monolithic approach is not a bad choice.
  prefs: []
  type: TYPE_NORMAL
- en: Although microservices are small and independent units, they are managed centrally.
    Information such as network location, configuration, logging files, and metrics
    should be stored in one central place. There are various types of tools and solutions
    that provide all these features. We will talk about them in detail in almost all
    of the chapters in this book. The Spring Cloud project is designed to help us
    in integrating with all that stuff. I hope to efficiently guide you through the
    most important integrations it offers.
  prefs: []
  type: TYPE_NORMAL
