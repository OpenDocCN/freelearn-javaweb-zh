- en: Improving Resilience Using Resilience4j
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this chapter, we will learn how to use Resilience4j to make our microservices
    more resilient, that is, how to mitigate and recover from errors. As we already
    discussed in [Chapter 1](282e7b49-42b8-4649-af81-b4b6830d391d.xhtml), *Introduction
    to Microservices*, in the *Circuit breaker* section, and [Chapter 8](9878a36a-5760-41a4-a132-1a2387b61037.xhtml),
    *Introduction to Spring Cloud,* the *Resilience4j for improved resilience* section,
    a circuit breaker can be used to minimize the damage that a slow or not-responding
    downstream microservice can cause in a large-scale system landscape of synchronously
    communicating microservices. We will see how the circuit breaker in Resilience4j
    can be used together with a timeout and retry mechanism to prevent two—in my experience—of
    the most common error situations:'
  prefs: []
  type: TYPE_NORMAL
- en: Microservices that start to respond slowly or not at all
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Requests that randomly fail from time to time, for example, due to temporary
    network problems
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The following topics will be covered in this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: Introducing the Resilience4j circuit breaker and retry mechanism
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Adding a circuit breaker and retry mechanism to the source code
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Trying out the circuit breaker and retry mechanism
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: All the commands that are described in this book are run on a MacBook Pro using
    macOS Mojave but should be straightforward to modify if you want to run them on
    another platform such as Linux or Windows.
  prefs: []
  type: TYPE_NORMAL
- en: No new tools need to be installed in this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: The source code for this chapter can be found in this book's GitHub repository: [https://github.com/PacktPublishing/Hands-On-Microservices-with-Spring-Boot-and-Spring-Cloud/tree/master/Chapter13](https://github.com/PacktPublishing/Hands-On-Microservices-with-Spring-Boot-and-Spring-Cloud/tree/master/Chapter13).
  prefs: []
  type: TYPE_NORMAL
- en: 'To be able to run the commands that are described in this book, download the
    source code to a folder and set up an environment variable, `$BOOK_HOME`, that
    points to that folder. Some sample commands are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: The Java source code is written for Java 8 and tested on Java 12\. This chapter
    uses Spring Cloud 2.1.0, SR1 (also known as the **Greenwich** release), Spring
    Boot 2.1.4, and Spring 5.1.6, that is, the latest available version of the Spring
    components at the time of writing this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: The `openjdk:12.0.2` base Docker image is used in all the Dockerfiles.
  prefs: []
  type: TYPE_NORMAL
- en: 'The source code contains the following Gradle projects:'
  prefs: []
  type: TYPE_NORMAL
- en: '`api`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`util`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`microservices/product-service`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`microservices/review-service`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`microservices/recommendation-service`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`microservices/product-composite-service`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`spring-cloud/eureka-server`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`spring-cloud/gateway`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`spring-cloud/authorization-server`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`spring-cloud/config-server`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The configuration files can be found in the config repository, `config-repo`.
  prefs: []
  type: TYPE_NORMAL
- en: All the source code examples in this chapter come from the source code in `$BOOK_HOME/Chapter13` but
    in several cases have been edited to remove irrelevant parts of the source code,
    such as comments, imports, and log statements.
  prefs: []
  type: TYPE_NORMAL
- en: If you want to see the changes that were applied to the source code in this
    chapter, that is, see what it took to add resilience using Resilience4j, you can
    compare it with the source code for [Chapter 12](a250774a-03a1-41b1-b935-cbeb9624b6e3.xhtml),
    *Centralized Configuration*. You can use your favorite `diff` tool and compare
    the two folders, `$BOOK_HOME/Chapter12` and `$BOOK_HOME/Chapter13`.
  prefs: []
  type: TYPE_NORMAL
- en: Introducing the Resilience4j circuit breaker and retry mechanism
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Retries and circuit breakers are potentially useful in any synchronous communication
    between two software components, for example, microservices. Resilience4j can
    be used by all our microservices except for the edge server since Spring Cloud
    Gateway currently only supports the older circuit breaker, Netflix Hystrix. In
    this chapter, we will apply a circuit breaker and a retry mechanism in one place, in
    calls to the `product` service from the `product-composite` service. This is illustrated
    in the following diagram:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/1242dd3a-010d-4a6d-8ce2-edc8fd88c290.png)'
  prefs: []
  type: TYPE_IMG
- en: Note that the synchronous calls to the discovery and config servers from the
    other microservices are not shown in the preceding diagram (to make it easier
    to read).
  prefs: []
  type: TYPE_NORMAL
- en: Work is ongoing as this chapter was written to add an abstraction layer for
    circuit breakers in Spring Cloud, something Spring Cloud Gateway will probably
    be able to benefit from. For details, see [https://spring.io/blog/2019/04/16/introducing-spring-cloud-circuit-breaker](https://spring.io/blog/2019/04/16/introducing-spring-cloud-circuit-breaker).
  prefs: []
  type: TYPE_NORMAL
- en: Introducing the circuit breaker
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s quickly revisit the state diagram for a circuit breaker from [Chapter
    8](9878a36a-5760-41a4-a132-1a2387b61037.xhtml), *Introduction to Spring Cloud*,
    in the *Resilience4j for improved resilience* section:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/87b2c812-ab46-45fe-a6d7-0f06a030d556.png)'
  prefs: []
  type: TYPE_IMG
- en: 'The key features of a circuit breaker are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: If a circuit breaker detects too many faults, it will open its circuit, that
    is, not allow new calls.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: When the circuit is open, a circuit breaker will perform fast failure logic.
    This means that it doesn't wait for a new fault, for example, a timeout, to happen
    on subsequent calls. Instead, it directly redirects the call to a **fallback**
    **method**. The fallback method can apply various business logic to produce the
    best effort response. For example, a fallback method can return data from a local
    cache or simply return an immediate error message. This will prevent a microservice
    from getting unresponsive if the services it depends on stop responding normally.
    This is specifically useful under high load.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: After a while, the circuit breaker will be half-open*,* allowing new calls to
    see whether the issue that caused the failures is gone. If new failures are detected
    by the circuit breaker, it will open the circuit again and go back to the fast
    failure logic. Otherwise, it will close the circuit and go back to normal operation.
    This makes a microservice resilient to faults, a capability that is indispensable
    in a system landscape of microservices that communicate synchronously with each
    other!
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Resilience4j exposes information about circuit breakers at runtime in a number
    of ways:'
  prefs: []
  type: TYPE_NORMAL
- en: The current state of a circuit breaker can be monitored using the microservice's actuator `health`
    endpoint, `/actuator/health`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The circuit breaker also publishes events on an `actuator` endpoint, for example,
    state transitions, `/actuator/circuitbreakerevents`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Finally, circuit breakers are integrated with Spring Boot's metrics system and
    can use it to publish metrics to monitoring tools such as Prometheus.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We will try out the `health` and `event` endpoints in this chapter. In [Chapter
    20](5e6cce2d-d426-4f55-95c9-52b596769a57.xhtml), *Monitoring Microservices*, we
    will see Prometheus in action and how it can collect metrics that are exposed
    by Spring Boot, for example, metrics from our circuit breaker.
  prefs: []
  type: TYPE_NORMAL
- en: 'To control the logic in a circuit breaker, Resilience4J can be configured using
    standard Spring Boot configuration files. We will use the following configuration
    parameters:'
  prefs: []
  type: TYPE_NORMAL
- en: '`ringBufferSizeInClosedState`: Number of calls in a closed state, which are
    used to determine whether the circuit shall be opened.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`failureRateThreshold`: The threshold, in percent, for failed calls that will
    cause the circuit to be opened.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`waitInterval`: Specifies how long the circuit stays in an open state, that
    is, before it transitions to the half-open state.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`ringBufferSizeInHalfOpenState`: The number of calls in the half-open state
    that are used to determine whether the circuit shall be opened again or go back
    to the normal, closed state.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`automaticTransitionFromOpenToHalfOpenEnabled`: Determines whether the circuit
    automatically will transition to half-open once the wait period is over or wait
    for the first call after the waiting period until it transitions to the half-open
    state.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`ignoreExceptions`: Can be used to specify exceptions that should not be counted
    as faults. Expected business exceptions such as not found or invalid input are
    typical exceptions that the circuit breaker should ignore, that is, users that
    search for non-existing data or enter invalid input should not cause the circuit
    to open.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Resilience4j keeps track of successful and failed calls when in the closed and
    half-open state using a ring buffer, hence the parameter names `ringBufferSizeInClosedState`
    and `ringBufferSizeInHalfOpenState`.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will use the following settings:'
  prefs: []
  type: TYPE_NORMAL
- en: '`ringBufferSizeInClosedState = 5` and `failureRateThreshold = 50%`, meaning
    that if three or more of the last five calls are faults, then the circuit will
    open.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`waitInterval = 10000` and `automaticTransitionFromOpenToHalfOpenEnabled =
    true`, meaning that the circuit breaker will keep the circuit open for 10 seconds
    and then transition to the half-open state.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`ringBufferSizeInHalfOpenState = 3`, meaning that the circuit breaker will
    decide whether the circuit shall be opened or closed based on the three first
    calls after the circuit has transitioned to the half-open state. Since the `failureRateThreshold` parameters
    are set to 50%, the circuit will be open again if two or all three calls fail.
    Otherwise, the circuit will be closed.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`ignoreExceptions = InvalidInputException` and `NotFoundException`, meaning
    that our two business exceptions will not be counted as faults in the circuit
    breaker.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Introducing the retry mechanism
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The **retry** mechanism is very useful for random and infrequent faults, such
    as temporary network glitches. The retry mechanism can simply retry a failed request
    a number of times with a configurable delay between the attempts. One very important
    restriction on the use of the retry mechanism is that the services that it retries
    must be **idempotent**, that is, calling the service one or many times with the
    same request parameters gives the same result. For example, reading information
    is idempotent but creating information is typically not. You don't want a retry
    mechanism to accidentally create two orders just because the response from the
    first order's creation got lost in the network.
  prefs: []
  type: TYPE_NORMAL
- en: 'Resilience4j exposes retry information in the same way as it does for circuit
    breakers when it comes to events and metrics but does not provide any health information.
    Retry events are accessible on the `actuator` endpoint, `/actuator/retryevents`. To
    control the retry logic, Resilience4J can be configured using standard Spring
    Boot configuration files. We will use the following configuration parameters:'
  prefs: []
  type: TYPE_NORMAL
- en: '`maxRetryAttempts`: Number of retries before giving up, including the first
    call'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`waitDuration`: Wait time before the next retry attempt'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`retryExceptions`: A list of exceptions that shall trigger a retry'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'In this chapter, we will use the following values:'
  prefs: []
  type: TYPE_NORMAL
- en: '`maxRetryAttempts = 3`: We will make a maximum of two retry attempts.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`waitDuration= 1000`: We will wait one second between retries.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`retryExceptions = InternalServerError`: We will only trigger retries on `InternalServerError`
    exceptions, that is, when HTTP requests respond with a 500 status code.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Be careful when configuring retry and circuit breaker settings so that, for
    example, the circuit breaker doesn't open the circuit before the intended number
    of retries have been completed!
  prefs: []
  type: TYPE_NORMAL
- en: Adding a circuit breaker and retry mechanism to the source code
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Before we add a circuit breaker and a retry mechanism to the source code, we
    will add code that makes it possible to force an error to occur—either a delay
    and/or a random fault. Next, we will add a circuit breaker to handle slow or not
    responding APIs, as well as a retry mechanism that can handle faults that happens
    randomly. Adding these features from Resilience4j follows the traditional Spring
    Boot way:'
  prefs: []
  type: TYPE_NORMAL
- en: Add a starter dependency for Resilience4j in the build file.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Add annotations in the source code where the circuit breaker and retry mechanism
    shall be applied.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Add configuration that controls the behavior of the circuit breaker and retry mechanism.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Once we have the circuit breaker and retry mechanism in place, we will extend
    our test script, `test-em-all.bash`, with the tests of the circuit breaker.
  prefs: []
  type: TYPE_NORMAL
- en: Adding programmable delays and random errors
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To be able to test our circuit breaker and retry mechanism, we need a way to
    control when errors happen. A simple way to achieve this is by adding optional
    query parameters in the API in order to retrieve a product and a composite product.
    The composite product API will simply pass on the parameters to the product API.
    The following query parameters have been added to the two APIs:'
  prefs: []
  type: TYPE_NORMAL
- en: '`delay`: Causes the `getProduct` API on the `product` microservice to delay
    its response. The parameter is specified in seconds. For example, if the parameter
    is set to `3`, it will cause a delay of three seconds before the response is returned.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`faultPercentage`: Causes the `getProduct` API on the `product` microservice to
    throw an exception randomly with the probability specified by the query parameter,
    from 0 to 100%. For example, if the parameter is set to `25`, it will cause every
    fourth call to the API, on average, to fail with an exception. It will return
    an HTTP error 500 internal server error in these cases.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Changes in the API definitions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The two query parameters that we introduced previously, `delay` and `faultPercentage`,
    have been defined in the `api` project in the following two Java interfaces:'
  prefs: []
  type: TYPE_NORMAL
- en: '`se.magnus.api.composite.product.ProductCompositeService`:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: '`se.magnus.api.core.product.ProductService`:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: Changes in the product composite microservice
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The `product-composite` microservice simply passes the parameters to the product
    API. The service implementation receives the API request and passes on the parameters
    to the integration component that makes the call to the product API:'
  prefs: []
  type: TYPE_NORMAL
- en: 'The call to the `se.magnus.microservices.composite.product.services.ProductCompositeServiceImpl` class:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'The call to the `se.magnus.microservices.composite.product.services.ProductCompositeIntegration` class:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: Changes in the product microservice
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The `product` microservice implements actual delay and random error generator
    in `se.magnus.microservices.core.product.services.ProductServiceImpl` as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'The delay function, `simulateDelay()`, uses the `Thread.sleep()` function to
    simulate a delay:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'The random error generator, `throwErrorIfBadLuck()`, creates a random number
    between `1` and `100` and throws an exception if it is higher or equal to the
    specified fault percentage:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: Adding a circuit breaker
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As we mentioned previously, we need to add dependencies, annotations, and configuration.
    We also need to add some code for handling timeouts and fallback logic. We will
    see how to do this in the following sections.
  prefs: []
  type: TYPE_NORMAL
- en: Adding dependencies to the build file
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To add a circuit breaker, we have to add dependencies to the appropriate Resilience4j
    libraries in the build file, `build.gradle`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: Adding the circuit breaker and timeout logic
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The circuit breaker can be applied by annotating the method it is expected
    to protect with `@CircuitBreaker(name="nnn")`, which in this case is the `getProduct()`
    method in the `se.magnus.microservices.composite.product.services.ProductCompositeIntegration`
    class. The circuit breaker is triggered by an exception, not by a timeout itself.
    To be able to trigger the circuit breaker after a timeout, we have to add code
    that generates an exception after a timeout. Using `WebClient`, which is based
    on Project Reactor, allows us to do that conveniently by using its `timeout(Duration)`
    method. The source code looks as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'The name of the circuit breaker, `"product"`, is used to identify the configuration
    that we will go through. The timeout parameter, `productServiceTimeoutSec`, is
    injected into the constructor as a configurable parameter value:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'To activate the circuit breaker, the annotated method must be invoked as a
    Spring Bean. In our case, it''s the integration class that''s injected by Spring
    into the service implementation class and therefore used as a Spring Bean:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: Adding fast fail fallback logic
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: To be able to apply fallback logic when the circuit breaker is open, that is,
    when a request fast fails, we can catch an exception, `CircuitBreakerOpenException`,
    that is thrown by the circuit breaker when it is open and call a fallback method.
    This has to be done outside of the circuit breaker, that is, in the caller. In
    our case, it is the `product-composite` service's implementation that calls the
    integration class.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here, we use the `onErrorReturn` method to call the `getProductFallbackValue()` method
    when we catch `CircuitBreakerOpenException`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'The fallback logic can be based on `productId` lookup information on the product
    from alternative sources, for example, an internal cache. In our case, we return
    a hardcoded value unless `productId` is `13`; otherwise, we throw a not found
    exception:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: Adding configuration
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Finally, the configuration of the circuit breaker is added to the `product-composite.yml` file
    in the config repository, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'Most of the values in the configuration have already been described in *Introducing
    the circuit breaker* section, except for the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '`app.product-service.timeoutSec`: Used to configure the timeout we introduced
    previously. This is set to two seconds.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`registerHealthIndicator`: Determines whether the circuit breaker shall display
    information in the `health` endpoint or not. This is set to `true`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Adding a retry mechanism
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the same way as for the circuit breaker, a retry mechanism is set up by adding
    dependencies, annotations, and configuration. The dependencies were added previously,
    so we only need to add the annotation and set up some configuration. We, however,
    also need to add some error handling logic due to retry-specific exceptions that
    the retry mechanism throws.
  prefs: []
  type: TYPE_NORMAL
- en: Adding the retry annotation
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The retry mechanism can be applied to a method by annotating it with `@Retry(name="nnn")`,
    where `nnn` is the name of the configuration entry to be used for this method.
    See the *Adding configuration* section for details on the configuration. The method,
    in our case, is the same as it is for the circuit breaker, that is, `getProduct()` in
    the `se.magnus.microservices.composite.product.services.ProductCompositeIntegration` class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: Handling retry-specific exceptions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Exceptions that are thrown by a method annotated with `@Retry` can be wrapped
    by the retry mechanism with a `RetryExceptionWrapper` exception. To be able to
    handle the actual exception that the method threw, for example, to apply a fallback
    method when `CircuitBreakerOpenException` is thrown, the caller needs to add logic
    that unwraps `RetryExceptionWrapper` exceptions and replaces them with the actual
    exception.
  prefs: []
  type: TYPE_NORMAL
- en: 'In our case, it is the `getCompositeProduct` method in the `ProductCompositeServiceImpl`
    class that makes the call using the Project Reactor API for `Mono` objects. The
    `Mono` API has a convenient method, `onErrorMap`, that can be used to unwrap `RetryExceptionWrapper`
    exceptions. It is used in the `getCompositeProduct` method like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: Adding configuration
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Configuration for the retry mechanism is added in the same way as it is for
    the circuit breaker, that is, in the `product-composite.yml` file in the config
    repository, like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: The actual values were discussed in *Introducing the retry mechanism* section.
  prefs: []
  type: TYPE_NORMAL
- en: Adding automated tests
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Automated tests for the circuit breaker have been added to the `test-em-all.bash` test
    script in a separate function, `testCircuitBreaker()`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: To be able to perform some of the required verifications, we need to have access
    to the `actuator` endpoints of the `product-composite` microservice, which are
    not exposed through the edge server. Therefore, we will access the `actuator`
    endpoints through a separate Docker container that will be attached to the internal
    network that was set up by Docker Compose for our microservices.
  prefs: []
  type: TYPE_NORMAL
- en: 'By default, the name of the network is based on the name of the folder where
    the Docker Compose file is placed. To avoid that uncertain dependency, an explicit
    network name, `my-network`, is defined in the `docker-compose` files. All container
    definitions have been updated to specify that they shall attach to the `my-network` network.
    The following is an example from `docker-compose.yml`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'Since the container is attached to the internal network, it can access the `actuator`
    endpoints of the product composite without going through the edge server. We will
    use Alpine as our Docker image and use `wget` instead of `curl` since `curl` isn''t
    included in the Alpine distribution by default. For example, to be able to find
    out the state of the circuit breaker named `product` in the `product-composite`
    microservice, we can run the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: The command is expected to return a value of `CLOSED`.
  prefs: []
  type: TYPE_NORMAL
- en: Since we have created the Docker container with the `--rm` flag, it will be
    stopped and destroyed by the Docker engine after the `wget` command completes.
  prefs: []
  type: TYPE_NORMAL
- en: 'The test starts by doing exactly this, that is, verifying that the circuit
    breaker is closed before the tests are executed:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, the test will force the circuit breaker to open up by running three commands
    in a row, all of which will fail on a slow response from the `product` service:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: '**Quick repetition of the configuration**: The timeout of the `product` service
    is set to two seconds so that a delay of three seconds will cause a timeout. The
    circuit breaker is configured to evaluate the last five last calls when closed.
    The tests in the script that precede the circuit breaker-specific tests have already
    performed a couple of successful calls. The failure threshold is set to 50%, that
    is, three calls with a three-second delay is enough to open the circuit.'
  prefs: []
  type: TYPE_NORMAL
- en: 'With the circuit open, we expect a fast failure, that is, we won''t need to
    wait for the timeout before we get a response. We also expect the `fallback` method
    to be called to return a best-effort response. This should also apply for a normal
    call, that is, without requesting a delay. This is verified with the following
    code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'We can also verify that the simulated not found error logic works as expected
    in the fallback method, that is, the fallback method returns `404`, `NOT_FOUND`
    for product ID `13`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'As configured, the circuit breaker will change its state to half-open after
    `10` seconds. To be able to verify that, the test waits for `10` seconds:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'After verifying the expected state (half-closed), the test runs three normal
    requests to make the circuit breaker go back to its normal state, which is also
    verified:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: '**Quick repetition of the configuration:** The circuit breaker is configured
    to evaluate the first three calls when in the half-open state. Therefore, we need
    to run three requests where more than 50% are successful before the circuit is
    closed.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The test wraps up by using the `/actuator/circuitbreakerevents` actuator API,
    which is exposed by the circuit breaker to reveal internal events. It can, for
    example, be used to find out what state transitions the circuit breaker has performed.
    We expect the last three state transitions to be as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: 'First state transitions: Closed to open'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Next state transitions: Open to half-closed'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Last state transitions: Half-closed to closed'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'This is verified by the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: The `jq` expression, `circuitBreakerEvents[-1]`, means the last entry in the
    array of circuit breaker events, `[-2]`, is the second to last event, while `[-3
    ]` is the third to last event. Together, they are the three latest events, that
    is, the ones we are interested in. By default, Resilience4j keeps the last 100
    events per circuit breaker. This can be customized using the `eventConsumerBufferSize` configuration
    parameter.
  prefs: []
  type: TYPE_NORMAL
- en: We added quite a lot of steps to the test script, but with this, we can automatically
    verify that the expected basic behavior of our circuit breaker is in place. In
    the next section, we will try it out!
  prefs: []
  type: TYPE_NORMAL
- en: Trying out the circuit breaker and retry mechanism
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Now, it''s time to try out the circuit breaker and retry mechanism. We will
    start, as usual, by building the Docker images and running the test script, `test-em-all.bash`.
    After that, we will run through the tests we described previously manually to
    ensure that we understand what''s going on! We will perform the following manual
    tests:'
  prefs: []
  type: TYPE_NORMAL
- en: Happy days tests of the circuit breaker, that is, to verify that the circuit
    is closed under normal operations
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Negative tests of the circuit breaker, that is, to verify that the circuit opens
    up when things start to go wrong
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Going back to normal operation, that is, to verify that the circuit goes back
    to its closed state once the problems are resolved
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Trying out the retry mechanism with random errors
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Building and running the automated tests
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In order to build and run the automated tests, we need to do the following:'
  prefs: []
  type: TYPE_NORMAL
- en: 'First, build the Docker images with the following commands:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, start the system landscape in Docker and run the usual tests with the
    following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: When the test script prints out `Start Circuit Breaker tests!`, the tests we
    described previously are executed!
  prefs: []
  type: TYPE_NORMAL
- en: Verifying that the circuit is closed under normal operations
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Before we can call the API, we need an access token. Run the following commands
    to acquire an access token:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'Try a normal request and verify that it returns the HTTP response code `200`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: The `-w "%{http_code}\n"` switch is used to print the HTTP return status. As
    long as the command returns `200`, we are not interested in the response body,
    and so we suppress it with the switch, that is, `-o /dev/null`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Verify that the circuit breaker is closed using the `health` API:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: We expect it to respond with `CLOSED`.
  prefs: []
  type: TYPE_NORMAL
- en: Forcing the circuit breaker to open when things go wrong
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Now, it''s time to make things go wrong! By that, I mean it''s time to try
    out some negative tests in order to verify that the circuit opens up when things
    start to go wrong. Call the API three times and direct the `product` service to
    cause a timeout on every call, that is, delay the response with `3` seconds. This
    should be enough to trip the circuit breaker:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'We expect a response such as the following each time:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'The circuit breaker is now open, so if you make a fourth attempt (within `waitInterval`,
    that is, `10` seconds), you will see a fast fail and the `fallback` method in
    action. You will get a response back immediately, instead of an error message
    once the timeout kicks in after `2` seconds:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: The response will come from the fallback method. This can be recognized by looking
    at the value in the name field, that is, `Fallback product2`.
  prefs: []
  type: TYPE_NORMAL
- en: Fast fail and fallback methods are key capabilities of a circuit breaker!
  prefs: []
  type: TYPE_NORMAL
- en: Given our configuration with a wait time set to only 10 seconds requires you
    to be rather quick to be able to see fast fail and fallback methods in action!
    Once in a half-open state, you can always submit three new requests that cause
    a timeout, forcing the circuit breaker back to the open state, and then quickly
    try the fourth request. Then, you should get a fast fail response from the fallback
    method! You can also increase the wait time to a minute or two, but it can be
    rather boring to wait that amount of time before the circuit switches to the half-open
    state.
  prefs: []
  type: TYPE_NORMAL
- en: 'Wait 10 seconds, for the circuit breaker to transition to half-open and then
    run the following command to verify that the circuit now is in a half-open state:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: Expect it to respond with `HALF_OPEN`.
  prefs: []
  type: TYPE_NORMAL
- en: Closing the circuit breaker again
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Once the circuit breaker is in a half-open state, it waits for three calls to
    see whether it should open the circuit again or go back to normal, that is, close
    it.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s submit three normal requests to close the circuit breaker:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'They should all response with `200`. Verify that the circuit is closed again
    by using the `health` API:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: We expect it to respond with `CLOSED`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Wrap this up by listing the last three state transitions using the following
    command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: 'Expect it to respond with the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: 'This response tells us that we have taken our circuit breaker through a full
    lap of its state diagram:'
  prefs: []
  type: TYPE_NORMAL
- en: From closed to open when an error starts to prevent requests from succeeding
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: From open to half-open to see whether the error is gone
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: From half-open to closed when the error is gone, that is, when we are back to
    normal operation
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Trying out retries caused by random errors
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Let's simulate that there is a – hopefully temporary – random issue with our
    `product` service or the communication with it.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can do this by using the `faultPercent` parameter. If we set it to `25`,
    we expect every fourth request to fail. We hope that the retry mechanism will
    kick in to help us by automatically retrying the request. One way of noticing
    that the retry mechanism has kicked in is to measure the response time of the
    `curl` command. A normal response should take no more than 100 ms. Since we have
    configured the retry mechanism to wait one second (see the `waitDuration` parameter
    in the configuration of the preceding retry mechanism), we expect the response
    time to increase with one second per retry attempt. To force a random error to
    occur, run the following command a couple of times:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: 'The command should respond with `200`, indicating that the request succeeded.
    A response time prefixed with `real`, for example, `real 0m0.078s` means that
    the response time was 0.078 s or 78 ms. A normal response, that is, without any
    retries, should look as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: 'A response after one retry should look as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: The HTTP status code 200 indicates that the request has succeeded, even though
    it required one retry before succeeding!
  prefs: []
  type: TYPE_NORMAL
- en: 'After you have noticed a response time of one second, that is, the request
    required one retry to succeed, run the following command to see the last two retry
    events:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: 'You should be able to see the failed request and the next successful attempt.
    The `creationTime` timestamps are expected to differ by one second. Expect a response
    such as the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: 'If you are really unlucky, you will get two faults in a row, and then you will
    get a response time of two seconds instead of one. If you repeat the preceding
    command, you will be able to see that the `numberOfAttempts` field is counted
    for each retry attempt, which is set to `2` in this case: `"numberOfAttempts":
    2`. If calls continue to fail, the circuit breaker will kick in and open its circuit,
    that is, subsequent calls will fast fail and the fallback method will be applied!'
  prefs: []
  type: TYPE_NORMAL
- en: '**That''s it!**'
  prefs: []
  type: TYPE_NORMAL
- en: Feel free to elaborate with the parameters in the configuration to learn about
    the circuit breaker and retry mechanisms better!
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we have seen Resilience4j and its circuit breaker and retry
    mechanism in action.
  prefs: []
  type: TYPE_NORMAL
- en: A circuit breaker can, using fast fail and `fallback` methods when it is open,
    prevent a microservice from becoming unresponsive if the synchronous services
    it depends on stop responding normally. A circuit breaker can also make a microservice
    resilient by allowing requests when it is half-open to see whether the failing
    service operates normally again and close the circuit if so.
  prefs: []
  type: TYPE_NORMAL
- en: A retry mechanism can retry requests that randomly fail from time to time, for
    example, due to temporary network problems. It is very important to only apply
    retry requests on idempotent services, that is, services that can handle that
    the same request is sent two or more times.
  prefs: []
  type: TYPE_NORMAL
- en: Circuit breakers and retry mechanisms are implemented by following Spring Boot
    conventions, that is, declaring dependencies, and adding annotations and configuration.
    Resilience4j exposes information about its circuit breakers and retry mechanisms
    at runtime, using `actuator` endpoints for health, events, and metrics for circuit
    breakers and events and metrics for retries.
  prefs: []
  type: TYPE_NORMAL
- en: We have seen the usage of both endpoints for health and events in this chapter,
    but we will have to wait until [Chapter 20](5e6cce2d-d426-4f55-95c9-52b596769a57.xhtml),
    *Monitoring Microservices*, before we use any of the metrics.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will cover the last part of using Spring Cloud, where
    we will learn how to trace call chains through a set of cooperating microservices
    using Spring Cloud Sleuth and Zipkin. Head over to [Chapter 14](42f456c5-d911-494a-a1ba-4631863068b6.xhtml),
    *Understanding Distributed Tracing*, to get started!
  prefs: []
  type: TYPE_NORMAL
- en: Questions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: What are the states of a circuit breaker and how are they used?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How can we handle timeout errors in the circuit breaker?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How can we apply fallback logic when a circuit breaker fast fails?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How can a retry mechanism and a circuit breaker interfere with each other?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Provide an example of a service that you can't apply a retry mechanism for.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
