- en: Assessments
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Chapter 1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'An enterprise Java microservice has the following features:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: It is written using the Java language.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: It can use any Java framework.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: It can use any Java APIs.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'It must be enterprise-grade: reliable, available, scalable, secure, robust,
    and performant.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'It must fulfill the characteristics of microservice architectures as listed
    at [https://martinfowler.com/microservices/](https://martinfowler.com/microservices/),
    which are as follows:'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Componentization via services
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Organized around business capabilities
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Products not projects
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Smart endpoints and dumb pipes
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Decentralized governance
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Decentralized data management
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Infrastructure automation
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Design for failure
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Evolutionary design
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: The terms digital economy and digital transformation describe the convergence
    of four different forces ...
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Chapter 2
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The main means of communication for the MicroProfile community is their Google
    Group, called *Eclipse MicroProfile*. You can post a message to it by sending
    an email to `microprofile@googlegroups.com`. Another great way to get your voice
    heard is by attending the bi-weekly MicroProfile Hangout call. Please check the
    MicroProfile Google Calendar to find out the exact date, time, and meeting information
    to join.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The MicroProfile Hangout call serves as a forum where topics brought up by attendees
    are discussed and decisions are made, from sub-project statuses and release contents
    to release dates and sub-project creation approvals.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: A sub-project (MicroProfile specification) lead or a group of leads are usually
    subject-matter experts in the topic at hand and are designated to serve as its
    facilitators. One important aspect to note is that the lead or leads of a working
    group (or sub-project for that matter) do not single-handedly shape or determine
    the evolution of a specification or what capabilities are included or not. They
    do not have veto power or a final say in the decisions made with respect to their
    specification. By sharing of ideas, expertise, past experiences, analysis of existing
    technologies, and best practices, the working group will come up with their best
    proposal possible.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: After the community discusses a new idea at length in the MicroProfile Google
    Group and/or the MicroProfile Hangout call, and it's been determined that it is
    worth furthering the debate, the community decides to create a working group for
    this new idea, and a lead or a group of leads, who are usually subject-matter
    experts in the topic at hand, are designated to serve as its facilitators. The
    working group will establish a recurring weekly or bi-weekly meeting, which is
    entered in the MicroProfile Google Calendar. Anybody can attend these meetings,
    but there's usually a core number of people that serve as the subject-matter experts
    that participate in these calls. After a few meetings, the working group decides
    whether or not the new functionality should be brought up to the MicroProfile
    Hangout call to discuss its proposal to become a MicroProfile sub-project. At
    the MicroProfile Hangout call, a sub-project proposal may be rejected or accepted. The
    acceptance of a sub-project means that it effectively addresses a need that enriches
    the specification towards its goal of optimizing enterprise Java for a microservices
    architecture. It is at this moment, that a sub-project becomes an official MicroProfile
    API. Once the sub-project becomes a MicroProfile API, then a determination is
    made whether it should be a standalone sub-project outside the umbrella or a sub-project
    included in the umbrella of MicroProfile releases.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Eclipse MicroProfile follows a time-boxed rapid incremental release schedule,
    which is public and listed on the Eclipse Foundation MicroProfile Project page.
    Major Eclipse MicroProfile releases, for example, from 1.x to 2.x, include major
    updates to MicroProfile APIs that may introduce breaking changes. Minor releases,
    that is, point releases, include small API updates or new APIs that make the predetermined
    release date. Currently, the MicroProfile community release windows are in February,
    June, and November of every year for minor and/or major releases.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The sandbox repository, which is a GitHub repository, is for incubating ideas
    and code examples that will eventually turn into a separate repository, contributing
    to a new specification. Anybody can open pull requests and use the sandbox for
    experimentation of new ideas and to share code and documentation, which can be
    used as part of the discussion in the community Google Group, the MicroProfile
    Hangout calls, or working group meetings.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The reason for releasing a sub-project outside the MicroProfile umbrella/platform
    release is that it gives the community and end users an opportunity to utilize
    and test the new technology, hence proving it in real applications before it can
    be considered for inclusion to the umbrella. The MicroProfile project encourages
    that a new sub-project specification at least release one version outside the
    umbrella before its inclusion in the umbrella/platform release can be considered.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The MicroProfile Starter is a samples source code generator, whose goal is to
    aid developers to quickly get started using and exploiting the capabilities of
    the community-driven open source specification for enterprise Java microservices,
    Eclipse MicroProfile, by generating working sample code in a Maven project.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Chapter 3
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The default sources of configuration properties are environment variables, Java
    system properties, and the `META-INF`/`microprofile-config.properties` file.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: You can provide a custom ConfigSource implementation that maps property names
    to values in the custom source.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Strings are not the only supported types, as MP-Config supports type conversion
    via a pluggable SPI, and provides several default conversions by default.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: You do not need to provide a value for an injected property if you have given
    a `defaultValue`, or have injected the property as an `Optional<?>` value.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Complex property types can be handled using a custom `Converter<?>` implementation
    that takes a string and returns the complex type.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: When an annotation is specified at the class ...
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Chapter 4
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The wire format is not usable in environments that only look at the HTTP status
    code to determine the HC status.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: An MP-HC response can include arbitrary properties using the `HealthCheckResponse#withData()`
    methods.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: You can create a HealthCheck implementation for each service, and the MP-HC
    feature will logically combine them to produce an overall status response.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: A JWT is a JSON Web Token, a JSON-formatted object that has a header, payload,
    and signature component.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: A claim is a single named value from the JWT payload.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Anything that can be represented in JSON can be used in a JWT.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The single main step in authenticating a JWT is validating that it is signed
    via the RS256 algorithm based on a configured public key.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: One could look at claims other that the groups claim to make checks to add application
    specific authorization decisions.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Chapter 5
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Distributed tracing provides a micro-view of what happened with a request from
    end to end, whereas metrics expose scalar numerical values from a single component.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Distributed tracing systems usually provide features such as the root cause
    and critical path analysis, contextualized logging, distributed context propagation,
    and service dependency diagrams.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Automatically traced are JAX-RS server endpoints and MicroProfile Rest clients.
    Some vendors can also automatically trace JAX-RS clients.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: These tags are added for every REST request `http.method`, `http.status_code`,
    `http.url`, `component`, `span.kind` and `error` if an exception is thrown.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Explicit instrumentation can be added by using `@Traced` annotation or injecting
    the tracer and creating ...
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Chapter 6
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'No: by default, any REST endpoint will have OpenAPI generated for it even if
    none of the MP OpenAPI annotations are used.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Yes: you can choose to use as many or as few of the MP OpenAPI annotations
    as you wish, to represent the REST endpoints in your microservice.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The notion is that you predefine the expected contracts of your endpoints and
    encapsulate these in OpenAPI documents that can be bundled with your microservice.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'No: you just need to know what the formats of the request and response are,
    and then you can create your own type-safe interface.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: By using the `.../mp-rest/url` MP Config setting, where `...` is either the
    interface name of the type-safe interface or the configKey passed to the `RegisterRestClient`
    annotation.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: One way is to register a `ClientHeadersFactory` implementation. Another is to
    list the headers in the `org.eclipse.microprofile.rest.client.propagateHeaders`
    MP-Config property.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Chapter 7
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: At the time of writing, there are eight implementations of Eclipse MicroProfile,
    all of which are open source. They are Thorntail, Open Liberty, Apache TomEE,
    Payara Micro, Hammock, KumuluzEE, Launcher, and Helidon. There is also Quarkus
    as the latest entrant.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: An application server is a container for Java EE applications. An application
    assembler only includes the functionality that the application needs, instead
    of requiring an application server to be up and running, and commonly generates
    an executable JAR. An application assembler can generate an uberjar, a self-contained
    runnable JAR file, or an application jar with its runtime dependencies located
    in a sub-directory, for example, an accompanying `lib` or `libs` sub-directory.
    ...
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Chapter 8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We have seen many examples throughout the book and this chapter that MP-Config
    settings affect both application and MP features.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: As long as the path you supplied exists, you should be able to see a successful
    heath check with information about that path.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: It shows information about the KeyCloak server. If KeyCloak is stopped, it shows
    an error.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: It will not be found because the metric is generated lazily on first request.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: TBD.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: For unsecured methods the behavior should be similar. For secured methods, the
    Swagger-UI invocations fail.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: You will see error responses.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'That is the encoded MP-JWT. You can use that in a curl command as the *Authorization:
    Bearer ...* header value where you would replace the ... with the string found
    in the Access Base64 Token field.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Chapter 9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: MicroProfile Reactive Messaging is a great option for handling message sources
    via connectors, especially in situations where the source is generating messages
    at a high frequency and an asynchronous approach to processing them makes the
    most sense.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: MicroProfile Context Propagation best supports MicroProfile Reactive Streams
    Operators and MicroProfile Reactive Messaging in that it allows the propagation
    of context that was traditionally associated with the current thread across various
    types of units of work.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The current specifications that support reactive programming are MicroProfile
    Reactive Streams Operators, MicroProfile Reactive Messaging, and MicroProfile
    Context Propagation.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: At the time of writing, the projects that sit ...
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Chapter 10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Eclipse MicroProfile provide one of the best approaches to develop microservices
    using enterprise Java. In turn, microservices developed using containers as their
    unit of deployment provide one of the best approaches to develop highly distributed
    systems in the cloud and on-premises, that is, cloud-native applications. Hence,
    MicroProfile-based microservices facilitate the development of cloud-native applications.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'There are two complementary aspects or components to cloud-native application
    development: application services and infrastructure services. Application services
    speed up the development of business logic of a cloud-native application, and
    infrastructure services speed up its delivery and deployment. These two aspects
    are complementary and integral to cloud-native application development.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Cloud-native application development is an approach to building and running
    applications that takes full advantage of the cloud computing model based upon
    four key tenets: a) A service-based architecture (miniservices, microservices,
    SOA services, and so on); b) An API-driven approach for inter-service communication;
    c) An underlying infrastructure that’s based on containers; and d) DevOps processes.
    The architecture and communication aspects are related to the development concerns
    of cloud-native applications, and the infrastructure and the process aspects are
    related to their delivery/deployment. Eclipse MicroProfile relates to these tenets
    in that it supports the implementation of microservices that can be part of an
    architecture that uses containers as its underlying infrastructure, where microservices
    communicate with each other using their APIs, and are developed using DevOps processes.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'This is how Eclipse MicroProfile contributes to each of the eight steps to
    guide your journey to cloud-native applications:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Evolve a DevOps culture and practices: "Take advantage of new technology, faster
    approaches, and tighter collaboration by embracing the principles and cultural
    values of DevOps and organizing your organization around those values." Although
    this is an organizational and process-related step, Eclipse MicroProfile, as a
    specification for microservices, can be a good fit for this adaptation of culture
    and process because microservices, due to its characteristics, closely support
    DevOps processes.'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Speed up existing applications using fast monoliths: "Accelerate existing applications
    by migrating to a modern, container-based platform—and break up monolithic applications
    into microservices or miniservices for additional efficiency gains." Eclipse MicroProfile
    can be of great help when breaking up your monolith into microservices. As you
    identify bounded contexts in your monolith, consider using Eclipse MicroProfile
    to implement each of the microservices that implement the logic of each bounded
    context.'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Use application services to speed up development: "Speed software development
    with reusability. Cloud-native application services are ready-to-use developer
    tools. However, these reusable components must be optimized and integrated into
    the underlying cloud-native infrastructure to maximize benefits." An In-Memory-Data-Grid
    (IMDG) and a messaging broker are application services that help speed up the
    development of business logic. A microservice, developed using Eclipse MicroProfile,
    can leverage these application services by invoking them from within its method
    bodies. Eclipse MicroProfile does not impose any kind of restriction when integrating
    to application services, such as an IMDG or a messaging broker.'
  prefs:
  - PREF_UL
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Choose the right tool for the right task: "Use a container-based application
    platform that supports the right mix of frameworks, languages, and architectures—and
    can be tailored to your specific business application need."  Eclipse MicroProfile
    is one of these tools that a developer can use when choosing the right tool for
    the right task. For example, Red Hat Application Runtimes is a collection of runtimes
    and tools, which includes Eclipse MicroProfile, Node.js, Spring Boot, and Vert.x.'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Provide developers with self-service on-demand infrastructure: "Use containers
    and container orchestration technology to simplify access to underlying infrastructure,
    give control and visibility to IT operations teams, and provide robust application
    life-cycle management across various infrastructure environments, such as datacenters,
    private clouds, and public clouds."  The microservices you develop with Eclipse
    MicroProfile can be deployed to one or more containers. By easily managing these
    containers and your microservices architecture running on them, you can accelerate
    your development cycles to deliver value to the business faster.'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Automate IT to accelerate application delivery: "Create automation sandboxes
    for learning the automation language and process, establish collaborative dialog
    across organizations for defining service requirements, create self-service catalogs
    that empower users and speed delivery, and use metering, monitoring, and chargeback
    policies and processes." Eclipse MicroProfile provides capabilities for metrics,
    fault tolerance, and health checks, all of which can be used as input to the IT
    automation processes.'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Implement continuous delivery and advanced deployment techniques: "Accelerate
    the delivery of your cloud-native applications with automated delivery, continuous
    integration/continuous delivery (CI/CD) pipelines, rolling blue/green and canary
    deployments, and A/B testing." The use of microservices in combination with CI/CD
    can facilitate advanced deployment techniques. For example, you can introduce
    a MicroProfile-based microservice with new functionality as part of a blue/green
    or canary deployment intro production, and switch all of the traffic to it once
    you have proven that the new functionality works as expected.'
  prefs:
  - PREF_UL
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Evolve a more modular architecture: "Choose a modular design that makes sense
    for your specific needs, using microservices, a monolith-first approach, or miniservices—or
    a combination." For this step, you can use Eclipse MicroProfile to develop microservices
    for new applications or as you break specific bounded contexts of your monolith
    into microservices.'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Twelve-factor app is a methodology that a developer can follow while designing
    and implementing microservices and applications, independent of the programming
    language or framework being used to implement them. The framework that a developer
    can use to implement microservices using twelve-factor app is Eclipse MicroProfile.
    Twelve-factor app and Eclipse MicroProfile are not mutually exclusive, but are
    complementary to each other.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Most, if not all, market FaaS offerings support Java. As such, developers can
    write the function bodies in one of the many implementations of Eclipse MicroProfile,
    which are all in Java. The ease of use and rich functionality of Eclipse MicroProfile
    combined with the simplicity of a FaaS platform can greatly improve the ability
    of developers to deliver value to the business faster. In addition, a technology
    such as Quarkus, which implements Eclipse MicroProfile, uses low amounts of memory
    and has fast startup times, is an ideal runtime for a FaaS.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'When using Eclipse MicroProfile in a deployment across clouds, here are the
    things you need to consider:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Configuration of communication routes between the cloud environment and the
    on-premise environment needs to be done using whatever DNS support the cloud environment
    provides.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Configuration of MicroProfile OpenTracing to enable capture of tracing across
    the cloud environments.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Monitoring of the split MicroProfile Metrics information across the cloud environments
  prefs:
  - PREF_UL
  - PREF_UL
  type: TYPE_NORMAL
- en: Setting up the CI tasks to target the appropriate cloud environment to maintain
    the correct microservices.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Distributed tracing in a multi-cloud environment can be challenging. We want
    to fulfill the same objective as with a single cloud environment to visualize
    the single end-to-end trace associated with a request as it passes through services
    within and across each cloud, but may face complications when dealing with different
    context propagation formats and storage of the tracing data in different formats
    per cloud. The first challenge is to ensure that a trace continues across different
    cloud environments. This is a problem because, at the time of writing, there is
    not widely adopted or standardized trace context format. Usually, each tracing
    system uses different headers and formats to propagate the tracing context. The
    second challenge, even in a homogenous tracing environment, is to visualize tracing
    data from multi-cloud environments. This can be problematic because tracing data
    in each cloud might be stored in different databases or in different formats.
    This can be overcome by replicating the data to a single unified storage or sending
    missing tracing data between systems on-demand with the appropriate data format
    adjustments.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Service Meshes such as Istio or LinkerD offer services at the platform level
    on top of Kubernetes in the areas of discovery, routing, and fault tolerance.
    Some of those services can also be found in MicroProfile. When you deploy a MicroProfile
    application into such a Service Mesh, you need to consider if you want to use
    the version from MicroProfile or the one from the Mesh. The MicroProfile feature
    that is most likely affected here is Fault Tolerance, and especially the retry
    logic.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
