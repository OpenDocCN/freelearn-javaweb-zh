- en: Chapter 5. Message Flow
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We discussed message transformation in the last chapter. After transformation
    has been taken care of, there can be additional tasks before it can be delivered
    to the next in the chain. For example, messages might need some chunking, or they
    might be incomplete and need some temporary storage or sequencing. In this chapter,
    we will explore the out-of-the-box capabilities that the Spring Integration framework
    provides for a seamless flow of messages across heterogeneous components. We will
    cover the following topics in this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: Routers
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Filters
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Splitters
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Aggregators
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Resequencers
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Chaining handlers
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Routers
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**Routers** are components that pick messages from a channel and, depending
    on a set of pre-defined criteria, deliver them to different channels. Routers
    never change the message—they only route/reroute messages to the next destination.
    Spring Integration provides the following built-in routers:'
  prefs: []
  type: TYPE_NORMAL
- en: Payload-type router
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Header value router
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Recipient list router
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: XPath router (part of the XML module)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Error message exception-type router
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Payload-type router
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'As can be observed from the preceding code snippet, depending on the payload
    type, the message is routed to different channels. The `java.lang.String` class
    has been configured to be routed to `jmsChannel`, while `org.springframework.messaging.Message`
    has been configured to be routed to `mailChannel`. The following two elements
    have been used:'
  prefs: []
  type: TYPE_NORMAL
- en: '`int:payload-type-router`: This is used to provide a namespace for the payload-type
    router'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`int:mapping`: This is the tag used to provide mapping between the Java object
    and the channel'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Header value router
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Instead of using the type of message payload, this router will try to read
    headers that have been set on the payload:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: Recipient list router
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Do not get confused with recipients who are users! Here, the recipient list
    refers to a list of channels, which can receive the message. It can be compared
    to the publish-subscribe channel use case, where a predefined set of channels
    are "subscribed" with the router:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'All the messages delivered on the feeds channel will be delivered both on `transformFeedChannel`
    and `auditFeedChannel`. The elements used are simple:'
  prefs: []
  type: TYPE_NORMAL
- en: '`int:recipient-list-router`: This is used to provide a namespace for a recipientlist
    router'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`int:recipient`: This is used to provide the name of the channel, which should
    receive the message'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: XPath router
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In [Chapter 4](part0037_split_000.html#page "Chapter 4. Message Transformers"),
    *Message Transformers*, we discussed handling XML payloads in detail and we discussed
    an example of *XPath*-based transformers. XPath router is similar—instead of transforming
    a message based on the XPath value, it is routed to one of the channels:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'This can send messages to a channel or a set of channels—the value of the expression
    will decide the channels to which messages should be routed. There is a way to
    route messages to specific channels based on the value of the expression:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: Error message exception-type router
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'An explanation of the tags used in this code snippet is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '`int:exception-type-router`: This provides the namespace for exception-type
    router.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`default-output-channel`: This is used to specify the default channel where
    the message should be delivered if none of the mappings can resolve a channel
    for the message. This is defined later in detail.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`int:mapping exception-type`: This is used to map an exception to a channel
    name.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Default output channel
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'There can be cases where the router is unable to decide which channel a message
    should be delivered to—what to do in this case? The following two options are
    available:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Throw an exception**: Depending on a use case, this can be an exception that
    has been mapped to a channel, or the exception can be thrown to be propagated
    above in the chain.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Define a default output channel**: As the name suggests, this is the channel
    where all the messages for which channel delivery cannot be decided are delivered.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'For example, in the preceding code snippet, the default channel has been specified
    as:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: If the exception cannot be mapped to a defined list, a message will be put on
    the default channel.
  prefs: []
  type: TYPE_NORMAL
- en: Using annotations
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Spring''s power comes from converting simple Java classes to specific components
    without extending or implementing external classes. To define routers, we can
    leverage the framework''s `@Router` annotation. We can annotate any method with
    `@Router`, and can use its reference. Let''s take an example where we want to
    route our feed based on the author:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: The return value is a string that is the author's name—a channel with the same
    name must be present. Alternatively, we can return `MessageChannel` or a list
    of `MessageChannel` references directly.
  prefs: []
  type: TYPE_NORMAL
- en: Filters
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Message filters are Spring Integration components, which act as an interceptor
    and decide whether to pass on the message to the next channel/component or drop
    it. Unlike routers, which decide what should be the next channel for a message,
    filters only take a *boolean* decision—whether to pass or not. There are two ways
    to define a message filter in Spring Integration:'
  prefs: []
  type: TYPE_NORMAL
- en: Write a simple Java class and designate its method that will take decisions
    whether to pass the message or not
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Configure it as a message endpoint that delegates to an implementation of the
    `MessageSelector` interface
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: This can be configured either in XML or annotations can be used.
  prefs: []
  type: TYPE_NORMAL
- en: Using a Java class to act as a filter
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Let''s take an example of using a simple Java class as a filter—this is part
    of our example about feeds. As feeds come in, we try to validate whether the payload
    is empty or not—then only pass it on for further processing:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'The tags interpretation is as simple and intuitive as it can be:'
  prefs: []
  type: TYPE_NORMAL
- en: '`int:filter`: This is used to specify the Spring framework namespace for filters'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`input-channel`: This is the channel from which messages will be picked'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`output-channel`: This is the channel to which messages will be delivered if
    they pass the filtering criteria'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`ref`: This is used for the reference of the Java bean that is acting as a
    filter'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`method`: This is the method of the Java bean acting as a filter'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Declaration for the bean acting as a filter is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'An actual Java class that has method filtering for the messages, is shown in
    the following code snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'We can also decide what to do if the payload fails the filtering criteria,
    for example, if the payload is empty. In such a case, we can do either of the
    following two options:'
  prefs: []
  type: TYPE_NORMAL
- en: An exception can be thrown
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It can be routed to a specific channel where action can be taken on it—say,
    just log the occurrence of a failure
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'To throw an exception, we can use the following code snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'To log the exception, we can use the following code snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: Here, we used a filter on a direct channel and validated the payload. If validation
    was successful, we passed on the message; otherwise, we rejected the message either
    by throwing an exception or by logging its occurrence. Another use case for filters
    could be publish-subscribe channels—many endpoints can listen on a channel and
    filter out the messages of their interest.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can also use *annotation* to define filters. Just using the `@Filter` annotation
    on a method of Java class and Spring Integration will convert it to a filter component—no
    need to extend or implement any additional reference:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'A filter declaration in XML needs to be changed, no need to use the `method`
    parameter:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: Configuring a filter as a message endpoint
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Another option to define a filter is to use frameworks (`MessageSelector`).
    The Java class needs to implement this interface and override the `accept` method.
    Whenever a payload is passed, the `accept` method is invoked and it returns a
    decision whether to pass on the message or drop it. The following code snippet
    modifies the previous example using `MessageSelector`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'After this definition, the filter can be declared and used as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: Since bean class has been declared inline, there is no need for the reference
    tag.
  prefs: []
  type: TYPE_NORMAL
- en: Splitters
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Splitters, as the name suggests, are used to split messages in smaller chunks
    and then send such resulting chunks for independent processing. There can be several
    reasons for splitting—larger size of payload than that of what is acceptable by
    the next endpoint, or message load parts that can be processed in parallel or
    down the chain. There is an aggregator and it is necessary to do some processing
    before these can be aggregated. Spring Integration provides a `splitter` tag.
    As in the case of a filter, splitters can also be written either by extending
    the framework interface or by writing a custom POJO.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s take the simpler one first, leveraging a simple Java class as a splitter:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'The elements are pretty self-explanatory:'
  prefs: []
  type: TYPE_NORMAL
- en: '`int:splitter`: This is used to specify the Spring framework namespace for
    filters'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`ref`: This is used to provide a reference of bean acting as a splitter'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`method`: This is used to specify a method in bean having message splitting
    implementation'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`input-channel`: This is the channel from which messages will be read'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`output-channel`: This is the channel on which messages will be written'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Java class acting as a splitter:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'Splitters must return a type of collection, and each item from that collection
    is then delivered one at a time to the next endpoint. If the returned value is
    not a message type, then each element will be wrapped in a message type before
    delivery. Let''s define a service activator for this splitter:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'The method `printSplitMessage` is defined in the following code snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'We can avoid using the `method` tag by using annotation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'As in the case of filters, we can also use framework support to write our splitters.
    Any Java class can extend `AbstractMessageSplitter` and override `splitMessage`.
    The previous example has been modified by extending the framework support in the
    following code snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: Aggregators
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The aggregators are the opposite of splitters—they combine multiple messages
    and present them as a single message to the next endpoint. This is a very complex
    operation, so let''s start by a real life scenario. A news channel might have
    many correspondents who can upload articles and related images. It might happen
    that the text of the articles arrives much sooner than the associated images—but
    the article must be sent for publishing only when all relevant images have also
    arrived. This scenario throws up a lot of challenges; partial articles should
    be stored somewhere, there should be a way to correlate incoming components with
    existing ones, and also there should be a way to identify the completion of a
    message. Aggregators are there to handle all of these aspects—some of the relevant
    concepts that are used are `MessageStore`, `CorrelationStrategy`, and `ReleaseStrategy`.
    Let''s start with a code sample and then we will dive down to explore each of
    these concepts in detail:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'Hmm, a pretty big declaration! And why not—a lot of things combine together
    to act as an aggregator. Let''s quickly glance at all the tags used:'
  prefs: []
  type: TYPE_NORMAL
- en: '`int:aggregator`: This is used to specify the Spring framework''s namespace
    for the aggregator.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`input-channel`: This is the channel from which messages will be consumed.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`output-channel`: This is the channel to which messages will be dropped after
    aggregation.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`ref`: This is used to specify the bean having the method that is called on
    the release of messages.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`method`: This is used to specify the method that is invoked when messages
    are released.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`release-strategy`: This is used to specify the bean having the method that
    decides whether aggregation is complete or not.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`release-strategy-method`: This is the method having the logic to check for
    completeness of the message.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`correlation-strategy`: This is used to specify the bean having the method
    to correlate the messages.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`correlation-strategy-method`: This is the method having the actual logic to
    correlate the messages.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`message-store`: This is used to specify the message store, where messages
    are temporarily stored until they have been correlated and are ready to release.
    This can be in memory (which is default) or can be a persistence store. If a persistence
    store is configured, message delivery will be resumed across a server crash.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Java class can be defined as an aggregator and, as described in the previous
    bullet points, the `method` and `ref` parameters decide which method of bean (referred
    by `ref`) should be invoked when messages have been aggregated as per `CorrelationStrategy`
    and released after fulfilment of `ReleaseStrategy`. In the following example,
    we are just printing the messages before passing them on to the next consumer
    in the chain:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: Let's get to the details of the three most important components that complete
    the aggregator.
  prefs: []
  type: TYPE_NORMAL
- en: Correlation strategy
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Aggregator needs to group the messages—but how will it decide the groups? In
    simple words, `CorrelationStrategy` decides how to correlate the messages. The
    default is based on a header named `CORRELATION_ID`. All messages having the same
    value for the `CORRELATION_ID` header will be put in one bracket. Alternatively,
    we can designate any Java class and its method to define a custom correlation
    strategy or can extend Spring Integration framework''s `CorrelationStrategy` interface
    to define it. If the `CorrelationStrategy` interface is implemented, then the
    `getCorrelationKey()` method should be implemented. Let''s see our correlation
    strategy in the feeds example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: So how are we correlating our messages? We are correlating the feeds based on
    the category name. The method must return an object that can be used for correlating
    the messages. If a user-defined object is returned, it must satisfy the requirements
    for a key in a map such as defining `hashcode()` and `equals()`. The return value
    must not be null.
  prefs: []
  type: TYPE_NORMAL
- en: 'Alternatively, if we would have wanted to implement it by extending framework
    support, then it would have looked like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: Release strategy
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We have been grouping messages based on correlation strategy—but when will
    we release it for the next component? This is decided by the release strategy.
    Similar to the correlation strategy, any Java POJO can define the release strategy
    or we can extend framework support. Here is the example of using the Java POJO
    class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: The argument of a message must be of type collection and it must return a Boolean
    indication whether to release the accumulated messages or not. For simplicity,
    we have just checked for the number of messages from the same category—if it's
    greater than two, we release the messages.
  prefs: []
  type: TYPE_NORMAL
- en: Message store
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Until an aggregated message fulfils the release criteria, the aggregator needs
    to store them temporarily. This is where message stores come into the picture.
    Message stores can be of two types: in-memory and persistence store. Default is
    in memory, and if this is to be used, then there is no need to declare this attribute
    at all. If a persistent message store needs to be used, then it must be declared
    and its reference should be given to the `message-store` attribute. A mysql message
    store can be declared and referenced as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: Data source is Spring framework's standard JDBC data source. The greatest advantage
    of using persistence store is recoverability—if the system recovers from a crash,
    all in-memory aggregated messages will not be lost. Another advantage is capacity—memory
    is limited, which can accommodate a limited number of messages for aggregation,
    but the database can have a much bigger space.
  prefs: []
  type: TYPE_NORMAL
- en: Resequencers
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'A **resequencer** can be used to enforce an ordered delivery to the next subsystem.
    It will hold on to a message till all messages numbered before it have been delivered.
    For example, if messages have been numbered 1 to 10 and if the message numbered
    8 arrives sooner than the messages numbered 1 to 7, it will hold it in temporary
    storage and will be delivered only when the delivery of messages numbered 1 to
    7 is complete. The `SEQUENCE_NUMBER` header of the message is used by resequencer
    to track the sequences. It can be considered as a special case of aggregator,
    which holds on to the message based on a header value but does not do any processing
    on the messages:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: As we mentioned, resequencers can be considered as a special case of aggregators—almost
    all tags mean the same, except the namespace declaration.
  prefs: []
  type: TYPE_NORMAL
- en: Chaining handlers
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We have discussed quite a lot of handlers provided by Spring Integration as
    filters, transformers, service activators, and so on, which can be independently
    applied on to the message—Spring Integration further provides a mechanism to chain
    these handlers. A special implementation of `MessageHandler` is `MessageHandlerChain`,
    can be configured as a single message endpoint. It is a chain of other handlers,
    and a message received simply delegates it to the configured handlers in a predefined
    sequence. Let''s take an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: Let's quickly create a chain and validate it. Start with a filter, which just
    passes all the messages, add a header in the next step, and finally print the
    headers in the service activator. If we can confirm the existence of added headers
    in the second step, then we are fine—chain executed!
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Let's take a deep breath… This has been a long chapter and we covered many out-of-the-box
    components provided by the Spring Integration framework such as routers, filters,
    and splitters. These all helped with message flow across different endpoints.
    In the next chapter, we will continue exploring Spring Integration framework's
    out-of-the-box capabilities, but the focus will be more on adapters to interact
    with external systems such as connecting to a database, fetching tweets from Twitter,
    writing to a JMS queue, interacting with an FTP server, and many more—a lot of
    interesting stuff, stay tuned!
  prefs: []
  type: TYPE_NORMAL
