- en: Chapter 6. Integration with External Systems
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In the previous chapter, we discussed Spring Integration components that help
    with message flow inside systems. In this chapter, let''s pull the lever further
    and see what Spring Integration has in the box when it comes to real-world integration
    challenges. We will cover Spring Integration''s support for external components
    and we will cover the following topics in detail:'
  prefs: []
  type: TYPE_NORMAL
- en: Working with files
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: File exchange over FTP/FTPS
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Social integration
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Enterprise messaging
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Invoking and consuming HTTP endpoints
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Web services
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Database integration
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Streaming
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Working with files
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: One of the most common and primitive ways to communicate is through files. Even
    after the introduction of databases, the filesystem has not lost its relevance
    and we frequently need to deal with them—in legacy applications, for dumping reports,
    shared locations, and so on.
  prefs: []
  type: TYPE_NORMAL
- en: So, how do you work with files in Java? Get the file handle, open a stream,
    work over it, and then close it. Some trivial stuff would take 10-15 lines of
    code. However, what if you forget to close the stream or the referenced file has
    been removed? The lines of code go on increasing as we handle all the corner cases.
    Spring Integration has very good support for files. It provides adapters and gateways
    that can handle file reading and writing operations with minimal lines of code.
  prefs: []
  type: TYPE_NORMAL
- en: Prerequisites
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To use the file components mentioned previously, we need to declare the Spring
    namespace support and Maven entry in the following way:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Namespace support can be added by using the following code snippet:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Maven entry can be added by using the following code snippet:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'We are now good to start writing our Spring Integration file components. Let''s
    discuss file support from Spring based on the two types of operation: reading
    files and writing files.'
  prefs: []
  type: TYPE_NORMAL
- en: Reading files
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Spring Integration provides an adapter that can read a file from a directory
    and make it available as a `Message<File>` on a channel for other consumers to
    consume it. Let''s look at a snippet to see how it is configured:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding configuration is sufficient to read files from a *directory*
    and put it on the specified *channel*. Let''s look at the elements:'
  prefs: []
  type: TYPE_NORMAL
- en: '`int-file:inbound-channel-adapter`: This is the namespace for file support'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`directory`: This is the directory from where files should be read'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`channel`: This is the channel on which a file should be written'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`prevent-duplicates`: If this is enabled, files already picked up in an earlier
    run are not picked up again'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`filename-pattern`: This is the name pattern for the file that should be picked
    up'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`int:poller`: This is the rate at which files should be polled'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`int-file:nio-locker`: If there are multiple consumers, this will lock files
    so that the same files are not picked concurrently'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You must have realized that although the configuration is simple, a lot of things
    are going on under the hood, such as preventing duplicates, filtering files, avoiding
    concurrent access, and so on. We will discuss these in detail, but before that
    let's have a peek at the class that is acting behind the scene for this adapter.
  prefs: []
  type: TYPE_NORMAL
- en: Behind the scenes
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The adapter declared in the previous example leverages `FileReadingMessageSource`,
    which is an implementation of `MessageSource`. It creates a message based on a
    file from a directory as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: At bean declaration level, we can inject filters, locking mechanics, and so
    on—but since we are using Spring Integration, it spares us from working at bean
    declaration level. Instead, we can use adapters exposed by Spring Integration.
  prefs: []
  type: TYPE_NORMAL
- en: Filters
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Filter is a powerful concept that can be used to prevent duplicates, select
    files based on name patterns, customize the list of files read, and perform many
    more interceptions before the required content can be presented to the next endpoint.
    There are predefined filters available for most common tasks, but in the true
    spirit of spring, we can have custom implementations as well and inject them in
    adapters provided by Spring Integration. Filters must be an instance of `FileListFilter`,
    and the default filter used is `AcceptOnceFileListFilter`. This filter keeps track
    of processed files, but the implementation is in-memory. This means that if the
    server restarts when files are being processed, it will lose track of which files
    have been processed and will re-read the same files. To overcome this issue, an
    instance of `FileSystemPersistentAcceptOnceFileListFilter` should be used, which
    will keep track of processed files by leveraging the `MetadataStore` implementation.
  prefs: []
  type: TYPE_NORMAL
- en: 'Additionally, filename patterns and `Reg Ex` filters are available and can
    be used to filter files based on their names or by matching the name against the
    `Reg Ex` specified. Let''s see a quick example showing the use of these two filters:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s say we want a custom filter, it can easily be defined and used. The
    code is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: Preventing duplicates
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Preventing duplicates is a subset of filter that filters out files that have
    already been picked up. Using `prevent-duplicates`, we can instruct an adapter
    to look for unique files only. The only glitch here is that a duplicate check
    is limited to a session, as the reader does not store any state. If the reader
    restarts, it will read all the files again—even though they have been read earlier.
  prefs: []
  type: TYPE_NORMAL
- en: Concurrent access
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'This is a very common use case in enterprises with multiple consumers, and
    we want to maintain the sanity of the files consumed. We can use the `java.nio`
    locker in the following way to lock files to ensure that they are not accessed
    concurrently:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'This code does not restrict us to use only `java.nio.locker`. Instead of using
    the `java.nio` locker, we can provide custom lockers as well:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Unlocking is not explicit. It is performed by calling `FileLocker.unlock(File
    file)`; otherwise, it will result in memory leaks over the period.
  prefs: []
  type: TYPE_NORMAL
- en: Writing files
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Spring Integration provides outbound adapters, which are the opposite of inbound
    adapters. This means that it consumes a file from a channel and writes it to a
    directory. Internally, Spring Integration uses an instance of `FileWritingMessageHandler`
    to write messages to the filesystem, and an implementation of this class can be
    used. This class can deal with files, strings, or byte array payloads. As usual,
    there is no need to use the low-level classes; instead, adapter and gateway exposed
    by spring can be used. Let''s connect an outbound adapter to the channel on which
    the inbound adapter writes files:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s discuss what each element represents:'
  prefs: []
  type: TYPE_NORMAL
- en: '`int-file:outbound-channel-adapter`: This provides file namespace support for
    the outbound channel adapter'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`channel`: This is the channel where the files would be written as Spring Integration
    messages'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`directory`: This is the directory from which files are picked'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`delete-source-files`: If this is set to true, it will delete the files after
    processing them'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: While writing files, we need to consider things such as what should be the name
    of the new file, which directory should it be written in, what should be done
    with the original file, and so on. Let's quickly touch upon these aspects.
  prefs: []
  type: TYPE_NORMAL
- en: Naming the file
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: By default, the name of the file will be retained when it is written in the
    directory. However, this can be overridden by providing an implementation `FileNameGenerator`.
    This is the class responsible for generating the filenames—by default `FileNameGenerator`
    looks for a message header whose key matches the constant `FileHeaders.FILENAME`.
  prefs: []
  type: TYPE_NORMAL
- en: Target directory
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'There are primarily three ways to locate the target directory:'
  prefs: []
  type: TYPE_NORMAL
- en: Statically define a directory attribute that will direct each message to a fixed
    directory.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Define a directory-expression attribute that should be a valid **Spring Expression
    Language** (**SpEL**) expression. This expression is evaluated for each message
    and the message header can be used to dynamically specify the output file directory.
    The expression must resolve to a string or to `java.io.File`, and this must point
    to a valid directory.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The last option is the auto create directory. If the destination directory is
    missing, it will be created automatically, including its parent directory. This
    is the default behavior; to disable this, set the `auto-create-directory` attribute
    to `false`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Dealing with existing filenames
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'What if the file being written already exists? The correct route to take is
    using the `mode` attribute. One of following four options is available:'
  prefs: []
  type: TYPE_NORMAL
- en: '`REPLACE`: This is the default mode. If a file already exists, it will be simply
    overwritten.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`APPEND`: This will append the content of the incoming file to the existing
    one.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`FAIL`: If a duplicate is not expected, this mode should be used. This will
    throw `MessageHandlingException` if the file already exists.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`IGNORE`: If no action needs to be taken if the target file exists, this option
    should be used.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'So far, we have covered most of the aspects of the filesystem. However, what
    if we want to process the message after it has been written to the directory?
    Spring Integration provides an outbound gateway that can be handy here. Let''s
    have a look at this simple example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: The tags are the same as those for the output adapter; the difference is that
    it puts the files on the channel specified by `reply-channel` for further processing.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s write a simple service activator that will process these files:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: File transformers
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: File transformers are used to transform data read from a file to an object and
    vice versa. Spring Integration has provided a few common transformers such as
    file to byte, file to string, and so on, but we can always extend the framework
    interfaces to define more advanced and appropriate file transformers.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s complete this section with a quick discussion on some implicit file
    transformers provided by spring. Let''s start with this example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: As it's obvious from the preceding snippet, Spring Integration has provided
    implicit transformers for most common use cases as file to byte and file to string.
    Transformers are not restricted to these two cases—custom transformers can be
    defined by implementing the transformer interface or extending `AbstractFilePayloadTransformer`.
  prefs: []
  type: TYPE_NORMAL
- en: FTP/FTPS
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**FTP**, or **File Transfer Protocol**, is used to transfer files across networks.
    FTP communications consist of two parts: server and client. The client establishes
    a session with the server, after which it can download or upload files. Spring
    Integration provides components that act as a client and connect to the FTP server
    to communicate with it. What about the server—which server will it connect to?
    If you have access to any public or hosted FTP server, use it. Else, the easiest
    way for trying out the example in this section is to set up a local instance of
    the FTP server. FTP setup is out of the scope of this book.'
  prefs: []
  type: TYPE_NORMAL
- en: Prerequisites
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To use Spring Integration components for FTP/FTPS, we need to add a namespace
    to our configuration file and then add the Maven dependency entry in the `pom.xml`
    file. The following entries should be made:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Namespace support can be added by using the following code snippet:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Maven entry can be added by using the following code snippet:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Once namespace is available and the JAR has been downloaded, we are ready to
    use the components. As mentioned earlier, client components of Spring Integration
    need a session to establish with the FTP server. The details of the session is
    encapsulated in the session factory; let''s look at a sample session factory configuration:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'The `DefaultFtpSessionFactory` class is at work here`,` and it takes the following
    parameters:'
  prefs: []
  type: TYPE_NORMAL
- en: Host that is running the FTP server
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Port at which it's running the server
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Username
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Password for the server
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A session pool for the factory is maintained and an instance is returned when
    required. Spring takes care of validating that a stale session is never returned.
  prefs: []
  type: TYPE_NORMAL
- en: Downloading files from the FTP server
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Inbound adapters can be used to read the files from the server. The most important
    aspect is the session factory that we just discussed in the preceding section.
    The following code snippet configures an FTP inbound adapter that downloads a
    file from a remote directory and makes it available for processing:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s quickly go through the tags used in this code:'
  prefs: []
  type: TYPE_NORMAL
- en: '`int-ftp:inbound-channel-adapter`: This is the namespace support for the FTP
    inbound adapter.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`channel`: This is the channel on which the downloaded files will be put as
    a message.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`session-factory`: This is a factory instance that encapsulates details for
    connecting to a server.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`remote-directory`: This is the directory on the server where the adapter should
    listen for the new arrival of files.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`local-directory`: This is the local directory where the downloaded files should
    be dumped.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`auto-create-local-directory`: If enabled, this will create the local directory
    structure if it''s missing.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`delete-remote-files`: If enabled, this will delete the files on the remote
    directory after it has been downloaded successfully. This will help in avoiding
    duplicate processing.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`filename-pattern`: This can be used as a filter, but only files matching the
    specified pattern will be downloaded.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`local-filename-generator-expression`: This can be used to generate a local
    filename.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: An inbound adapter is a special listener that listens for events on the remote
    directory, for example, an event fired on the creation of a new file. At this
    point, it will initiate the file transfer. It creates a payload of type `Message<File>`
    and puts it on the output channel. By default, the filename is retained and a
    file with the same name as the remote file is created in the local directory.
    This can be overridden by using `local-filename-generator-expression`.
  prefs: []
  type: TYPE_NORMAL
- en: Incomplete files
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: On the remote server, there could be files that are still in the process of
    being written. Typically, there the extension is different, for example, `filename.actualext.writing`.
    The best way to avoid reading incomplete files is to use the filename pattern
    that will copy only those files that have been written completely.
  prefs: []
  type: TYPE_NORMAL
- en: Uploading files to the FTP server
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'Here is a brief description of the tags used:'
  prefs: []
  type: TYPE_NORMAL
- en: '`int-ftp:outbound-channel-adapter`: This is the namespace support for the FTP
    outbound adapter.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`channel`: This is the name of the channel whose payload will be written to
    the remote server.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`remote-directory`: This is the remote directory where files will be put. The
    user configured in the session factory must have appropriate permission.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`session-factory`: This encapsulates details for connecting to the FTP server.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`auto-create-directory`: If enabled, this will automatically create a remote
    directory if it''s missing, and the given user should have sufficient permission.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The payload on the channel need not necessarily be a file type; it can be one
    of the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '`java.io.File`: A Java file object'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`byte[]`: This is a byte array that represents the file contents'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`java.lang.String`: This is the text that represents the file contents'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Avoiding partially written files
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Files on the remote server must be made available only when they have been written
    completely and not when they are still partial. Spring uses a mechanism of writing
    the files to a temporary location and its availability is published only when
    it has been completely written. By default, the suffix is written, but it can
    be changed using the `temporary-file-`suffix property. This can be completely
    disabled by setting `use-temporary-file-name` to `false`.
  prefs: []
  type: TYPE_NORMAL
- en: FTP outbound gateway
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Gateway, by definition, is a two-way component: it accepts input and provides
    a result for further processing. So what is the input and output in the case of
    FTP? It issues commands to the FTP server and returns the result of the command.
    The following command will issue an `ls` command with the option `–l` to the server.
    The result is a list of string objects containing the filename of each file that
    will be put on the `reply-channel`. The code is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'The tags are pretty simple:'
  prefs: []
  type: TYPE_NORMAL
- en: '`int-ftp:outbound-gateway`: This is the namespace support for the FTP outbound
    gateway'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`session-factory`: This is the wrapper for details needed to connect to the
    FTP server'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`command`: This is the command to be issued'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`command-options`: This is the option for the command'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`reply-channel`: This is the response of the command that is put on this channel'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: FTPS support
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'For FTPS support, all that is needed is to change the factory class—an instance
    of `org.springframework.integration.ftp.session.DefaultFtpsSessionFactory` should
    be used. Note the `s` in `DefaultFtpsSessionFactory`. Once the session is created
    with this factory, it''s ready to communicate over a secure channel. Here is an
    example of a secure session factory configuration:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: Although it is obvious, I would remind you that the FTP server must be configured
    to support a secure connection and open the appropriate *port*.
  prefs: []
  type: TYPE_NORMAL
- en: Social integration
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Any application in today's context is incomplete if it does not provide support
    for social messaging. Spring Integration provides in-built support for many social
    interfaces such as e-mails, Twitter feeds, and so on. Let's discuss the implementation
    of Twitter in this section. Prior to Version 2.1, Spring Integration was dependent
    on the Twitter4J API for Twitter support, but now it leverages Spring's social
    module for Twitter integration. Spring Integration provides an interface for receiving
    and sending tweets as well as searching and publishing the search results in messages.
    Twitter uses `oauth` for authentication purposes. An app must be registered before
    we start Twitter development on it.
  prefs: []
  type: TYPE_NORMAL
- en: Prerequisites
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Let''s look at the steps that need to be completed before we can use a Twitter
    component in our Spring Integration example:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Twitter account setup:** A Twitter account is needed. Perform the following
    steps to get the keys that will allow the user to use Twitter using the API:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Visit [https://apps.twitter.com/](https://apps.twitter.com/).
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Sign in to your account.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Click on **Create New App**.![Prerequisites](img/00009.jpeg)
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Enter the details such as **Application name**, **Description**, **Website**,
    and so on. All fields are self-explanatory and appropriate help has also been
    provided. The value for the field **Website** need not be a valid one—put an arbitrary
    website name in the correct format.![Prerequisites](img/00010.jpeg)
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Click on the **Create your application** button. If the application is created
    successfully, a confirmation message will be shown and the **Application Management**
    page will appear, as shown here:![Prerequisites](img/00011.jpeg)
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Go to the **Keys and Access Tokens** tab and note the details for **Consumer
    Key (API Key)** and **Consumer Secret (API Secret)** under **Application Settings**,
    as shown in the following screenshot:![Prerequisites](img/00012.jpeg)
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: You need additional access tokens so that applications can use Twitter using
    APIs. Click on **Create my access token**; it takes a while to generate these
    tokens. Once it is generated, note down the value of **Access Token** and **Access
    Token Secret**.![Prerequisites](img/00013.jpeg)
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Go to the **Permissions** tab and provide permission to **Read, Write** **and
    Access direct messages**.![Prerequisites](img/00014.jpeg)
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: 'After performing all these steps, and with the required keys and access token,
    we are ready to use Twitter. Let''s store these in the `twitterauth.properties`
    property file:'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
- en: 'As I mentioned, the template encapsulates all the values. Here is the order
    of the arguments:'
  prefs: []
  type: TYPE_NORMAL
- en: '`apiKey`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`apiSecret`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`accessToken`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`accessTokenSecret`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'With all the setup in place, let''s now do some real work:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Namespace support can be added by using the following code snippet:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Maven entry can be added by using the following code snippet:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Receiving tweets
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The components in this code are covered in the following bullet points:'
  prefs: []
  type: TYPE_NORMAL
- en: '`int-twitter:inbound-channel-adapter`: This is the namespace support for Twitter''s
    inbound channel adapter.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`twitter-template`: This is the most important aspect. The Twitter template
    encapsulates which account to use to poll the Twitter site. The details given
    in the preceding code snippet are fake; it should be replaced with real connection
    parameters.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`channel`: Messages are dumped on this channel.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: These adapters are further used for other applications, such as for searching
    messages, retrieving direct messages, and retrieving tweets that mention your
    account, and so on. Let's have a quick look at the code snippets for these adapters.
    I will not go into detail for each one; they are almost similar to what have been
    discussed previously.
  prefs: []
  type: TYPE_NORMAL
- en: '**Search**: This adapter helps to search the tweets for the parameter configured
    in the query tag. The code is as follows:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '**Retrieving Direct Messages**: This adapter allows us to receive the direct
    message for the account in use (account configured in Twitter template). The code
    is as follows:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '**Retrieving Mention Messages**: This adapter allows us to receive messages
    that mention the configured account via the `@user` tag (account configured in
    the Twitter template). The code is as follows:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Sending tweets
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Twitter exposes outbound adapters to send messages. Here is a sample code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'Whatever message is put on the `twitterSendMessageChannel` channel is tweeted
    by this adapter. Similar to an inbound gateway, the outbound gateway provides
    support for sending direct messages. Here is a simple example of an outbound adapter:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'Any message that is put on the `twitterSendDirectMessage` channel is sent to
    the user directly. But where is the name of the user to whom the message will
    be sent? It is decided by a header in the message `TwitterHeaders.DM_TARGET_USER_ID`.
    This must be populated either programmatically, or by using enrichers or SpEL.
    For example, it can be programmatically added as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'Alternatively, it can be populated by using a header enricher, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: Twitter search outbound gateway
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'As gateways provide a two-way window, the search outbound gateway can be used
    to issue dynamic search commands and receive the results as a collection. If no
    result is found, the collection is empty. Let''s configure a search outbound gateway,
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'And here is what the tags covered in this code mean:'
  prefs: []
  type: TYPE_NORMAL
- en: '`int-twitter:search-outbound-gateway`: This is the namespace for the Twitter
    search outbound gateway'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`request-channel`: This is the channel that is used to send search requests
    to this gateway'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`twitter-template`: This is the Twitter template reference'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`search-args-expression`: This is used as arguments for the search'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`reply-channel`: This is the channel on which searched results are populated'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: This gives us enough to get started with the social integration aspects of the
    spring framework.
  prefs: []
  type: TYPE_NORMAL
- en: Enterprise messaging
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Enterprise landscape is incomplete without JMS—it is one of the most commonly
    used mediums of enterprise integration. Spring provides very good support for
    this. Spring Integration builds over that support and provides adapter and gateways
    to receive and consume messages from many middleware brokers such as ActiveMQ,
    RabbitMQ, Rediss, and so on.
  prefs: []
  type: TYPE_NORMAL
- en: Spring Integration provides inbound and outbound adapters to send and receive
    messages along with gateways that can be used in a request/reply scenario. Let's
    walk through these implementations in a little more detail. A basic understanding
    of the JMS mechanism and its concepts is expected. It is not possible to cover
    even the introduction of JMS here. Let's start with the prerequisites.
  prefs: []
  type: TYPE_NORMAL
- en: Prerequisites
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To use Spring Integration messaging components, namespaces, and relevant Maven
    the following dependency should be added:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Namespace support can be added by using the following code snippet:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Maven entry can be provided using the following code snippet:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'After adding these two dependencies, we are ready to use the components. But
    before we can use an adapter, we must configure an underlying message broker.
    Let''s configure ActiveMQ. Add the following in `pom.xml`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'After this, we are ready to create a connection factory and JMS queue that
    will be used by the adapters to communicate. First, create a session factory.
    As you will notice, this is wrapped in Spring''s `CachingConnectionFactory`, but
    the underlying provider is ActiveMQ:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s create a queue that can be used to retrieve and put messages:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: Now, we are ready to send and retrieve messages from the queue. Let's look into
    each message one by one.
  prefs: []
  type: TYPE_NORMAL
- en: Receiving messages – the inbound adapter
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Spring Integration provides two ways of receiving messages: polling and event
    listener. Both of them are based on the underlying Spring framework''s comprehensive
    support for JMS. `JmsTemplate` is used by the polling adapter, while `MessageListener`
    is used by the event-driven adapter. As the name suggests, a polling adapter keeps
    polling the queue for the arrival of new messages and puts the message on the
    configured channel if it finds one. On the other hand, in the case of the event-driven
    adapter, it''s the responsibility of the server to notify the configured adapter.'
  prefs: []
  type: TYPE_NORMAL
- en: The polling adapter
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Let''s start with a code sample:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'There is a poller element, so it''s obvious that it is a polling-based adapter.
    It can be configured in one of two ways: by providing a JMS template or using
    a connection factory along with a destination. I have used the latter approach.
    The preceding adapter has a polling queue mentioned in the destination and once
    it gets any message, it puts the message on the channel configured in the `channel`
    attribute.'
  prefs: []
  type: TYPE_NORMAL
- en: The event-driven adapter
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Similar to polling adapters, event-driven adapters also need a reference either
    to an implementation of the interface `AbstractMessageListenerContainer` or need
    a connection factory and destination. Again, I will use the latter approach. Here
    is a sample configuration:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: There is no poller sub-element here. As soon as a message arrives at its destination,
    the adapter is invoked, which puts it on the configured channel.
  prefs: []
  type: TYPE_NORMAL
- en: Sending messages – the outbound adapter
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Outbound adapters convert messages on the channel to JMS messages and put them
    on the configured queue. To convert Spring Integration messages to JMS messages,
    the outbound adapter uses `JmsSendingMessageHandler`. This is is an implementation
    of `MessageHandler`. Outbound adapters should be configured with either `JmsTemplate`
    or with a connection factory and destination queue. Keeping in sync with the preceding
    examples, we will take the latter approach, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: This adapter receives the Spring Integration message from `jmsChannel`, converts
    it to a JMS message, and puts it on the destination.
  prefs: []
  type: TYPE_NORMAL
- en: Gateway
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Gateway provides a request/reply behavior instead of a one-way send or receive.
    For example, after sending a message, we might expect a reply or we may want to
    send an acknowledgement after receiving a message.
  prefs: []
  type: TYPE_NORMAL
- en: The inbound gateway
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Inbound gateways provide an alternative to inbound adapters when request-reply
    capabilities are expected. An inbound gateway is an event-based implementation
    that listens for a message on the queue, converts it to Spring `Message`, and
    puts it on the channel. Here is a sample code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: 'However, this is what an inbound adapter does—even the configuration is similar,
    except the namespace. So, what is the difference? The difference lies in replying
    back to the reply destination. Once the message is put on the channel, it will
    be propagated down the line and at some stage a reply would be generated and sent
    back as an acknowledgement. The inbound gateway, on receiving this reply, will
    create a JMS message and put it back on the reply destination queue. Then, where
    is the reply destination? The reply destination is decided in one of the following
    ways:'
  prefs: []
  type: TYPE_NORMAL
- en: Original message has a property `JMSReplyTo`, if it's present it has the highest
    precedence.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The inbound gateway looks for a configured, default-reply-destination which
    can be configured either as a name or as a direct reference of a channel. For
    specifying channel as direct reference default-reply-destination tag should be
    used.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: An exception will be thrown by the gateway if it does not find either of the
    preceding two ways.
  prefs: []
  type: TYPE_NORMAL
- en: The outbound gateway
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Outbound gateways should be used in scenarios where a reply is expected for
    the send messages. Let''s start with an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: The preceding configuration will send messages to `request-destination`. When
    an acknowledgement is received, it can be fetched from the configured `reply-destination`.
    If `reply-destination` has not been configured, JMS `TemporaryQueues` will be
    created.
  prefs: []
  type: TYPE_NORMAL
- en: HTTP
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Spring Integration provides support to access external HTTP services as well
    as to expose HTTP services to an external application.
  prefs: []
  type: TYPE_NORMAL
- en: Prerequisites
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Let''s add a namespace and relevant Maven dependency so that Spring Integration''s
    HTTP components are available for use in our application:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Namepace support can be added using the following code snippet:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Maven entry can be added using the following code:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The HTTP inbound gateway
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Inbound gateways expose HTTP services to the external world, for example, REST-based
    web services. The application must be deployed in a web container such as Jetty
    or Tomcat for the inbound adapter or the gateway to work. The easiest way to implement
    the inbound component is by using Spring''s `HttpRequestHandlerServlet` class,
    and by defining it in the `web.xml` file. Here is a sample entry:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: 'Alternatively, we can use the spring MVC support. This is what we have used
    in our example; let''s take a look at the `web.xml` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: 'The `org.springframework.web.servlet.DispatcherServlet` class is a standard
    Spring MVC controller. Notice the configuration parameter, `http-inbound-config.xml`.
    This is the file that will have the declaration for the gateway:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: 'The components used in this code are explained in the following bullet points:'
  prefs: []
  type: TYPE_NORMAL
- en: '`int-http:inbound-gateway`: This is the namespace support for the HTML gateway'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`request-channel`: This will put the incoming request payload on the channel'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`path`: This is the path exposed for incoming requests'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`supported-methods`: This is a comma-separated list of supported methods that
    use the HTTP protocol'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'In the following code, the service activator listens for the payload on the
    input channel and modifies it before an inbound gateway sends a response:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: '`HttpMessageConverter` can be used to convert `HttpServletRequest` to `Messages`.
    A gateway element produces different instances depending on whether it has to
    return just a response (for example 200 success) or it has to return a response
    with a view. If the response is a view, it produces an instance of `HttpRequestHandlingController`.
    Otherwise, it produces an instance of `HandlingMessagingGateway`. To render the
    view, any view-rendering technology supported by Spring MVC can be used.'
  prefs: []
  type: TYPE_NORMAL
- en: 'For requests that just require a confirmation that the request was successful,
    an adapter can be used instead of the gateway:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: The HTTP outbound gateway
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The outbound gateway is used to invoke services published by external HTTP
    components. Let''s use our preceding example to test this. Create a war of the
    application that has inbound gateways and deploy it in a container. We can use
    the following example of an outbound gateway to invoke the HTTP request:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: 'The components used in this code are explained in the following bullet points:'
  prefs: []
  type: TYPE_NORMAL
- en: '`int-http:outbound-gateway`: This is the namespace support for the HTTP outbound
    gateway'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`channel`: Based on the message on this channel, it will try to hit the URL'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`url`: This is the external URL to which a request is made'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`http-method`: This specifies which HTTP methods should be used while making
    the request'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`expected-response-type`: This is the type of response expected (by default,
    it''s `String`)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Instead of gateway, adapters can also be used. The only difference is that
    an adapter does not send a response back on the reply channel. Under the hood,
    outbound adapters use the `RestTemplate` from the Spring framework. The following
    code snippet adds the outbound adapter:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: Web services
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The HTTP adapter and gateways provide support for REST-based web services, but
    Spring Integration also provides support for XML-based web services such as SOAP.
    An inbound adapter or gateway is used to create and expose an endpoint as a web
    service, while an outbound adapter or gateway is used to invoke external services.
    Spring Integration support for web services is built over the spring `ws` project.
    I am not going to cover spring `ws` or any specific SOAP details such as `wsdl`,
    header, body, or payload. Instead, we will showcase the Spring Integration wrappers.
  prefs: []
  type: TYPE_NORMAL
- en: Prerequisites
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Web services support can be added by including the following namespaces and
    Maven dependencies:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Namespace support can be added using the following code snippet:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Maven entry can be added using the following code:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The inbound gateway
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Inbound gateways will expose a SOAP service for handling an external request,
    which will then be converted to messages and posted to the channel. A front controller
    is required to intercept requests and pass them on the configured gateway; it
    is an instance of `org.springframework.ws.transport.http.MessageDispatcherServlet`.
    This should be configured in the `web.xml` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: 'An implementation of `org.springframework.ws.server.EndpointMapping` must be
    provided to do the mapping between servlet and an endpoint. This can be configured
    either in the Java configuration class or property file. Let''s put it in a property
    file and inject it as `contextConfigLocation`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: The `org.springframework.ws.server.endpoint.mapping.UriEndpointMapping` class
    performs servlet to `Message` mapping.
  prefs: []
  type: TYPE_NORMAL
- en: 'After that, we have the service activator that can change the response or do
    some operations on it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: The outbound gateway
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'This is even easier; the outbound gateway can take a URI and invoke the service,
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: 'In the preceding code, a valid SOAP payload should be put on the `request-channel`;
    this will be used by the gateway to invoke the service configured. The payload
    of the response is published on the `reply-channel`. Here is an example code snippet
    to invoke the preceding service:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: Database SQL
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: It's difficult to imagine enterprise applications without any database; it is
    one of the oldest and most commonly used bridging mechanisms. Spring Integration
    provides support to read from and write to the database. Again, this support is
    based on the Spring framework's foundation for database support. It provides inbound
    and outbound adapters, gateways, and even specific adapters for stored procedures.
    Let's have a look at some of these, and others can be used on the same pattern.
  prefs: []
  type: TYPE_NORMAL
- en: Prerequisites
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Before we talk about how to use database support of Spring Integration, let''s
    add the necessary namespaces and Maven dependencies:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Namespace support can be added using the following code snippet:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Maven entry can be added using the following code snippet:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Datasource
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Before we can start using the component, we need to define a datasource. Datasource
    is a wrapper that encapsulates database connection details. A sample datasource
    for an in-memory database H2 is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: 'For simplicity, I will use an in-memory database. But this is nothing specific
    to Spring Integration; datasource can be configured for any database supported
    by Spring. Include the following dependency in `pom.xml` for the in-memory database:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, we are ready with the datasource. Let''s initialize it with some test
    data; again, Spring provides easy-to-use components that can get our task done
    in a couple of lines of configuration:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs: []
  type: TYPE_PRE
- en: With the preceding configuration, we are now ready to explore the adapters,
    gateways, and other components provided by Spring.
  prefs: []
  type: TYPE_NORMAL
- en: Reading from the database – the inbound adapter
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The inbound adapter needs a reference to `JdbcTemplate` or datasource. We will
    stick to datasource. Its task is to read data from the database and put the result
    on the specified channel. By default, the message payload is the whole result
    set expressed as a list. The result set type can be changed by defining the `RowMapper`
    strategy, support for which is provided by spring:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE64]'
  prefs: []
  type: TYPE_PRE
- en: This configuration will connect to the database configured in the datasource.
    In our case, it's an in-memory database, that is, H2\. It will execute the query
    and issue an update. The result will be put on the configured channel. The update
    query is very handy when we want to filter out already processed records in the
    next polling cycle.
  prefs: []
  type: TYPE_NORMAL
- en: Transaction support
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Transaction support for the inbound adapter can be wrapped along with the poller:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE65]'
  prefs: []
  type: TYPE_PRE
- en: 'With transaction as a sub-element of poller, query and update will be executed
    in the same transaction. A valid transaction manager should be defined; again
    it''s nothing specific to Spring Integration. Instead, spring-based entity manager
    and transaction manager should be defined (again, this is nothing to do with Spring
    Integration; instead, it''s standard spring database support stuff). The code
    is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE66]'
  prefs: []
  type: TYPE_PRE
- en: Writing to the database – the outbound adapter
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The outbound adapter can be used to insert data in the database; it can use
    the message on the channel to construct the query and execute it. The following
    code will add the outbound adapter:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE67]'
  prefs: []
  type: TYPE_PRE
- en: This extracts a value from the payload and writes the data in the database.
    The database to which data will be written depends on the datasource.
  prefs: []
  type: TYPE_NORMAL
- en: Inbound and outbound gateways
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Gateways combine input and output adapter functionalities; it fires a query
    and posts the reply on the reply channel:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE68]'
  prefs: []
  type: TYPE_PRE
- en: Outbound gateways require a reference to the datasource that is used to decide
    the database to connect to.
  prefs: []
  type: TYPE_NORMAL
- en: Stream processing
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Spring Integration provides two implicit components for stream: one to read
    the streams and an other to write to streams. This section is small—let''s quickly
    get to the code!'
  prefs: []
  type: TYPE_NORMAL
- en: Prerequisites
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'First, let''s add the namespaces and Maven dependencies:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Namespace support can be added using the following code:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE69]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Maven dependencies can be added using the following code snippet:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE70]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: With the previous inclusion, we are ready to use the adapters.
  prefs: []
  type: TYPE_NORMAL
- en: Reading from a stream
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'There is a STDIN adapter provided by Spring Integration that reads from `stdin`.
    What is this `stdin`? Any stuff that is written to the command line, for example,
    `System.in` in Java. The following code snippet is used to add the STDIN adapter:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE71]'
  prefs: []
  type: TYPE_PRE
- en: Here, `int-stream:stdin-channel-adapter` is the namespace support and channel
    where the adapter puts the messages that have been written to the console.
  prefs: []
  type: TYPE_NORMAL
- en: 'If we want to get some insider view, spring uses either `ByteStreamReadingMessageSource`
    or `CharacterStreamReadingMessageSource`, which are implementations of `MessageSource`,
    to provide the adapter functionality. `ByteStreamReadingMessageSource` needs `InputStream`,
    while `CharacterStreamReadingMessageSource` needs `Reader`, as shown in the following
    code snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE72]'
  prefs: []
  type: TYPE_PRE
- en: Writing to a stream
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'A similar adapter for writing to the console is also provided by Spring: `stdout`.
    It prints to the console whatever message it gets on the channel. Let''s plug
    a `stdout` adapter to the preceding code and the output will be directed to the
    console:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE73]'
  prefs: []
  type: TYPE_PRE
- en: '`int-stream:stdout-channel-adapter` is the namespace, and channel is what the
    adapter will be polling for messages, and then print each on the console. `append-newline`
    will add a new line to output.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Behind the scenes, Spring uses either `ByteStreamWritingMessageHandler` or
    `CharacterStreamWritingMessageHandler`. They require a reference of `OutputStream`
    and `Writer`, respectively:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE74]'
  prefs: []
  type: TYPE_PRE
- en: This has been a long chapter and we all deserve a coffee break!
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This chapter showcased the simplicity and abstraction that Spring Integration
    provides when it comes to handling complicated integrations, be it file-based,
    HTTP, JMS, or any other integration mechanism. Do not panic; I promise that the
    next few chapters are going to be smaller, and we will cover the testability of
    Spring Integration, performance, management, and then wrap up with an end-to-end
    example. In the next chapter, we will cover how Spring Batch and Spring Integration
    can be integrated to leverage the best of each framework.
  prefs: []
  type: TYPE_NORMAL
