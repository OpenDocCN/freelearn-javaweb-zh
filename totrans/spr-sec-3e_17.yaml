- en: Microservice Security with OAuth 2 and JSON Web Tokens
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we will take a look at microservices-based architectures and
    look at how OAuth 2 with **JSON Web Tokens** (**JWT**) plays a role in securing
    microservices in a Spring-based application.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following is a list of topics that will be covered in this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: The general difference between monolithic applications and microservices
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Comparing **service-oriented architectures** (**SOA**) with microservices
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The conceptual architecture of OAuth 2 and how it provides your services with
    trustworthy client access
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Types of OAuth 2 access tokens
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Types of OAuth 2 grant types
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Examining JWT and their general structure
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Implementing a resource server and authentication server used to grant access
    rights to clients in order to access OAuth 2 resources
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Implementing a RESTful client to gain access to resources through an OAuth 2
    grant flow
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We have quite a few items to cover in this chapter, but before we dig into the
    details of how to start leveraging Spring Security to implement OAuth 2 and JWT,
    we first want to create a baseline of the calendar application that does not have
    Thymeleaf or any other browser-based user interface.
  prefs: []
  type: TYPE_NORMAL
- en: After removing all Thymeleaf configuration and resources, the various controllers
    have been converted to **JAX-RS REST** controllers.
  prefs: []
  type: TYPE_NORMAL
- en: You should start with the code from `chapter16.00-calendar`.
  prefs: []
  type: TYPE_NORMAL
- en: What are microservices?
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Microservices are an architectural approach that allows the development of physically
    separated modular applications which are autonomous, enabling agility, rapid development,
    continuous deployment, and scaling.
  prefs: []
  type: TYPE_NORMAL
- en: An application is built as a set of services, similar to SOA, such that services
    communicate through standard APIs, for example, JSON or XML, and this allows the
    aggregation of language-agnostic services. Basically, a service can be written
    in the best language for the task the service is being created for.
  prefs: []
  type: TYPE_NORMAL
- en: Each service runs in its own process and is location neutral, thus it can be
    located anywhere on the access network.
  prefs: []
  type: TYPE_NORMAL
- en: Monoliths
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The microservices approach is the opposite of the traditional monolithic software
    approach, which consists of tightly integrated modules that ship infrequently
    and have to scale as a single unit. Traditional Java EE applications and the JBCP
    calendar application in this book are examples of monolithic applications. Take
    a look at the following diagram which depicts the monolithic architecture:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/8a5ed567-edbf-45ad-bada-a2ee8e8d2dd0.png)'
  prefs: []
  type: TYPE_IMG
- en: Although the monolithic approach fits well for some organizations and some applications,
    microservices is becoming popular with companies that need more options for agility
    and scalability in their ecosystem.
  prefs: []
  type: TYPE_NORMAL
- en: Microservices
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'A microservice architecture is a collection of small discrete services where
    each service implements a specific business capability. These services run their
    own process and communicate via an HTTP API usually using a RESTful service approach.
    These services are created to serve only one specific business function, such
    as user management, administrative roles, an e-commerce cart, a search engine,
    social media integration, and many others. Take a look at the following diagram
    which depicts the microservices architecture:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/4d14f1d3-65aa-41c4-9de5-2117238b8db8.png)'
  prefs: []
  type: TYPE_IMG
- en: Each **s**ervice can be deployed, upgraded, scaled, restarted, and removed independently
    of other services in the application and other systems in the enterprise.
  prefs: []
  type: TYPE_NORMAL
- en: Because each service is created independently of the other, they can each be
    written in different programming languages and use different data storage. Centralized
    service management is virtually non-existent and these services use lightweight
    HTTP, REST, or Thrift APIs for communicating among themselves.
  prefs: []
  type: TYPE_NORMAL
- en: The **Apache Thrift** software framework can be downloaded from [https://thrift.apache.org](https://thrift.apache.org/).
    It is a framework for developing scalable cross-language services that combines
    a software stack with a code generation engine to build services that work efficiently
    and seamlessly between C++, Java, Python, PHP, Ruby, Erlang, Perl, Haskell, C#,
    Cocoa, JavaScript, Node.js, Smalltalk, and other languages.
  prefs: []
  type: TYPE_NORMAL
- en: Service-oriented architectures
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: You might be asking yourself, "Isn't this the same as SOA?" Not exactly, you
    could say microservices achieve what SOA promised in the first place.
  prefs: []
  type: TYPE_NORMAL
- en: An SOA is a style of software design where services are exposed to other components
    through a language-agnostic, communication protocol over a computer network.
  prefs: []
  type: TYPE_NORMAL
- en: The basic principle of SOA is to be independent of vendors, products, and technologies.
  prefs: []
  type: TYPE_NORMAL
- en: The definition of a service is a discrete unit of functionality that can be
    accessed remotely and acted upon and updated independently, such as retrieving
    a credit card statement online.
  prefs: []
  type: TYPE_NORMAL
- en: Although similar, SOA and microservices are still different types of architectures.
  prefs: []
  type: TYPE_NORMAL
- en: A typical SOA is often implemented inside deployment monoliths and is more platform
    driven, while microservices can be independently deployable and, therefore, offer
    more flexibility in all dimensions.
  prefs: []
  type: TYPE_NORMAL
- en: 'The key difference, of course, is the size; the word micro says it all. Microservices
    tend to be significantly smaller than regular SOA services. As Martin Fowler said:'
  prefs: []
  type: TYPE_NORMAL
- en: '"We should think about SOA as a superset of microservices."'
  prefs: []
  type: TYPE_NORMAL
- en: -Martin Fowler
  prefs: []
  type: TYPE_NORMAL
- en: Microservice security
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Microservices can provide great flexibility but also introduce challenges that
    must be addressed.
  prefs: []
  type: TYPE_NORMAL
- en: Service communication
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Monolithic applications use inâ€˜memory communication between processes, while
    microservices communicate over the network. The move to network communication
    raises issues of not only speed but also security.
  prefs: []
  type: TYPE_NORMAL
- en: Tight coupling
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Microservices use many datastores rather than a few. This creates the opportunity
    for implicit service contracts between microservices and services that are tightly
    coupled.
  prefs: []
  type: TYPE_NORMAL
- en: Technical complexity
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Microservices can create additional complexity, which can create security gaps.
    If the team does not have the correct experience, then managing these complexities
    can quickly become unmanageable.
  prefs: []
  type: TYPE_NORMAL
- en: The OAuth 2 specification
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: There is sometimes a misconception that OAuth 2 is an evolution from OAuth 1,
    but it is a completely different approach. OAuth1 specification requires signatures,
    so you would have to use cryptographic algorithms to create generate and validate
    those signatures that are no longer required for OAuth 2\. The OAuth 2 encryption
    is now handled by TLS, which is required.
  prefs: []
  type: TYPE_NORMAL
- en: '**OAuth 2** *RFC-6749*, *The OAuth 2.0 Authorization Framework* ([https://tools.ietf.org/html/rfc6749](https://tools.ietf.org/html/rfc6749)):'
  prefs: []
  type: TYPE_NORMAL
- en: '*The OAuth 2.0 authorization framework enables a third-party application to
    obtain limited access to an HTTP service, either on behalf of a resource owner
    by orchestrating an approval interaction between the resource owner and the HTTP
    service, or by allowing the third-party application to obtain access on its own
    behalf*.'
  prefs: []
  type: TYPE_NORMAL
- en: This specification replaces and makes obsolate the OAuth 1.0 protocol described
    in *RFC 5849, The OAuth 1.0 Protocol* ([https://tools.ietf.org/html/rfc5849).](https://tools.ietf.org/html/rfc5849)
  prefs: []
  type: TYPE_NORMAL
- en: 'To properly understand how to utilize OAuth 2, we need to identify certain
    roles and the collaboration between these roles. Let''s define each of the roles
    that are participating in the OAuth 2 authorization process:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Resource owner:** The resource owner is the entity capable of granting access
    to a protected resource that is located on a resource server'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Authorization server:** The authorization server is a centralized security
    gateway for issuing access tokens to the client after successfully authenticating
    the resource owner and obtaining authorization'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Resource server:** The resource server is the server hosting the protected
    resources and is capable of dissecting and responding to protected resource requests
    using the OAuth 2 access token'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Microservice client:** The client is the application making resource requests
    that are protected on behalf of the resource owner, but with their authorization'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Access tokens
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: An OAuth 2 access token, commonly referred to as `access_token` in code samples,
    represents a credential that can be used by a client to access an API.
  prefs: []
  type: TYPE_NORMAL
- en: Access token
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: An access token usually has a limited lifetime and is used to enable the client
    to access protected resources when including this token in the HTTP request header
    for each request.
  prefs: []
  type: TYPE_NORMAL
- en: Refresh token
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A refresh token has a longer lifetime and is used to get a new access token
    once the access token has expired, but without the need to send credentials to
    the server again.
  prefs: []
  type: TYPE_NORMAL
- en: Grant types
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Grant types are methods that a client can use to gain an access token that represents
    the permissions granted. There are different grant types that allow different
    types of access based on the needs of your application. Each grant type can support
    a different OAuth 2 flow without worrying about the technical aspects of the implementation.
  prefs: []
  type: TYPE_NORMAL
- en: Authorization code
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The authorization code grant type, defined in *RFC 6749*, *Section 4.1* ([https://tools.ietf.org/html/rfc6749](https://tools.ietf.org/html/rfc6749)),
    is a redirection-based flow where the browser receives an authorization code from
    anauthorization server and sends this to the client. The client will then interact
    with the authorization server and exchange the authorization code for `access_token`
    and, optionally, `id_token` and `refresh_token`. The client can now use this `access_token`
    to call the protected resource on behalf of the user.
  prefs: []
  type: TYPE_NORMAL
- en: Implicit
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The implicit grant type, defined in *RFC 6749*, *Section 4.1* ([https://tools.ietf.org/html/rfc6749](https://tools.ietf.org/html/rfc6749)),
    is similar to the authorization code grant type, but the client application receives
    `access_token` directly, without the need for `authorization_code`. This happens
    because the client application, which is usually a JavaScript application running
    within a browser and is less trusted than a client application running on the
    server, cannot be trusted with `client_secret` (which is required in the authorization
    code grant type). The implicit grant type does not send a refresh token to the
    application due to limited trust.
  prefs: []
  type: TYPE_NORMAL
- en: Password credentials
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The resource owner password grant type, defined in *RFC 6749*, *Section 4.3*
    ([https://tools.ietf.org/html/rfc6749](https://tools.ietf.org/html/rfc6749)),
    can be used directly as an authorization grant to obtain `access_token` and, optionally,
    `refresh_token`. This grant is used when there is a high degree of trust between
    the user and the client and when other authorization grant flows are not available.
    This grant type eliminates the need for the client to store the user credentials
    by exchanging the credentials with a long-lived `access_token` or `refresh_token`.
  prefs: []
  type: TYPE_NORMAL
- en: Client credentials
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The Client Credentials Grant's, defined in *RFC 6749*, *Section 4.4* ([https://tools.ietf.org/html/rfc6749#section-4.4](https://tools.ietf.org/html/rfc6749#section-4.4)),
    is for a non-interactive client (CLI), a daemon, or another service running. The
    client can directly ask the authorization server for `access_token` by using client-provided
    credentials (client id and client secret) to authenticate.
  prefs: []
  type: TYPE_NORMAL
- en: JSON Web Tokens
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: JWT is an open standard, *RFC 7519* ([https://tools.ietf.org/html/rfc7519](https://tools.ietf.org/html/rfc7519))
    that defines a compact and self-contained format for securely transmitting information
    between parties in the form of a JSON object. This information can be verified
    and trusted because it is digitally signed. JWTs can be signed using a secret
    (with the **hash-based message authentication code** (**HMAC**) **algorithm**)
    or a public/private key pair using the **Rivest-Shamir-Adleman** (**RSA**) encryption
    algorithm.
  prefs: []
  type: TYPE_NORMAL
- en: 'JWT *RFC- 7519* ([https://tools.ietf.org/html/ rfc7519](https://tools.ietf.org/html/%20rfc7519)):'
  prefs: []
  type: TYPE_NORMAL
- en: '*JSON Web Token (JWT) is a compact, URL-safe means of representing claims to
    be transferred between two parties. The claims in a JWT are encoded as a JSON
    object that is used as the payload of a JSON Web Signature (*JWS*) structure or
    as the plaintext of a JSON Web Encryption (JWE) structure, enabling the claims
    to be digitally signed or integrity protected with a Message Authentication Code
    (MAC) and/or encrypted.*'
  prefs: []
  type: TYPE_NORMAL
- en: JWT is used to carry information related to the identity and characteristics
    (claims) of the client bearing the token. JWT is a container and is signed by
    the server in order to avoid client tampering. This token is created during the
    authentication process and is verified by the authorization server before any
    processing. It is used by a resource server to allow a client to present a token
    representing its "identity card" to the resource server, and allows the resource
    server to verify the validity and integrity of the token in a stateless, secure
    manner.
  prefs: []
  type: TYPE_NORMAL
- en: Token structure
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The structure of a JWT adheres to the following three-part structure including
    a header, payload, and signature:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: Encoded JWT
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The following code snippet is the complete encoded `access_token` that is returned
    based on the client request:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: Header
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The encoded header for our `access_token` JWT is **base64** encoded, as shown
    in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'By decoding the encoded header, we have the following payload:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: Payload
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The encoded payload for our `access_token` JWT is base64 encoded, as shown
    here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'By decoding the encoded payload, we have the following payload claims:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: Signature
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The encoded payload for our `access_token` has been encoded with a private
    key by the authorization server, as seen in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'The following is pseudo code for the creation of a JWT signature:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: OAuth 2 support in Spring Security
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The Spring Security OAuth project provides support for using Spring Security
    with OAuth 2 authorization using the standard Spring Framework and Spring Security
    programming models and configuration idioms.
  prefs: []
  type: TYPE_NORMAL
- en: Resource owner
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The resource owner can be one or multiple sources, and in the context of the
    JBCP calendar, it is going to have the calendar application as the resource owner.
    The JBCP calendar will not have any specific configuration that is needed to denote
    its ownership aside from configuring the resource server.
  prefs: []
  type: TYPE_NORMAL
- en: Resource server
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The `@EnableResourceServer` annotation denotes the intention for the containing
    application to enable a Spring Security filter that authenticates requests via
    an incoming OAuth2 token:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'The `@EnableResourceServer` annotation denotes the intention for the containing
    application to enable an `OAuth2AuthenticationProcessingFilter` filter that authenticates
    requests via an incoming OAuth 2 token. The `OAuth2AuthenticationProcessingFilter`
    filter requires web security to be enabled using the `@EnableWebSecurity` annotation
    somewhere in the application. The `@EnableResourceServer` annotation registers
    a custom `WebSecurityConfigurerAdapter` class with a hardcoded `@Order` of `3`.
    It is currently not possible to change the order of this `WebSecurityConfigurerAdapter`
    class due to technical limitations in the Spring Framework. To deal with this
    limitation, it is advised not to use other security adapters with the order of
    `3`, and Spring Security will complain in the event that you do set one in the
    same order:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: Authorization server
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To enable the authorization server capability, we include the `@EnableAuthorizationServer`
    annotation in our configuration. The addition of this annotation will put an `o.s.s.OAuth
    2.provider.endpoint.AuthorizationEndpoint` interface and an `o.s.s.OAuth 2.provider.endpoint.TokenEndpoint`
    interface into context. The developer will be responsible for securing the `AuthorizationEndpoint`
    (/`oauth`/`authorize`) with the `@EnableWebSecurity` configuration. The `TokenEndpoint`
    (/`oauth`/`token`) will be automatically secured using HTTP basic authentication
    based on the OAuth 2 client credentials:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: RSA JWT access token converter keypair
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In order to create a secure JWT encoded signature, we will create a custom
    RSA `keystore` that we will use to create a custom `o.s.s.OAuth 2.provider.token.storeJwtAccessTokenConverter`
    interface:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: This will create a `PKCS12` certificate called `jwtConverterStore.p12`, which
    needs to be copied into the `./src/main/resources/key` directory.
  prefs: []
  type: TYPE_NORMAL
- en: OAuth 2 resource configuration properties
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We want to externalize the properties required to configure our JWT resources
    by providing `keyPair` attributes, including `keystore`, `alias`, and `storePassword`
    for our generated certificate, as you can see in our `application.yml` file, `src/main/resources/application.yml`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: OAuth 2 client configuration properties
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We need to configure the client details for the client authentication, grants,
    and OAuth 2 scopes, as you can see in the `application.yml` file, `src/main/resources/application.yml`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: JWT access token converter
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The final step for creating JWT tokens is creating a custom `JwtAccessTokenConverter`
    that will use the generated RSA certificate for our JWT signatures. To do this,
    we need to pull our keyPair configuration and configure a custom `JwtAccessTokenConverter`
    as seen in the OAuth2AuthorizationServerConfig.java file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: The UserDetailsService object
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We will use `CalendarUser` credentials to assign an authorized `GrantedAuthority`
    to the client. In order to do this, we must either configure our `CalendarUserDetailsService`
    class or qualify it with the name `userDetailsService`, as you can see in the
    following `CalendarUserDetailsService.java` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'Another alternative to defining a custom name for our `@Component` annotation
    is to define an `@Bean` declaration, which we can accomplish using the following
    entry in our `SecurityConfig.java` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: Running the OAuth 2 server application
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: At this point, we can start the application and we will be ready to send OAuth
    2 requests.
  prefs: []
  type: TYPE_NORMAL
- en: 'At this point, your code should look like this: `chapter16.01-calendar`.'
  prefs: []
  type: TYPE_NORMAL
- en: Server requests
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We can test the application with either a command-line tool such as `cURL` or
    `HTTPie`, or you could also use a REST client plugin such as Postman to send requests
    to the server.
  prefs: []
  type: TYPE_NORMAL
- en: '`HTTPie`: a CLI, cURL-like tool for humans, `HTTPie` (pronounced aitch-tee-tee-pie)
    is a command-line HTTP client. Its goal is to make CLI interaction with web services
    as human-friendly as possible. It provides a simple HTTP command that allows for
    sending arbitrary HTTP requests using a simple and natural syntax, and displays
    colorized output. `HTTPie` can be used for testing, debugging, and generally interacting
    with HTTP servers ([https://httpie.org](https://httpie.org/)).'
  prefs: []
  type: TYPE_NORMAL
- en: Token requests
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'When we make the initial token request, we should get a successful response
    similar to the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'Specifically, we have been granted an access token that can be used in subsequent
    requests. The following is the `access_token` that will be used as our bearer:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'Now we will take the `access_token` and use that token to initiate additional
    requests to the server with the following format:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'When adding the `access_token` we received in the first request, we should
    get the following request:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'We can continue to make subsequent requests with the same `access_token`, such
    as retrieving the events for the current user:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: Now that we have our OAuth 2 server ready to issue `access_tokens` for clients,
    we now can create a microservices client to interact with our system.
  prefs: []
  type: TYPE_NORMAL
- en: Microservices client
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We start our new client application by enabling this application as an OAuth
    2 client with the addition of the `@EnableOAuth2Client` annotation. The addition
    of the `@EnableOAuth2Client` annotation will allow this application to retrieve
    and use authorization code grants from one or more OAuth2 authorization server.
    Client applications that use client credential grants do not need `AccessTokenRequest`
    or the scoped `RestOperations` (the state is global for the applications), but
    they should still use the filter to trigger `OAuth2RestOperations` to obtain a
    token when necessary. Applications that use password grants need to set the authentication
    properties in `OAuth2ProtectedResourceDetails` before using the `RestOperations`
    method, which we will configure shortly. Let''s take a look at the following steps
    and see how it is done:'
  prefs: []
  type: TYPE_NORMAL
- en: 'We need to set up a few properties that will be used to configure the client,
    as shown in the following `JavaConfig.java` file:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'In addition to several standard properties we need to execute the OAuth 2 RESTful
    operations, we also need to create a `dataSource` to hold `oauth_client_token`
    that will be retrieved upon the initial request, then used in subsequent operations
    for a given resource. Now let''s create `ClientTokenServices` for managing `oauth_client_token`,
    as shown in the following `JavaConfig.java` file:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'Now we create the `OAuth2RestTemplate` that will manage the OAuth2 communication.
    We will start by creating a `ResourceOwnerPasswordResourceDetails` to hold the
    resource connection details, then construct an `OAuth2RestTemplate` to be used
    as an `OAuth2RestOperations` for the client request:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: Configuring the OAuth 2 client
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Now that we have enabled our `@EnableOAuth2Client` annotation and set up a
    `ResourceOwnerPasswordResourceDetails` object, we need to configure the properties
    used to connect to the resource server and authentication server:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'We now have the pieces in place and can start making requests with the `OAuth2RestOperations`
    object. We will start by creating `RestController` to pull remote details and
    display them as a result of RESTful requests, as shown in our `OAuth2EnabledEventsController.java`
    file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: We now should have the same codebase for a client application.
  prefs: []
  type: TYPE_NORMAL
- en: Your code should look like `chapter16.01-calendar-client`.
  prefs: []
  type: TYPE_NORMAL
- en: 'We need to ensure that the `chapter16.01-calendar` application is running and
    ready to take OAuth 2 requests from clients. We can then start the `chapter16.01-calendar-client`
    application, which will expose several RESTful endpoints, including one to access
    the configured user events located at `/events/my` on the remote resource, and
    will return the following result by running `http://localhost:8888/events/my`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, you learned the general difference between monolithic applications
    and microservices and compared SOA with microservices. You also learned the conceptual
    architecture of OAuth 2 and how it provides your services with trustworthy client
    access, and learned about the types of OAuth 2 access tokens and the types of
    OAuth 2 grant types.
  prefs: []
  type: TYPE_NORMAL
- en: We examined the JWT and their general structure, implemented a resource server
    and authentication server used to grant access rights to clients in order to access
    OAuth 2 resources, and implemented a RESTful client to gain access to resources
    through an OAuth 2 grant flow.
  prefs: []
  type: TYPE_NORMAL
