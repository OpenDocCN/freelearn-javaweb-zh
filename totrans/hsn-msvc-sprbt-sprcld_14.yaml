- en: Centralized Configuration
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we will learn how to use the Spring Cloud Configuration server
    to centralize managing the configuration of our microservices. As already described
    in [Chapter 1](282e7b49-42b8-4649-af81-b4b6830d391d.xhtml), *Introduction to Microservices*,
    in the *Central configuration* section, an increasing number of microservices
    typically come with an increasing number of configuration files that need to be
    managed and updated.
  prefs: []
  type: TYPE_NORMAL
- en: With the Spring Cloud Configuration server, we can place the configuration files
    for all our microservices in a central configuration repository that will make
    it much easier to handle them. Our microservices will be updated to retrieve their
    configuration from the configuration server at startup.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following topics will be covered in this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: Introduction to the Spring Cloud Configuration server
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Setting up a config server
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Configuring clients of a config server
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Structuring the configuration repository
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Trying out the Spring Cloud Configuration server
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: All the commands described in this book are run on a MacBook Pro using macOS
    Mojave but should be straightforward enough to modify in order to be able to run
    on another platform such as Linux or Windows.
  prefs: []
  type: TYPE_NORMAL
- en: No new tools need to be installed in this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: The source code for this chapter can be found on GitHub at [https://github.com/PacktPublishing/Hands-On-Microservices-with-Spring-Boot-and-Spring-Cloud/tree/master/Chapter12](https://github.com/PacktPublishing/Hands-On-Microservices-with-Spring-Boot-and-Spring-Cloud/tree/master/Chapter12).
  prefs: []
  type: TYPE_NORMAL
- en: 'To be able to run the commands as described in the book, download the source
    code to a folder and set up an environment variable, `$BOOK_HOME`, that points
    to that folder. Sample commands include the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: The Java source code is written for Java 8 and tested on Java 12\. This chapter
    uses Spring Cloud 2.1.0, SR1 (also known as the **Greenwich** release), Spring
    Boot 2.1.4, and Spring 5.1.6, that is, the latest available versions of the Spring
    components at the time of writing this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: The base Docker image, `openjdk:12.0.2`, is used in all Dockerfiles.
  prefs: []
  type: TYPE_NORMAL
- en: 'The source code contains the following Gradle projects:'
  prefs: []
  type: TYPE_NORMAL
- en: '`api`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`util`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`microservices/product-service`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`microservices/review-service`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`microservices/recommendation-service`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`microservices/product-composite-service`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`spring-cloud/eureka-server`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`spring-cloud/gateway`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`spring-cloud/authorization-server`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`spring-cloud/config-server`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: All source code examples in this chapter come from the source code in `$BOOK_HOME/Chapter12`,
    but are, in several cases, edited to remove non-relevant parts of the source code,
    such as comments, import statements, and log statements.
  prefs: []
  type: TYPE_NORMAL
- en: If you want to see the changes applied to the source code in [Chapter 12](a250774a-03a1-41b1-b935-cbeb9624b6e3.xhtml),
    *Centralized Configuration*, that is, see what it took to add a configuration
    server, you can compare that with the source code for [Chapter 11](bcb9bba0-d2fe-4ee8-954b-07a7e38e1115.xhtml),
    *Securing Access to APIs*. You can use your favorite `diff` tool and compare the
    two folders, `$BOOK_HOME/Chapter11` and `$BOOK_HOME/Chapter12`.
  prefs: []
  type: TYPE_NORMAL
- en: Introduction to the Spring Cloud Configuration server
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The Spring Cloud Configuration server (shortened to *config server*) will be
    added to the existing microservice landscape behind the edge server in [Chapter
    10](a3383211-405d-4319-b142-ddb8cf3674fd.xhtml), *Using Spring Cloud Gateway to
    Hide Microservices Behind an Edge Server*, in the same way as for the other microservices:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/f1a6d8fa-dd07-47dd-9f4d-3861729c6a70.png)'
  prefs: []
  type: TYPE_IMG
- en: 'When it comes to setting up a config server, there are a number of options
    to consider:'
  prefs: []
  type: TYPE_NORMAL
- en: Selecting a storage type for the configuration repository
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Deciding on the initial client connection, either to the config server or to
    the discovery server
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Securing the configuration, both against unauthorized access to the API and
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: avoiding storing sensitive information in plain text in the configuration repository
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Let's go through each option one by one and also introduce the API exposed by
    the config server.
  prefs: []
  type: TYPE_NORMAL
- en: Selecting the storage type of the configuration repository
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'As already described in [Chapter 8](9878a36a-5760-41a4-a132-1a2387b61037.xhtml),
    *Introduction to Spring Cloud*, in the *Spring Cloud Config for centralized configuration*
    section, the config server supports storing configuration files in a number of
    different backends, for example:'
  prefs: []
  type: TYPE_NORMAL
- en: Git repository
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Local filesystem
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: HashiCorp Vault
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A JDBC database
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In this chapter, we will use a local filesystem. To use the local filesystem,
    the config server needs to be launched with the Spring profile, `native`, enabled.
    The location of the configuration repository is specified using the property,
    `spring.cloud.config.server.native.searchLocations`.
  prefs: []
  type: TYPE_NORMAL
- en: Deciding on the initial client connection
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: By default, a client connects first to the config server to retrieve its configuration.
    Based on the configuration, it connects to the discovery server, that is, Netflix
    Eureka in our case, to register itself. It is also possible to do this the other
    way around, that is, the client first connects to the discovery server to find
    a config server instance and then connects to the config server to get its configuration.
    There are pros and cons to both approaches.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, the clients will first connect to the config server. With this
    approach, it will be possible to store the configuration of the discovery server,
    that is, Netflix Eureka, in the config server.
  prefs: []
  type: TYPE_NORMAL
- en: To learn more about the other alternative, see [https://cloud.spring.io/spring-cloud-static/spring-cloud-config/2.1.0.RELEASE/single/spring-cloud-config.html#discovery-first-bootstrap](https://cloud.spring.io/spring-cloud-static/spring-cloud-config/2.1.0.RELEASE/single/spring-cloud-config.html#_environment_repository).
  prefs: []
  type: TYPE_NORMAL
- en: One concern with connecting to the config server first is that the config server can
    become a single point of failure. If the clients connect first to a discovery
    service, such as Netflix Eureka, there can be multiple config server instances
    registered, so that a single point of failure can be avoided. When, later on in
    this book, we learn about the *service* concept in Kubernetes, we will see how
    we can avoid a single point of failure by running multiple containers, for example,
    config servers, behind each Kubernetes service.
  prefs: []
  type: TYPE_NORMAL
- en: Securing the configuration
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Configuration information will, in general, be handled as sensitive information.
    This means that we need to secure the configuration information both in transit
    and at rest. From a runtime perspective, the config server does not need to be
    exposed to the outside through the edge server. During development, it is, however,
    useful to be able to access the API of the config server to check the configuration.
    In production environments, it is recommended to lock down external access to
    the config server.
  prefs: []
  type: TYPE_NORMAL
- en: Securing the configuration in transit
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When the configuration information is asked for by a microservice, or anyone
    using the API of the config server, it will be protected against eavesdropping
    by the edge server since it already uses HTTPS.
  prefs: []
  type: TYPE_NORMAL
- en: To ensure that the API user is a known client, we will use HTTP basic authentication.
    We can set up HTTP basic authentication by using Spring Security in the config
    server and specifying the environment variables, `SPRING_SECURITY_USER_NAME` and
    `SPRING_SECURITY_USER_PASSWORD`, with the permitted credentials.
  prefs: []
  type: TYPE_NORMAL
- en: Securing the configuration at rest
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: To avoid a situation whereby anyone with access to the configuration repository
    can steal sensitive information, such as passwords, the config server supports
    encryption of configuration information when stored on disk. The config server
    supports using both symmetric and asymmetric keys. Asymmetric keys are more secure
    but harder to manage.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we will use a symmetric key. The symmetric key is given to
    the config server at startup by specifying an environment variable, `ENCRYPT_KEY`.
    The encrypted key is just a plain text string that needs to be protected in the
    same way as any sensitive information.
  prefs: []
  type: TYPE_NORMAL
- en: To learn more about the use of asymmetric keys, see [https://cloud.spring.io/spring-cloud-static/spring-cloud-config/2.1.0.RELEASE/single/spring-cloud-config.html#_key_management](https://cloud.spring.io/spring-cloud-static/spring-cloud-config/2.1.0.RELEASE/single/spring-cloud-config.html#_key_management).
  prefs: []
  type: TYPE_NORMAL
- en: Introducing the config server API
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The config server exposes a REST API that can be used by its clients to retrieve
    their configuration. In this chapter, we will use the following endpoints in the
    API:'
  prefs: []
  type: TYPE_NORMAL
- en: '`/actuator`: The standard actuator endpoints exposed by all microservices.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: As always, these should be used with care. They are very useful during development
    but must be locked down before being used in production.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '`/encrypt` and `/decrypt`: Endpoints for encrypting and decrypting sensitive
    information. These must also be locked down before being used in production.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`/{microservice}/{profile}`: Returns the configuration for the specified microservice
    and the specified Spring profile.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We will see some sample uses for the APIs when we try out the config server.
  prefs: []
  type: TYPE_NORMAL
- en: Setting up a config server
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Setting up a config server on the basis of the decisions discussed is straightforward:'
  prefs: []
  type: TYPE_NORMAL
- en: Create a Spring Boot project using Spring Initializr as described in [Chapter
    3](d26f4e61-20bf-4f55-b96d-060c7dd6f20c.xhtml), *Creating a Set of Cooperating
    Microservices*. Refer to the *Using Spring Initializr to generate skeleton* *code*
    section.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Add the dependencies, `spring-cloud-config-server` and `spring-boot-starter-security`,
    to the Gradle build file, `build.gradle`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Add the annotation, `@EnableConfigServer`, to the application class, `ConfigServerApplication`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'Add the configuration for the config server to the default property file, `application.yml`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: The most important configuration is to specify where to find the configuration
    repository, specified by the `spring.cloud.config.server.native.searchLocations` property.
  prefs: []
  type: TYPE_NORMAL
- en: Add a routing rule to the edge server to make the API of the config server accessible
    from outside the microservice landscape.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Add a Dockerfile and a definition of the config server to the three Docker Compose
    files.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Externalize sensitive configuration parameters to the standard Docker Compose
    environment file, `.env`
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Add the config server to the common build file, `settings.gradle`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: The source code for the Spring Cloud Configuration server can be found in `$BOOK_HOME/Chapter12/spring-cloud/config-server`.
  prefs: []
  type: TYPE_NORMAL
- en: Now, let's look a bit more into how to set up the routing rule and how to configure
    the config server for use in Docker.
  prefs: []
  type: TYPE_NORMAL
- en: Setting up a routing rule in the edge server
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To be able to access the API of the config server from outside the microservice
    landscape, we add a routing rule to the edge server. All requests to the edge
    server that begin with `/config` will be routed to the config server with the
    following routing rule:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: The `RewritePath` filter in the preceding routing rule will remove the leading
    part, `/config`, from the incoming URL before it sends it to the config server.
  prefs: []
  type: TYPE_NORMAL
- en: 'With this routing rule in place, we can use the API of the config server; for
    example, run the following command to ask for the configuration of the product
    service when it uses the Docker Spring profile:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: We will run the preceding command when we try out the config server.
  prefs: []
  type: TYPE_NORMAL
- en: Configuring the config server for use with Docker
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The Dockerfile of the config server looks the same as for the other microservices,
    except for the fact that it exposes port `8888` instead of port `8080`.
  prefs: []
  type: TYPE_NORMAL
- en: 'When it comes to adding the config server to the Docker Compose files, it looks
    a bit different from what we have seen for the other microservices:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'Here are the explanations for the preceding source code:'
  prefs: []
  type: TYPE_NORMAL
- en: The Spring profile, `native`, is added to signal to the config server that the
    config repository is based on plain files; in other words, it is not a Git repository.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The environment variable `ENCRYPT_KEY` is used to specify the symmetric encryption
    key that shall be used by the config server to encrypt and decrypt sensitive configuration
    information.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The environment variables, `SPRING_SECURITY_USER_NAME` and `SPRING_SECURITY_USER_PASSWORD`,
    are used to specify the credentials to be used for protecting the APIs using basic
    HTTP authentication.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The volume declaration will make the `config-repo` folder accessible in the
    Docker container at `/config-repo`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The values of the three preceding environment variables defined are fetched
    by Docker Compose from the `.env` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: The information stored in the `.env` file, that is, the username, password,
    and encryption key, is sensitive information and must be protected if used for
    something other than development and testing. Also, note that losing the encryption
    key will lead to a situation whereby the encrypted information in the config repository
    cannot be decrypted!
  prefs: []
  type: TYPE_NORMAL
- en: Configuring clients of a config server
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To be able to get their configurations from the config server, our microservices
    need to be updated. This can be done through the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Add the `spring-cloud-starter-config`, and `spring-retry` dependencies to the
    Gradle build file, `build.gradle`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Move the configuration file, `application.yml`, to the config repository and
    rename it to the name of the client as specified by the property, `spring.application.name`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Add a file named `bootstrap.yml` to the `src/main/resources` folder. This file
    holds the configuration required to connect to the config server. Refer to the
    following for an explanation of its content.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Add credentials for accessing the config server to the Docker Compose files,
    for example, the `product` service:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'Disable the use of the config server when running Spring Boot-based automated
    tests. This is done by adding `spring.cloud.config.enabled=false` to the `@DataMongoTest`, `@DataJpaTest`,
    and `@SpringBootTest` annotations.  For example, execute the following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: Configuring connection information
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'As mentioned previously, the `src/main/resources/bootstrap.yml` file holds
    the client configuration that is required in order to be able to connect to the
    config server. This file has the same content for all clients of the config server,
    except for the application name as specified by the property called, `spring.application.name` (in
    the following example, set to `product`):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'This configuration will make the client do the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Connect to the config server using the `http://localhost:8888` URL when it runs
    outside Docker, and using the `http://config-server:8888` URL when running in
    a Docker container.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Use HTTP basic authentication using the value of the `CONFIG_SERVER_USR` and
    `CONFIG_SERVER_PWD` properties, as its username and password.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Try to reconnect to the config server during startup up to 20 times, if required.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If the connection attempt fails, the client will initially wait for 3 seconds
    before trying to reconnect.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The wait time for subsequent retries will increase by a factor of 1.3.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The maximum wait time between connection attempts will be 10 seconds.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If the client can't connect to the config server after 20 attempts, its startup
    will fail.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: This configuration is generally good for resilience against temporary connectivity
    problems with the config server. It is especially useful when the whole landscape
    of microservices and its config server are started up at once, for example, when
    using the `docker-compose up` command. In this scenario, many of the clients will
    be trying to connect to the config server before it is ready, and the retry logic
    will make the clients connect to the config server successfully once it is up
    and running.
  prefs: []
  type: TYPE_NORMAL
- en: Moving the partitioning configuration from Docker Compose files to the configuration
    repository
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The Docker Compose files, `docker-compose-partitions.yml`, and `docker-compose-kafka.yml`,
    contain some extra configuration for handling partitions in the message brokers,
    RabbitMQ and Kafka. For details, refer to the *Guaranteed order and partitions* section
    in [Chapter 7](436fb8c1-0c4d-410c-a3ec-da251aba4ca1.xhtml), *Developing Reactive
    Microservices*. This configuration has also been moved to the centralized configuration
    repository.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, in `docker-compose-kafka.yml`, the configuration for the product
    consumer that reads messages from the first partition in the product topic in
    Kafka appears as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'This configuration has been structured into a number of Spring profiles for
    increased reusability and moved to the corresponding configuration files in the
    configuration repository. The Spring profiles added are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '`streaming_partitioned` contains properties for enabling the use of partitions
    in a message broker.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`streaming_instance_0` contains properties required for consuming messages
    from the first partition.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`streaming_instance_1` contains properties required for consuming messages
    from the second partition.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`kafka` contains properties that are specific for the use of Kafka as the messaging
    broker.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The following configuration has been added to the configuration files of the
    message consumers, that is, the product, review, and recommendation services:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'The following configuration has been added to the configuration file of the
    message producer, that is, the product-composite service:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'The Docker Compose files are now cleaner and only contain the configuration
    of credentials for accessing the configurations server and a list of Spring profiles
    to activate. For example, the configuration for the product consumer that read
    messages from the first partition in the product topic in Kafka is now reduced
    to the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'For the full source code, refer to the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '`docker-compose-partitions.yml`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`docker-compose-kafka.yml`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`config-repo/product-composite.yml`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`config-repo/product.yml`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`config-repo/recommendation.yml`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`config-repo/review.yml`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Structuring the configuration repository
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'After moving the configuration files from each client to the configuration
    repository, we will have some level of consistent configuration in many of the
    configuration files, for example, for the configuration of actuator endpoints
    and how to connect to Eureka, RabbitMQ, and Kafka. The common parts have been
    placed in a configuration file named `application.yml` that is shared by all clients.
    The configuration repository contains the following files:'
  prefs: []
  type: TYPE_NORMAL
- en: '`application.yml`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`eureka-server.yml`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`product-composite.yml`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`recommendation.yml`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`auth-server.yml`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`gateway.yml`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`product.yml`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`review.yml`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The configuration repository can be found in `$BOOK_HOME/Chapter12/config-repo`.
  prefs: []
  type: TYPE_NORMAL
- en: Trying out the Spring Cloud Configuration server
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Now it is time to try out the config server:'
  prefs: []
  type: TYPE_NORMAL
- en: First, we build from source and run the test script to ensure that everything
    fits together.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Next, we will try out the config server API to retrieve the configuration for
    our microservices.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Finally, we will see how we can encrypt and decrypt sensitive information, for
    example, passwords.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Building and running automated tests
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'So now we build and run, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: 'First, build the Docker images with the following commands:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, start the system landscape in Docker and run the usual tests with the
    following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: Getting the configuration using the config server API
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'As already described previously, we can reach the API of the config server
    through the edge server by using the URL prefix, `/config`. We also have to supply
    credentials as specified in the `.env` file for HTTP basic authentication. For
    example, to retrieve the configuration used for the product service when it runs
    as a Docker container, that is, having activated the Spring profile `docker`,
    run the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'Expect a response with the following structure (many of the properties in the
    response are replaced by `...` to increase readability):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'The explanations for the preceding response are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: 'The response contains properties from a number of *property sources*, one per
    the Spring profile and property file that matched the API request. The property
    sources are returned in priority order; that is, if a property is specified in
    multiple property sources, the first property in the response takes precedence.
    The preceding sample response contains the following property sources:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`/config-repo/product.yml`, for the `docker` Spring profile'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`/config-repo/application.yml`, for the `docker` Spring profile'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`/config-repo/product.yml`, for the `default` Spring profile'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`/config-repo/application.yml`, for the `default` Spring profile docker'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'For example, the port used will be `8080` and not `7001`, since `"server.port":
    8080` is specified before `"server.port": 7001` in the preceding response.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Sensitive information, such as the passwords to Eureka and RabbitMQ, are returned
    in plain text, for example, `"p"` and `"guest"`, but they are encrypted on disk.
    In the configuration file, `application.yml`, they are specified as follows:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: Encrypting and decrypting sensitive information
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Information can be encrypted and decrypted using the `/encrypt`, and `/decrypt`
    endpoints exposed by the config server. The `/encrpyt` endpoint can be used to
    create encrypted values to be placed in the property file in the config repository.
    Refer to the preceding example where the passwords to Eureka and RabbitMQ are
    stored encrypted on disk. The `/decrypt` endpoint can be used to verify encrypted
    information that is stored on disk in the config repository.
  prefs: []
  type: TYPE_NORMAL
- en: 'To encrypt the `hello world` string, run the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: It is important to use the `--data-urlencode` flag when using `curl` to call
    the `/encrypt` endpoint, so as to ensure the correct handling of special characters
    such as `'+'`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Expect a response along the lines of the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/733638b7-6ddf-4111-b1b8-9ea27d16f42e.png)'
  prefs: []
  type: TYPE_IMG
- en: 'To decrypt the encrypted value, run the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'Expect the `hello world` string as the response:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/db7066ec-de99-4008-91ad-a347b02ff206.png)'
  prefs: []
  type: TYPE_IMG
- en: 'If you want to use an encrypted value in a configuration file, you need to
    prefix it with `{cipher}` and wrap it in `''''`. For example, to store the encrypted
    version of `hello world`, execute the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'These tests conclude the chapter on centralized configuration. Wrap it up by
    shutting down the system landscape:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we have seen how we can use the Spring Cloud Configuration
    server to centralize managing the configuration of our microservices. We can place
    the configuration files in a common configuration repository and share common
    configurations in a single configuration file while keeping microservice-specific
    configuration in microservice specific configuration files. The microservices
    have been updated to retrieve their configuration from the config server at startup
    and are configured to handle temporary outages while retrieving their configuration
    from the config server.
  prefs: []
  type: TYPE_NORMAL
- en: The config server can protect configuration information by requiring authenticated
    usage of its API with basic HTTP authentication, and can prevent eavesdropping
    by exposing its API externally through the edge server that uses HTTPS. To prevent
    intruders who obtained access to the configuration files on disk from gaining
    access to sensitive information such as passwords, we can use the config server
    `/encrypt` endpoint to encrypt the information and store it encrypted on disk.
  prefs: []
  type: TYPE_NORMAL
- en: While exposing the APIs from the config server externally is useful during development,
    they should be locked down before use in production.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will learn how we can use *Resilience4j* to mitigate
    the potential drawbacks of overusing synchronous communication between microservices.
    If we, for example, establish chains of microservices that call each other synchronously
    using REST APIs, and the last microservice stops responding, bad things can happen
    that affect many of the microservices involved. Resilience4j comes with an implementation
    of the circuit breaker pattern, which can be used to handle these types of problem.
  prefs: []
  type: TYPE_NORMAL
- en: Questions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'What API call can we expect from a review service to the config server during
    startup to retrieve its configuration? The review service was started up using
    the following command: `docker compose up -d`.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'What configuration information should we expect back from an API call to the
    config server using this command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: What types of repository backend does Spring Cloud Config support?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How can we encrypt sensitive information on disk using Spring Cloud Config?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How can we protect the config server API from misuse?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Mention some pros and cons for clients that first connect to the config server
    as opposed to those that first connect to the discovery server.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
