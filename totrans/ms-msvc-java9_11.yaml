- en: Migrating a Monolithic Application to Microservice-Based Application
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We are at the last chapter of this book and I hope you have enjoyed and mastered
    the full stack (except DB) microservice development. I have tried to touch upon
    all necessary topics that will give you a complete view of a microservice-based
    production application and allow you to move forward with more exploration. Since
    you have learned about microservice architecture and design, you can easily differentiate
    between a monolithic application and a microservice-based application, and you
    can identify what work one needs to do to migrate a monolithic application to
    a microservice-based application.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we'll talk about refactoring a monolithic application to a
    microservice based application. I assume an existing monolithic application is
    already deployed and being used by customers. At the end of this chapter, you'll
    learn about the different approaches and strategies one can use to make monolithic
    migration to microservice easier.
  prefs: []
  type: TYPE_NORMAL
- en: 'This chapter covers the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Do you need to migrate?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Approaches and keys for successful migration
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Do you need to migrate?
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This is the first question that should set the tone for your migration. Do you
    really need to migrate your existing application to a microservice-based architecture?
    What benefits does it bring to the table? What are the consequences? How we can
    support the existing on-premise customers? Would existing customers support and
    bear the cost of migration to microservices? Do I need to write the code from
    scratch? How would the data be migrated to a new microservice-based system? What
    would be the timeline to this migration? Is existing team proficient enough to
    bring this change fast? Could we accept the new functional changes during this
    migration? Does our process in line to accommodate migration? So on and so forth.
    I believe there would be plenty of similar questions that come to your mind. I
    hope that, from all of the previous chapters, that you might have gained good
    knowledge of the work a microservice-based system requires.
  prefs: []
  type: TYPE_NORMAL
- en: After all of the pros and cons, your team would decide the migration. If the
    answer is yes, this chapter will help you on the way forward to migration.
  prefs: []
  type: TYPE_NORMAL
- en: Cloud versus on-premise versus both cloud and on-premise
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: What is your existing offering to a cloud solution, an on-premise solution,
    or do you offer both cloud and on-premise solutions or do you want to start cloud
    offering along with on-premise solution. Your approach would be based on the kind
    of solution you offer.
  prefs: []
  type: TYPE_NORMAL
- en: Cloud only solution
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: If you offer cloud solutions, then your migration task is easier than the other
    two solutions. Having said that, it does not mean it would be a cake walk. You
    would have full control over migration. You have the liberty of not considering
    the direct impact of migration on customers. Cloud customers simply use the solution
    and are not bothered how it has been implemented or hosted. I assume that there
    is no API or SDK change, and obviously, migration should not involve any functional
    change. Microservice migration only on the cloud has the edge of using smooth
    incremental migration. This means that you would first transform the UI application,
    then one API/service, and then the next, so on and so forth. Mind you, you are
    in control.
  prefs: []
  type: TYPE_NORMAL
- en: On-premise only solution
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: On-premise solutions are deployed on customer infrastructure. On top of that,
    you might have many clients with different versions deployed on their infrastructure.
    You don't have full control of these deployments. You need to work with customers
    and a team effort is required for successful migration.
  prefs: []
  type: TYPE_NORMAL
- en: Also, before you approach a customer, you should have the full flesh migration
    solution ready. Having different versions of your product makes this extra difficult.
    I would recommend offering migration only of the latest version and while you
    developed migration, only security and break fixes should be allowed for customers.
    Yes, you should not offer new functionality at all.
  prefs: []
  type: TYPE_NORMAL
- en: Both cloud and on-premise solution
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: If your application has both cloud and on-premise offering, then migration of
    on-premise solution to microservices could be in synchronization with the cloud
    or vice versa. This means that if you spent efforts on migrating one, you can
    replicate the same on the other. Therefore, it includes challenges mentioned earlier
    for either cloud or on-premise migration with addition to replication on other
    environments. Also, sometimes on-premise customers may have their own customization.
    It also needs to be taken care of while migrating. Here, your own cloud solution
    should be migrated first to microservices, which can be replicated on on-premises
    later.
  prefs: []
  type: TYPE_NORMAL
- en: Migrating a production/solution offering only on-premise deployment, but you
    want of start cloud deployments also; this is most challenging. You are supposed
    to migrate your existing code as per my microservice design, while making sure
    it also supports existing on-premise deployments. Sometimes, it could be a legacy
    technology stack, or even existing code might have been written using some own
    proprietary technology like protocols. It could be that the existing design is
    not flexible enough to break into microservices. This type of migration offers
    the most challenges. An incremental migration of on-premise solution to microservices
    should be done, where you can first separate the UI applications and offer external
    APIs that interact with UI applications. If APIs are already in place or your
    application is already divided into separate UI applications, believe me, it removes
    tons of baggage from migration. Then, you can focus on migrating the server-side
    code, including the APIs developed for UI applications. You might ask why we can't
    migrate all UI applications, APIs, and server code together. Yes, you can. But,
    doing an incremental migration would give you surety, confidence, and quick failures/learning.
    After all, Agile development is all about incremental development.
  prefs: []
  type: TYPE_NORMAL
- en: If your existing code is not modular or contains lots of legacy code, then I
    would advise you to first refactor it and make it modular. It would make your
    task easier. Having said that, it should be done module by module. Break and refactor
    whatever code you can before migrating it to pure microservices.
  prefs: []
  type: TYPE_NORMAL
- en: We'll discuss a few approaches that might help you to refactor a large complex
    monolithic application into microservices.
  prefs: []
  type: TYPE_NORMAL
- en: Approaches and keys to successful migration
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Software modernization has been done for many years. A lot of work is done to
    perform successful software modernization. You will find it useful to go through
    all of the best practices and principles for successful software modernization
    (migration). In this chapter, we will talk specifically about software modernization
    of the microservice architecture.
  prefs: []
  type: TYPE_NORMAL
- en: Incremental migration
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: You should transform monolithic applications to microservices in an incremental
    manner. You should not start the full-fledged migration of the whole code all
    together. It entangles the risk-reward ratio and increases the probability of
    failure. It also increases the probability of transition time and, hence, cost.
    You may want to break your code into different modules and then start transforming
    each of the modules one by one. It is quite likely that you may want to rewrite
    a few modules from scratch, which should be done if the existing code is tightly
    coupled and too complex to refactor. But, writing the complete solution from scratch
    is a big no. You should avoid it. It increases the cost, time to migration, and
    the probability of failures.
  prefs: []
  type: TYPE_NORMAL
- en: Process automation and tools setup
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Agile methodologies work hand in hand with microservices. You can use any Agile
    processes, such as Scrum and Kanban with modern development processes, such as
    test-driven development or peer programing, for incremental development. Process
    automation is a must for microservice-based environments. You should have automated
    CI/CD and test automation in place. If containerization of deliverables is not
    yet done with the CI/CD pipeline, then you should do it. It enables successful
    integration of newly developed microservices with the existing system or other
    new microservices.
  prefs: []
  type: TYPE_NORMAL
- en: You would want to set up the service discovery, service gateway, configuration
    server, or any event-based system in parallel or prior to the start of your first
    microservice transformation.
  prefs: []
  type: TYPE_NORMAL
- en: Pilot project
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Another problem I have observed in microservice migration is starting development
    with different modules altogether. Ideally, a small team should perform the pilot
    project to transform any of the existing modules to microservices. Once it is
    successful, the same approach can be replicated to other modules. If you start
    the migration of various modules simultaneously, then you may repeat the same
    mistake in all microservices. It increases the risk of failures and the duration
    of transformation.
  prefs: []
  type: TYPE_NORMAL
- en: A team that performs successful migration offers the way to developed modules
    and its integration with existing monolithic applications successfully. If you
    successfully developed and transformed each module into a microservice one by
    one, at some point in time, you would have a microservice-based application instead
    of a monolithic application.
  prefs: []
  type: TYPE_NORMAL
- en: Standalone user interface applications
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: If you already have standalone user interface applications that consume APIs,
    then you are already steps away from a successful migration. If this is not the
    case, it should be the first step to separate your user interface from the server
    code. UI applications would consume the APIs. If the existing application does
    not have the APIs that should be consumed by the UI applications, then you should
    write the wrapper APIs on top of the existing code.
  prefs: []
  type: TYPE_NORMAL
- en: 'Take a look at the following diagram that reflects the presentation layer before
    the migration of UI applications:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/59d116bf-c7db-4216-9203-33f56b466a98.png)'
  prefs: []
  type: TYPE_IMG
- en: Before UI Applications migration
  prefs: []
  type: TYPE_NORMAL
- en: 'The following diagram reflects the presentation layer after the migration of
    UI applications:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/56cc418e-1d2e-4987-be74-eb62894213fc.png)'
  prefs: []
  type: TYPE_IMG
- en: After UI applications Migration
  prefs: []
  type: TYPE_NORMAL
- en: You can see that earlier, the UI was included inside the monolithic application
    along with business logic and DAO. After migration, the UI application is separated
    from the monolithic application and consumes the APIs for communicating with the
    server code. REST is standard for implementing the APIs that can be written on
    top of existing code.
  prefs: []
  type: TYPE_NORMAL
- en: Migrating modules to microservices
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now, you have one server-side monolithic application and one or more UI applications.
    It gives you another advantage of consuming the APIs while separating the modules
    from existing monolithic applications. For example, after separation of UI applications,
    you might transform one of the modules to a microservice. Once the UI applications
    are successfully tested, API calls related with this module can be routed to the
    newly transformed module instead of the existing monolithic API. As shown in next
    diagram, when the API `GET/customer/1` is called, the web `Gateway` can route
    the request to the `Customer Microservice` instead of the `Monolithic` application.
  prefs: []
  type: TYPE_NORMAL
- en: You can also perform the testing on production before making the new microservice-based
    API live by comparing the response from both monolithic and microservice modules.
    Once we have consistently matching responses, we can be sure that the transformation
    is done successfully and API calls can be migrated to the refactored module API.
    As shown in the following figure, a component is deployed that makes another call
    to a new customer microservice whenever a customer API is called. Then, it compares
    the responses of both of the calls and stores the results. These results can be
    analyzed and a fix should be delivered for any inconsistency. When a response
    from a newly transformed microservice matches with the existing monolithic responses,
    you can stop routing the calls to existing monolithic applications and replace
    it with new microservice.
  prefs: []
  type: TYPE_NORMAL
- en: Following this approach allows you to migrate modules one by one to a microservice,
    and at one point in time, you can migrate all monolithic modules to microservices.
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/237764f3-242b-43bc-8fb1-33eac8744c1c.png)'
  prefs: []
  type: TYPE_IMG
- en: API routing, comparison, and migration
  prefs: []
  type: TYPE_NORMAL
- en: How to accommodate a new functionality during migration
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A new functionality should be avoided in ideal scenarios during migration. Only
    important fixes and security changes should be allowed. However, if there is an
    urgency to implement a new functionality, then it should be developed either in
    a separate microservice or in a modular way to existing monolithic code that makes
    its separation from existing code easier.
  prefs: []
  type: TYPE_NORMAL
- en: For example, if you really need a new feature in the `customer` module that
    does not have any dependency on other modules, you can simply create a new customer
    microservice and use it for specific API calls, either by external world or through
    other modules. It is up to you whether you use REST calls or events for inter-process
    communication.
  prefs: []
  type: TYPE_NORMAL
- en: Similarly, if you need a new functionality that has dependency on other modules
    (for example, a new customer functionality having a dependency on booking) and
    it is not exposed as an API to a UI or service API, then it can still be developed
    as a separate microservice, as shown in the following diagram. The `customer`
    module calls a newly developed microservice and then it calls the `booking` module
    for request processing and provides the response back to the `customer` module.
    Here, for inter-process communication, REST or events could be used.
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/2acbdfb7-53ea-4a58-8739-5c945ff95560.png)'
  prefs: []
  type: TYPE_IMG
- en: Implementing a new module as a microservice that calls another module
  prefs: []
  type: TYPE_NORMAL
- en: References
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Read the following books for more information on code refactoring and domain-driven
    design:'
  prefs: []
  type: TYPE_NORMAL
- en: '*Refactoring: Improving the Design of Existing Code* by Martin Fowler'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Domain-Driven Design* by Eric J. Evans'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Software modernization is the way to move forward and in the current environment
    since everything is moved to the cloud and the way resource power and capacity
    is increased, microservices based on design look more appropriate than anything
    else. We discussed a combination of cloud and on-premise solutions and the challenges
    of transforming those into microservices.
  prefs: []
  type: TYPE_NORMAL
- en: We also discussed why an incremental development approach is preferred as far
    as monolithic application migration to microservices is concerned. We talked about
    various approaches and practices that are required for successful migration to
    microservices.
  prefs: []
  type: TYPE_NORMAL
