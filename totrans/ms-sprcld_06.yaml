- en: Communication Between Microservices
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the last two chapters, we discussed details related to very important elements
    in microservice architecture—service discovery and the configuration server. However,
    it is worth remembering that the main reason for their existence in the system
    is just to help in the management of the whole set of independent, standalone
    applications. One aspect of this management is communication between microservices.
    Here, a particularly important role is played by service discovery, which is responsible
    for storing and serving the network locations of all available applications. Of
    course, we may imagine our system architecture without a service discovery server.
    Such an example will also be presented in this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: However, the most important components taking part in an inter-service communication
    are HTTP clients and client-side load balancers. In this chapter, we are going
    to focus just on them.
  prefs: []
  type: TYPE_NORMAL
- en: 'The topics we will cover in this chapter include:'
  prefs: []
  type: TYPE_NORMAL
- en: Using Spring `RestTemplate` for inter-service communication with and without
    service discovery
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Customizing the Ribbon client
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Description of the main features provided by the Feign client, such as integration
    with the Ribbon client, service discovery, inheritance, and zoning support
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Different styles of communication
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We can identify different styles of communication between microservices. It
    is possible to classify them into two dimensions. The first of them is a division
    into synchronous and asynchronous communication protocols. The key point of asynchronous
    communication is that the client should not have blocked a thread while waiting
    for a response. The most popular protocol for that type of communication is AMQP,
    and we already had the opportunity to run an example of that protocol usage at
    the end of the previous chapter. However, the main way of communication between
    services is still synchronous HTTP protocol. We will be only talking about it
    in this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: The second division is into different communication types based on whether there
    is a single message receiver or multiple receivers. In one-to-one communication,
    each request is processed by exactly one service instance. In one-to-many communication,
    each request may be processed by many different services. This will be discussed
    in [Chapter 11](554c4049-1dc9-430d-8fe7-19f3b9ac99a3.xhtml), *Message Driven Microservices*.
  prefs: []
  type: TYPE_NORMAL
- en: Synchronous communication with Spring Cloud
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Spring Cloud provides a set of components to help you in implementing communication
    between microservices. The first of them is `RestTemplate`, which is always used
    for consuming RESTful web services by a client. It is included in a Spring Web
    project. To use it effectively in a microservices environment, it should be annotated
    with the `@LoadBalanced` qualifier. Thanks to that, it will be automatically configured
    to use Netflix Ribbon and it will be able to take an advantage of service discovery
    by using service names instead of IP addresses. Ribbon is a client-side load balancer,
    which provides a simple interface allowing control over the behavior of HTTP and
    TCP clients. It can be easily integrated with other Spring Cloud components, such
    as service discovery or circuit breaker, and, furthermore, it is fully transparent
    to a developer. The next available component is Feign, a declarative REST client
    also from the Netflix OSS stack. Feign already uses Ribbon for load balancing
    and fetching data from service discovery. It may be easily declared on the interface
    by annotating a method with `@FeignClient`. In this chapter, we will take a closer
    look at all the components listed here.
  prefs: []
  type: TYPE_NORMAL
- en: Load balancing with Ribbon
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The main concept around Ribbon is a named **client**. That's why we may call
    other services using their names instead of the full address with hostname and
    port, without connecting to a service discovery. In that case, the list of addresses
    should be provided in the Ribbon configuration settings inside the `application.yml`
    file.
  prefs: []
  type: TYPE_NORMAL
- en: Enabling communication between microservices using the Ribbon client
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s proceed with the example. It consists of four independent microservices.
    Some of them may call endpoints exposed by the others. The application source
    code is available here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://github.com/piomin/sample-spring-cloud-comm.git](https://github.com/piomin/sample-spring-cloud-comm.git).'
  prefs: []
  type: TYPE_NORMAL
- en: 'In this example, we will try to develop a simple order system where customers
    may buy products. If a customer decides to confirm a selected list of products
    to buy, the `POST` request is sent to the `order-service`. It is processed by
    the `Order prepare(@RequestBody Order order) {...}` method inside REST controller.
    This method is responsible for order preparation. First, it calculates the final
    price, considering the price of each product from the list, customer order history,
    and their category in the system by calling the proper API method from the `customer-service`.
    Then, it verifies the customer''s account balance is high enough to execute the
    order by calling the account service, and, finally, it returns the calculated
    price. If the customer confirms the action, the `PUT /{id}` method is called.
    The request is processed by the method `Order accept(@PathVariable Long id) {...}`
    inside REST controller. It changes the order status and withdraws money from the
    customer''s account. The system architecture is broken down into the individual
    microservices as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/5c7304e2-7612-4327-94a6-eaaaec6c0fd5.png)'
  prefs: []
  type: TYPE_IMG
- en: Static load balancing configuration
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Our `order-service` has to communicate with all other microservices from the
    example to perform the required operations. So, we need to define three different
    Ribbon clients with network addresses set using the `ribbon.listOfServers` property.
    The second important thing in the example is to disable discovery services in
    Eureka, which are enabled by default. Here are all the defined properties for
    `order-service` inside its `application.yml` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'We should include the following dependencies in the project to use `RestTemplate`
    in conjunction with the Ribbon client:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, we should enable the Ribbon client by declaring a list of the names configured
    in `application.yml`. To achieve this, you may annotate the main class or any
    other Spring configuration class with `@RibbonClients`. You should also register
    the `RestTemplate` bean and annotate it with `@LoadBalanced` to enable interaction
    with Spring Cloud components:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: Calling other services
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Finally, we may begin to implement the `OrderController` responsible for serving
    HTTP methods exposed outside a microservice. It has the `RestTemplate` bean injected
    to be able to call other HTTP endpoints. You may see in the following source code
    fragment that uses the Ribbon client name configured in `application.yml` instead
    of IP address or hostname. Using the same `RestTemplate` bean, we can communicate
    with three different microservices. Let's just take a second here to discuss the
    methods available inside the controller. In the first of the implemented methods,
    we call the `GET` endpoint from `product-service`, which returns a list with details
    of selected products. Then, we invoke the `GET /withAccounts/{id}` method exposed
    by `customer-service`. It returns the customer details with the list of their
    accounts.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, we have all the information needed to calculate the final order price
    and validate the customer has sufficient funds in their main account. The `PUT`
    method calls the endpoint from `account-service` to withdraw money from the customer
    account. I have spent quite a bit of time discussing methods available in `OrderController`.
    However, I think that it was needed because the same example will be used to show
    the main features of Spring Cloud components that provide mechanisms for synchronous
    communication between microservices:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'It is interesting to note that the `GET /withAccounts/{id}` method from `customer-service`,
    which is called by `order-service`, also uses the Ribbon client to communicate
    with another microservice, `account-service`. Here''s the fragment from `CustomerController`
    with the implementation of the preceding method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'First, build the whole project with the Maven command `mvn clean install`.
    Then, you may launch all the microservices in any order using the `java -jar`
    command without any additional parameters. Optionally, you can run the application
    from your IDE. The test data is prepared for every microservice on startup. There
    is no persistence storage, so all objects will be removed after a restart. We
    can test the whole system by calling the `POST` method exposed by `order-service`.
    The example request is shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'If you try to send this request, you will able to see the following logs printed
    by the Ribbon client:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: The approach described in this section has one big disadvantage, which makes
    it not very usable in a system composed of several microservices. The problem
    is more severe if you have auto-scaling. It is easy to see that all the network
    addresses of services have be managed manually. Of course, we may move the configuration
    settings from the `application.yml` file inside every fat JAR to the configuration
    server. However, it does not change the fact that management of a large number
    of interactions will still be troublesome. Such a problem would be easily solved
    by the ability for the client-side load balancer and service discovery to interact.
  prefs: []
  type: TYPE_NORMAL
- en: Using RestTemplate together with service discovery
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In fact, an integration with service discovery is the default behavior of the
    Ribbon client. As you probably remember, we disabled Eureka for the client-side
    balancer by setting the `ribbon.eureka.enabled` property to `false`. The existence
    of service discovery simplifies a configuration of Spring Cloud components during
    inter-service communication, examples in this section.
  prefs: []
  type: TYPE_NORMAL
- en: Building example application
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The system architecture is the same as for the previous example. To view the
    source code for the current exercise, you have to switch to the `ribbon_with_discovery`
    branch ([https://github.com/piomin/shown here-spring-cloud-comm/tree/ribbon_with_discovery](https://github.com/piomin/sample-spring-cloud-comm/tree/ribbon_with_discovery)). The
    first thing you will see there is a new module, `discovery-service`. We have discussed
    in detail almost all aspects related to Eureka in [Chapter 4](b016b615-1eed-457a-9b9c-66ba07c9ce9e.xhtml),
    *Service Discovery*, so you should not have any problems with launching it. We
    run a single standalone Eureka server with really basic settings. It is available
    on the default port, `8761`.
  prefs: []
  type: TYPE_NORMAL
- en: 'In comparison with the previous example, we should remove all the configuration
    and annotations strictly related to the Ribbon client. In their place, the Eureka
    discovery client has to be enabled with `@EnableDiscoveryClient` and the Eureka
    server address is provided in the `application.yml` file. Now, the main class
    of `order-service` looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'Here''s the current configuration file. I set the name of the service with
    the `spring.application.name` property:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'This is the same as earlier; we also launch all microservices. But, this time
    `account-service` and `product-service` will be multiplied by two instances. When
    starting a second instance of each service, the default server port may be overridden
    with the `-DPORT` or `-Dserver.port` parameter, for example, `java -jar -DPORT=9093
    product-service-1.0-SNAPSHOT.jar`. All the instances have been registered in the
    Eureka server. This can be easily checked out using its UI dashboard:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/deb2c9a7-afca-421d-993c-84c3189fed0c.png)'
  prefs: []
  type: TYPE_IMG
- en: 'This is the first time in this book we have seen a practical example of load
    balancing. By default, the Ribbon client distributes traffic equally among all
    the registered instances of the microservice. That algorithm is called **round
    robin**. In practice, it means that the client remembers where it forwarded the
    last request and then sends the current request to the service next in the row.
    This approach may be overridden by the other rule I''m going to show you in detail
    in the next chapter. Load balancing may also be configured for the previous example
    without service discovery, by setting a comma-separated list of service addresses
    in `ribbon.listOfServers`, for example, `ribbon.listOfServers=localhost:8093,localhost:9093`.
    Getting back to the example application, the requests sent by `order-service`
    will be load balanced between two instances of `account-service` and `product-service`.
    This looks similar to `customer-service`, which distributes traffic between two
    instances of `account-service`. If you launch all the instances of the service
    visible on the Eureka dashboard in the previous screenshot and send some test
    requests to `order-service`, you will certainly see the following log which I
    have posted. I have highlighted the fragment where the Ribbon client displays
    a list of addresses found for the target service:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: Using Feign client
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '`RestTemplate` is a Spring component specially adapted to interact with Spring
    Cloud and microservices. However, Netflix has developed their own tool that acts
    as a web service client for providing out-of-the-box communication between independent
    REST services. Feign client, which is in it, generally does the same as `RestTemplate`
    with the `@LoadBalanced` annotation, but in a more elegant way. It is a Java to
    HTTP client binder that works by processing annotations into a templatized request.
    When using Open Feign client, you only have to create an interface and annotate
    it. It integrates with Ribbon and Eureka to provide a load balanced HTTP client,
    fetching all the necessary network addresses from service discovery. Spring Cloud
    adds support for Spring MVC annotations and for using the same HTTP message converters
    as in Spring Web.'
  prefs: []
  type: TYPE_NORMAL
- en: Support for different zones
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let me back up for a moment to the last example. I''m going to propose some
    changes to complicate our system architecture a little. The current architecture
    is visualized in the following diagram. The communication model between microservices
    is still the same, but now we launch two instances of every microservice and divide
    them into two different zones. A zoning mechanism has been already discussed in
    [Chapter 4](b016b615-1eed-457a-9b9c-66ba07c9ce9e.xhtml), *Service Discovery*,
    when talking about service discovery with Eureka, so I assume it is well known
    to you. The main purpose of this exercise is not only to show how to use Feign
    client, but also how a zoning mechanism works in communication between instances
    of microservices. Let''s start with the basics then:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/0afef3be-1670-4898-98c6-3c8c6f421485.png)'
  prefs: []
  type: TYPE_IMG
- en: Enabling Feign for an application
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To include Feign in the project, we have to add to the dependencies the `spring-cloud-starter-feign` artifact or
    `spring-cloud-starter-openfeign` for Spring Cloud Netflix in minimal version 1.4.0:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'The next step is to enable Feign for the application by annotating a main or
    a configuration class with `@EnableFeignClients`. This annotation will result
    in a search for all clients implemented in the application. We may also reduce
    the number of client used by setting the `clients` or `basePackages` annotation
    properties, for example, `@EnableFeignClients(clients = {AccountClient.class,
    Product.class})`. Here''s the main class of the `order-service` application:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: Building Feign interfaces
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'An approach where only an interface with some annotations has to be created
    to provide a component is standard for Spring Framework. For Feign, an interface
    must be annotated with `@FeignClient(name = "...")`. It has one required property
    name, which corresponds to the invoked microservice name if service discovery
    is enabled. Otherwise, it is used together with the `url` property, where we can
    set a concrete network address. `@FeignClient` is not the only annotation that
    needs to be used here. Every method in our client interface is associated with
    a specific HTTP API endpoint by marking it with `@RequestMapping` or more concrete
    annotations, such as `@GetMapping`, `@PostMapping`, or `@PutMapping`, as in this
    example source code fragment:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'Such components may be injected into the controller bean as they are also Spring
    Beans. Then, we just have to invoke their methods. Here''s the current implementation
    of the REST controller in `order-service`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: Launching microservices
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'I have changed a configuration for all the microservices in `application.yml`.
    Now, there are two different profiles, the first used for assigning an application
    to `zone1` and the second for `zone2`. You may check out the version from the
    `feign_with_discovery` branch ([https://github.com/piomin/shown here-spring-cloud-comm/tree/feign_with_discovery](https://github.com/piomin/sample-spring-cloud-comm/tree/feign_with_discovery)).
    Then, build the whole project using the `mvn clean install` command. The application
    should be launched with the `java -jar --spring.profiles.active=zone[n]` command,
    where `[n]` is the number of the zone. Because you have to start many instances
    to perform that test, it is worth considering a limit on heap size by setting
    the `-Xmx` parameter, for example, `-Xmx128m`. Here are the current configuration
    settings for one of the microservices:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'We will launch one instance of every microservice per single zone. So, there
    are nine running Spring Boot applications, including the service discovery server,
    as shown in this screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/0333d3f0-6041-4b5e-98cc-a474b4c5a072.png)'
  prefs: []
  type: TYPE_IMG
- en: 'If you send the test request to the instance of `order-service` running in
    `zone1` (`http://localhost:8090`), all the traffic will be forwarded to the other
    services in that zone, and the same for `zone2` (`http://localhost:9090`). I have
    highlighted the fragment where the Ribbon client prints a list of found addresses
    of the target service registered in the current zone:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: Inheritance support
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'You have probably noticed that the annotations inside a controller implementation
    and the Feign client implementation for a REST service served by that controller
    are identical. We may create an interface that contains abstract REST method definitions.
    That interface can be implemented by a controller class or extended by a Feign
    client interface:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, the controller class provides an implementation for all methods from the
    base interface, but does not contain any annotations for REST mappings instead
    of `@RestController`. Here''s a fragment of the `account-service` controller:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'The Feign client interface for calling `account-service` does not provide any
    methods. It just extends the base interface, `AccountService`. To see the full
    implementation based on interfaces and Feign inheritance, switch to the `feign_with_inheritance` branch:'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://github.com/piomin/shown here-spring-cloud-comm/tree/feign_with_inheritance](https://github.com/piomin/sample-spring-cloud-comm/tree/feign_with_inheritance)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Here''s an example Feign client declaration with inheritance support. It extends
    the `AccountService` interface, and hence handles all the methods exposed by `@RestController`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: Creating a client manually
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'If you are not convinced by the annotation-like style, you may always create
    a Feign client manually using the Feign Builder API. Feign has several features
    that can be customized, such as encoders and decoders for messages or HTTP client
    implementation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: Client customization
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Client customization can be performed not only with the Feign Builder API,
    but also by using the annotation-like style. We may provide a configuration class
    by setting it with the `configuration` property of `@FeignClient`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'An example configuration bean is shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'Spring Cloud supports the following properties to override by declaring Spring
    Beans:'
  prefs: []
  type: TYPE_NORMAL
- en: '`Decoder`: By default, `ResponseEntityDecoder`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Encoder`: By default, `SpringEncoder`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Logger`: By default, `Slf4jLogger`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Contract`: By default, `SpringMvcContract`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Feign.Builder`: By default, `HystrixFeign.Builder`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Client`: If Ribbon is enabled, it is `LoadBalancerFeignClient`; otherwise,
    the default Feign client is used.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Logger.Level`: It sets a default log level for Feign. You can choose between
    `NONE`, `BASIC`, `HEADERS` and `FULL`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Retryer`: It allows the implementing of the retry algorithm in case of communication
    failure.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`ErrorDecoder`: It allows the mapping of the HTTP status code into application-specific
    exception.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Request.Options`: It allows setting read and connects timeout for the request.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Collection<RequestInterceptor>`: Collection of registered `RequestInterceptor`
    implementations that perform some actions basing on data taken from request.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Feign client can also be customized using configuration properties. It is possible
    to override settings for all available clients or only for a single selected client
    by providing its name after the `feign.client.config` property prefix. If we set
    the name `default` instead of a specific client name, it will apply it to all Feign
    clients. Default configurations can also be specified when using the `@EnableFeignClients` annotation and
    its `defaultConfiguration` attribute in a similar way to what was described previously.
    The settings provided in the `appplication.yml` file always have a higher priority
    than the `@Configuration` bean. To change that approach and prefer `@Configuration`
    instead of the YAML file, you should set the `feign.client.default-to-properties` property to
    `false`. Here''s an example Feign client configuration for `account-service` that
    sets connect timeout, read timeout of HTTP connection, and log level:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we have launched a couple of microservices that communicate
    with one another. We discussed such topics as different implementations of REST
    clients, load balancing between multiple instances, and integration with service
    discovery. In my opinion, these aspects are so important that I decided to describe
    them in two chapters. This chapter should be treated as an introduction to the subject
    of inter-service communication and a discussion of integration with other important
    components of microservice architecture. The next chapter will show more advanced
    use of load balancers and REST clients, with particular attention on network and
    communication problems. After reading this chapter, you should be able to use
    Ribbon, Feign, and even `RestTemplate` properly in your applications and connect
    them to other Spring Cloud components.
  prefs: []
  type: TYPE_NORMAL
- en: In most cases, this knowledge is enough. However, sometimes you will need to
    customize client-side load balancer configuration or enable more advanced communication
    mechanisms like a circuit breaker or fallback. It is important to understand these
    solutions and their impact on the inter-service communication in your system.
    We will discuss them in the next chapter.
  prefs: []
  type: TYPE_NORMAL
