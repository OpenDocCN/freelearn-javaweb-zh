- en: Additional Configuration and Discovery Features
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We talked a great deal about service discovery and distributed configuration
    in [Chapter 4](b016b615-1eed-457a-9b9c-66ba07c9ce9e.xhtml), *Service Discovery*,
    and [Chapter 5](37142825-02d0-48a0-99df-1a1a88a1bbd4.xhtml), *Distributed Configuration
    with Spring Cloud Config*. We discussed two solutions in detail. The first of
    them, Eureka, is provided by Netflix OSS and has been adopted by Spring Cloud
    for service discovery. The second was the Spring Cloud Config project dedicated
    only to a distributed configuration. However, there are some interesting solutions
    on the market effectively combining both of these features. Currently, Spring
    Cloud supports two of them:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Consul**: This product is built by HashiCorp. It is a highly available, distributed
    solution designed to connect and configure applications across dynamic, distributed
    infrastructure. Consul is a rather complex product, and has multiple components,
    but its main functionality is discovering and configuring services across any
    infrastructure.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Zookeeper**: This product is built by Apache Software Foundation. It is a
    distributed, hierarchical key/value storage written in Java. It is designed to
    maintain configuration information, naming, and distributed synchronization. In
    contrast to Consul, it is more of a primitive key/value storage than a modern
    service discovery tool. However, Zookeeper is still very popular, especially for
    solutions based on the Apache Software stack.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Support for two other popular products from that area is still in the development
    stage. The following projects have still not been added to the official Spring
    Cloud Release Train:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Kubernetes**: This is an open-source solution designed for automating deployment,
    scaling, and management of containerized applications, originally created by Google.
    This tool is enjoying great popularity right now. Recently, the Docker platform
    has started supporting Kubernetes.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Etcd**: This is a distributed reliable key/value storage for the most critical
    data of a distributed system written in Go. It is used in production by many companies
    and other software products, for example, Kubernetes.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In this chapter, I'm going to introduce only officially supported solutions,
    namely Consul and Zookeeper. Kubernetes, which is much more than only a key/value
    storage or a service registry, will be discussed in [Chapter 14](0756243e-39c9-4696-8d79-4175e7cf4c48.xhtml),
    *Docker Support*.
  prefs: []
  type: TYPE_NORMAL
- en: Using Spring Cloud Consul
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The Spring Cloud Consul project provides integration for Consul and Spring Boot
    applications through auto-configuration. By using the well-known Spring Framework
    annotation style, we may enable and configure common patterns within microservice-based
    environments. These patterns include service discovery using Consul agent, distributed
    configuration using Consul key/value store, distributed events with Spring Cloud
    Bus, and Consul Events. The project also supports a client-side load balancer
    based on Netflix's Ribbon and an API gateway based on Netflix's Zuul. Before we
    start to discuss these features, we first have to run and configure Consul agent.
  prefs: []
  type: TYPE_NORMAL
- en: Running Consul agent
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We will begin with the simplest way of starting Consul agent on our local machines.
    The standalone development mode may be easily set up with the Docker container.
    Here''s the command, which will start the Consul container from the official Hashicorp''s
    image available on Docker Hub:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: After launching, Consul is available under the address `http://192.168.99.100:8500`.
    It exposes RESTful HTTP API, that is, the main interface. All the API routes are
    prefixed with `/v1/`. Of course, it is not required to use the API directly. There
    are some programming libraries that can be used to consume the API more conveniently.
    One of them is `consul-api`, the client written in Java and also used by Spring
    Cloud Consul internally. There is also the web UI dashboard provided by Consul
    available under the same address as the HTTP API, but on a different context path,
    `/ui/`. It allows for viewing all registered services and nodes, viewing all health
    checks and their current status, and reading and setting key/value data.
  prefs: []
  type: TYPE_NORMAL
- en: 'As I mentioned in the preface to this section, we are going to use three different
    features of Consul—agent, events, and KV store. Each of them is represented by
    the group of endpoints, respectively `/agent`, `/event`, and `/kv`. The most interesting
    agent endpoints are those related with service registration. Here''s a list of
    these endpoints:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Method** | **Path** | **Description** |'
  prefs: []
  type: TYPE_TB
- en: '| `GET` | `/agent/services` | It returns a list of the services registered
    with the local agent. If Consul is run in a clustered mode, that list may be different
    than the list reported by the `/catalog` endpoint before synchronization performed
    between cluster members. |'
  prefs: []
  type: TYPE_TB
- en: '| `PUT` | `/agent/service/register` | It adds a new service to the local agent.
    The agent is responsible for managing local services, and for sending updates
    to the servers to perform synchronization for the global catalog. |'
  prefs: []
  type: TYPE_TB
- en: '| `PUT` | `/agent/service/deregister/:service_id` | It removes a service with
    `service_id` from the local agent. The agent takes care of de-registering the
    service with the global catalog. |'
  prefs: []
  type: TYPE_TB
- en: 'The `/kv` endpoints are dedicated to managing simple key/value store, which
    is especially useful for storing service configuration or other metadata. It is
    worth noting that each data center has its own KV store, so in order to share
    it across multiple nodes, we should have configured the Consul replicate daemon.
    Anyway, here''s a list of the three endpoints for managing the key/value store:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Method** | **Path** | **Description** |'
  prefs: []
  type: TYPE_TB
- en: '| `GET` | `/kv/:key` | It returns the value for the given key name. If the
    requested key does not exist, HTTP status 404 is returned as a response. |'
  prefs: []
  type: TYPE_TB
- en: '| `PUT` | `/kv/:key` | It is used for adding a new key to the store, or just
    to update the existing one with a key name. |'
  prefs: []
  type: TYPE_TB
- en: '| `DELETE` | `/kv/:key` | It is the last CRUD method that is used for deleting
    a single key, or all keys, with the same prefix. |'
  prefs: []
  type: TYPE_TB
- en: Spring Cloud uses Consul Events for providing a dynamic configuration reload.
    There are two simple API methods. The first of them, `PUT /event/fire/:name`,
    triggers a new event. The second, `GET /event/list`, returns a list of events,
    which might be filtered by name, tag, node, or service name.
  prefs: []
  type: TYPE_NORMAL
- en: Integration on the client side
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To activate Consul service discovery in your project, you should include the
    starter `spring-cloud-starter-consul-discovery` to the dependencies. If you would
    like to enable distributed configuration with Consul, just include `spring-cloud-starter-consul-config`.
    In some cases, you would probably use both these features in your client-side
    application. Then, you should declare a dependency to the `spring-cloud-starter-consul-all`
    artifact:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'By default, the Consul agent is expected to be available under the address
    `localhost:8500`. If it is different for your application, you should provide
    the appropriate address in the `application.yml` or `bootstrap.yml` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: Service discovery
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Discovery with Consul is enabled for the application by annotating the main
    class with the generic Spring Cloud `@EnableDiscoveryClient`. You should remember
    that from [Chapter 4](b016b615-1eed-457a-9b9c-66ba07c9ce9e.xhtml), *Service Discovery*,
    because there is no difference in comparison with Eureka. The default service
    name is also taken from the `${spring.application.name}` property. Sample microservices
    that use Consul as a discovery server are available on GitHub in the [https://github.com/piomin/sample-spring-cloud-consul.git](https://github.com/piomin/sample-spring-cloud-consul.git)
    repository. The architecture of the system is the same as for examples in some
    previous chapters. There are four microservices, `order-service`, `product-service`,
    `customer-service`, and `account-service`, and the API gateway is implemented
    in the module `gateway-service`. For inter-service communication, we use the Feign
    client together with the Ribbon load balancer:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'By default, the Spring Boot application is registered in Consul with the instance
    ID generated as a concatenation of values taken from the properties `spring.application.name`,
    `spring.profiles.active`, `server.port`. In most cases, it is enough to be sure
    that the ID is unique, but if the custom pattern is required, it may be easily
    set with the `spring.cloud.consul.discovery.instanceId` property:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'After launching all the sample microservices, take a look at the Consul UI
    dashboard. You should see there are four different services registered, like in
    the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/8fa25939-b447-4d22-af84-19dab28e9745.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Alternatively, you may check out a list of registered services using the RESTful
    HTTP API endpoint `GET /v1/agent/services`. Here''s the fragment of the JSON response:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: Now, you may easily test the whole system by sending some test requests to `order-service`
    using the `pl.piomin.services.order.OrderControllerTest` JUnit test class. Everything
    should work fine, and the same as for discovery with Eureka.
  prefs: []
  type: TYPE_NORMAL
- en: Health check
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Consul checks out the health status of every registered instance by calling
    the `/health` endpoint. If you do not wish to provide the Spring Boot Actuator
    library in the classpath, or there are some problems with your service, it will
    be visible on the web dashboard:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/208a2cee-71ec-4469-b222-39572887b4ea.png)'
  prefs: []
  type: TYPE_IMG
- en: If the health check endpoint is available under a different context path for
    any reason, you may override that path with the `spring.cloud.consul.discovery.healthCheckPath`
    property. There is also the possibility to change the status refresh interval
    by defining `healthCheckInterval` with a pattern, such as, for example, `10s`
    for seconds or `2m` for minutes.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: Zones
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: I assume you remember our discussion about zoning mechanisms available for discovery
    with Eureka in [Chapter 4](b016b615-1eed-457a-9b9c-66ba07c9ce9e.xhtml), *Service
    Discovery*. It is useful when the hosts are placed in a different location, and
    you would prefer communication between instances registered in the same zone.
    The official documentation of the Spring Cloud Consul ([http://cloud.spring.io/spring-cloud-static/spring-cloud-consul/1.2.3.RELEASE/single/spring-cloud-consul.html](http://cloud.spring.io/spring-cloud-static/spring-cloud-consul/1.2.3.RELEASE/single/spring-cloud-consul.html))
    says nothing about such a solution, which fortunately doesn't mean it is not implemented.
    Spring Cloud provides a zoning mechanism based on Consul tags. The default zone
    for the application may be configured with the `spring.cloud.consul.discovery.instanceZone`
    property. It sets the tag configured in the `spring.cloud.consul.discovery.defaultZoneMetadataName`
    property with the passed value. The default metadata tag name is `zone`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s go back to the sample applications. I have extended all the configuration
    files with two profiles, `zone1` and `zone2`. Here''s the `bootstrap.yml` file
    for `order-service`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'There are two running instances of every microservice registered in two different
    zones. After building the whole project with the `mvn clean install` command,
    you should launch the Spring Boot application with the active profile `zone1`
    or `zone2`, for example, `java -jar --spring.profiles.active=zone1 target/order-service-1.0-SNAPSHOT.jar`.
    You can see the full list of registered instances tagged with the zone in the
    Nodes section. The view from the Consul dashboard is visible in the following
    screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/a1a34b42-27d3-46d1-814b-fc20ffd77a3e.png)'
  prefs: []
  type: TYPE_IMG
- en: The last element of our architecture is an API gateway based on Zuul. We also
    run two instances of `gateway-service` in different zones. We would like to omit
    registration in Consul and allow only a configuration to be fetched, which is
    used by the Ribbon client while performing load balancing. Here's the fragment
    of the `bootstrap.yml` file of `gateway-service`. Registration has been disabled
    by setting the properties `spring.cloud.
  prefs: []
  type: TYPE_NORMAL
- en: consul.discovery.register` and `spring.cloud.consul.discovery.
  prefs: []
  type: TYPE_NORMAL
- en: 'registerHealthCheck` to `false`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: Client settings customization
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The Spring Cloud Consul client may be customized through the properties in
    the configuration file. Some of those settings have already been introduced in
    the previous sections in this chapter. Other useful settings have been listed
    in the following table. All of them are prefixed with `spring.cloud.consul.discovery`:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Property** | **Default value** | **Description** |'
  prefs: []
  type: TYPE_TB
- en: '| `enabled` | `true` | It sets whether Consul discovery is enabled or disabled
    for an application |'
  prefs: []
  type: TYPE_TB
- en: '| `failFast` | `true` | It throws exceptions during service registration if
    `true`; otherwise, it logs warnings |'
  prefs: []
  type: TYPE_TB
- en: '| `hostname` | - | It sets the hostname of the instance when registering in
    Consul |'
  prefs: []
  type: TYPE_TB
- en: '| `preferIpAddress` | `false` | It forces an application to send its IP address
    instead of the hostname during registration |'
  prefs: []
  type: TYPE_TB
- en: '| `scheme` | `http` | It sets whether the service is available under HTTP or
    HTTPS protocol |'
  prefs: []
  type: TYPE_TB
- en: '| `serverListQueryTags` | - | It allows filtering services by a single tag
    |'
  prefs: []
  type: TYPE_TB
- en: '| `serviceName` | - | It overrides the service name, which by default takes
    from the property `spring.application.name` |'
  prefs: []
  type: TYPE_TB
- en: '| `tags` | - | It sets the list tags with values to use when registering the
    service |'
  prefs: []
  type: TYPE_TB
- en: Running in clustered mode
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Until now, we were always launching a single, standalone instance of Consul.
    As far as this is a suitable solution in development mode, it is not enough for
    a production. There, we would like to have a scalable, production-grade service
    discovery infrastructure, consisting of some nodes working together inside the
    cluster. Consul provides support for clustering based on a gossip protocol used
    for communication between members and a Raft consensus protocol for a leadership
    election. I wouldn't like to go into the details of that process, but some basics
    about Consul architecture should be clarified.
  prefs: []
  type: TYPE_NORMAL
- en: We have already talked about Consul agent, but what it is exactly and what is
    its role weren't explained. An agent is the long-running daemon on every member
    of the Consul cluster. It may be run in either client or server mode. All agents
    are responsible for running checks and keeping services registered, in different
    nodes and in sync, globally.
  prefs: []
  type: TYPE_NORMAL
- en: 'Our main goal in this section is to set up and configure the Consul cluster
    using its Docker image. First, we will start the container, which acts as a leader
    of the cluster. There is only one difference in the currently used Docker command
    than for the standalone Consul server. We have set the environment variable `CONSUL_BIND_INTERFACE=eth0`
    in order to change the network address of the cluster agent from `127.0.0.1` to
    the one available for other member containers. My Consul server is now running
    at the internal address `172.17.0.2`. To check out what your address is (it should
    be the same) you may run the command `docker logs consul`. The appropriate information
    is logged just after container startup:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'Knowledge of that address is very important, since now we have to pass it to
    every member container startup command as a cluster join parameter. We also bind
    it to all interfaces by setting `0.0.0.0` as a client address. Now, we may easily
    expose the client agent API outside the container using the `-p` parameter:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'After running two containers with Consul agent, you may check out the full
    list of cluster members by executing the following command on the leader''s container:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/62ad9459-eb41-4770-8035-f2a23dee1e42.png)'
  prefs: []
  type: TYPE_IMG
- en: 'The Consul server agent is exposed on the `8500` port, while member agents
    on ports `8501` and `8502`. Even if the microservice instance registers itself
    to a member agent, it is visible to all members of a cluster:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/0003cbac-7ff3-4286-ac65-3c13cf98a2ad.png)'
  prefs: []
  type: TYPE_IMG
- en: 'We may easily change the default Consul agent address for the Spring Boot application
    by changing the configuration properties:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: Distributed configuration
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'An application with Spring Cloud Consul Config library in the classpath fetches
    configuration from the Consul key/value store during the bootstrap phase. That
    is, by default, stored in the `/config` folder. When we are creating a new key
    first, we have to set a folder path. That path is then used for identifying the
    key and assigning it to the application. Spring Cloud Config tries to resolve
    properties stored in the folder based on the application name and active profiles.
    Assuming we have the `spring.application.name` property set to `order-service`
    in the `bootstrap.yml` file and the `spring.profiles.active` running argument
    set to `zone1`, it tries to locate the property sources in the following order:
    `config/order-service,zone1/`, `config/order-service/`, `config/application,zone1/`,
    `config/application/`. All folders with the prefix `config/application` are the
    default configuration dedicated to all the applications that do not have service-specific
    property sources.'
  prefs: []
  type: TYPE_NORMAL
- en: Managing properties in Consul
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The most comfortable way to add a single key to Consul is through its web dashboard.
    The other way is by using the `/kv` HTTP endpoint, which has been already described
    at the beginning of this chapter. When using a web console, you have to go to
    the section KEY/VALUE. Then, you may view all the currently existing keys and
    also create a new one by providing its full path and value, in any format. That
    feature is visualized in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/f0b420c2-a7db-4403-9a36-107311c5d2ac.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Every single key may be updated or deleted:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/85ffa69a-6da9-49aa-b8fc-ef419d3a28ce.png)'
  prefs: []
  type: TYPE_IMG
- en: To access a sample application that uses a property source stored in Consul,
    you should switch to the branch configuration in the same repository as the previous
    sample. I have created keys, `server.port` and `spring.cloud.consul.discovery.instanceZone`,
    for every microservice instead of defining it in the `application.yml` or `bootstrap.yml`
    files.
  prefs: []
  type: TYPE_NORMAL
- en: Client customization
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The Consul Config client may be customized with the following properties, which
    are prefixed with `spring.cloud.consul.config`:'
  prefs: []
  type: TYPE_NORMAL
- en: '`enabled`: By setting this property to `false`, you may disable Consul Config.
    It is useful if you include `spring-cloud-starter-consul-all`, which enables both
    discovery and distributed configuration.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`fail-fast`: This sets whether to throw exceptions during configuration lookup
    or log warnings in case of connection failure. Setting it to `true` allows the
    application to continue startup normally.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`prefix`: This sets the base folder for all the configuration values. By default,
    it is `/config`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`defaultContext`: This sets the folder name used by all applications that do
    not have a specific configuration. By default, it is `/application`. For example,
    if you override it to `app`, the properties should be searched in the folder `/config/apps`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`profileSeparator`: By default, a profile is separated with an application
    name using a comma. That property allows you to override the value of that separator.
    For example, if you set it to `::`, you should create the folder `/config/order-service::zone1/`.
    Here''s an example:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: Sometimes, you would like to store a blob of properties created in a YAML or
    Properties format, in contrast to individual key/value pairs. In that case, you
    should set the `spring.cloud.consul.config.format` property to `YAML` or `PROPERTIES`.
    Then, the application would look for configuration properties located inside a
    folder with the data key, for example, `config/order-service,zone1/data`, `config/order-service/data`,
    `config/application,zone1/data`, or `config/application/data`. The default data
    key may be changed using the `spring.cloud.consul.config.data-key` property.
  prefs: []
  type: TYPE_NORMAL
- en: Watching configuration changes
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The sample that has been discussed in the previous section loads the configuration on
    startup of the application. If you would like that configuration to be reloaded,
    you should send an HTTP `POST` to the `/refresh` endpoint. In order to examine
    how such a refresh would work for our application, we modify the fragment of application
    code responsible for creating some test data. Until now, it has been provided
    as a repository, `@Bean`, with some hardcoded in-memory objects. Take a look at
    the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'Our goal is to move the code visible here to the configuration store using
    the Consul key/value feature. To achieve this, we have to create three keys per
    object, with names `id`, `name`, and `type`. The configuration is loaded from
    the properties with the `repository` prefix:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'The next step is to define the appropriate keys for each service using the
    Consul web dashboard. Here''s the sample configuration for the list consisting
    of `Customer` objects. The list is initialized on application startup:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/bffd5327-fdb1-4ea1-9e4f-8dd99169c30a.png)'
  prefs: []
  type: TYPE_IMG
- en: 'You may change the value of each property. The update event would be automatically
    sent to application thanks to Consul''s ability to watch a key prefix. If there
    is a new configuration data, the refresh event is published to the queue. All
    queues and exchanges are created on application startup by Spring Cloud Bus, which
    is included in the project as a dependency of `spring-cloud-starter-consul-all`.
    If your application receives such an event, it prints the following information
    in logs:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: Using Spring Cloud Zookeeper
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Spring Cloud supports various products used as a part of the microservices
    architecture. You can find this out when reading this chapter where Consul has
    been compared with Eureka as a discovery tool, and with Spring Cloud Config as
    a distributed configuration tool. Zookeeper is another solution that might serve
    as an alternative choice to those listed previously. As with Consul, it can be
    used for both service discovery and distributed configuration. To enable Spring
    Cloud Zookeeper in the project, you should include the `spring-cloud-starter-zookeeper-discovery`
    starter for the service discovery feature, or `spring-cloud-starter-zookeeper-config`
    for the configuration server feature. Alternatively, you may declare a `spring-cloud-starter-zookeeper-all`
    dependency that activates all functionalities for the application. Don''t forget
    to include `spring-boot-starter-web`, which is still required to provide web functionality:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'Zookeeper connection settings are auto-configured. By default, the client tries
    to connect to `localhost:2181`. In order to override it, you should define the
    `spring.cloud.zookeeper.connect-string` property with the current server network
    address:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: As with Spring Cloud Consul, Zookeeper supports all the most popular communication
    libraries provided by Spring Cloud Netflix, such as Feign, Ribbon, Zuul, or Hystrix.
    Before we start working on the sample implementation, first we have to start the
    Zookeeper instance.
  prefs: []
  type: TYPE_NORMAL
- en: Running Zookeeper
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'As you probably guessed, I''m going to launch Zookeeper on the local machine
    using its Docker image. The following command starts the Zookeeper server instance.
    Since it <q>fails fast</q>, the best approach is to always restart it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'In contrast to previously discussed solutions in this area, such as Consul
    or Eureka, Zookeeper doesn''t provide a simple RESTful API or a web management
    console that allows us to easily manage it. It has an official API binding for
    Java and C. We may also use its command line interface, which can be easily started
    within the Docker container. The command visible here starts the container with
    the command line client, and links it to the Zookeeper server container:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'Zookeeper CLI allows for performing some useful operations, such as the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Creating znodes**: To create a znode with the given path, use the command
    `create /path /data`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Getting data**: The command `get /path` returns the data and metadata associated
    with the znode.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Watching znode for changes**: This shows a notification if znode or znode''s
    children data changes. Watching can only be set with the `get` command.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Setting data**: To set znode data, use the command `set /path /data`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Creating children of a znode**: This command is similar to that used for
    creating a single znode. The only difference is that the path of the child znode
    includes the parent path `create /parent/path/subnode/path /data`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Listing children of a znode**: This may be displayed using the `ls /path`
    command.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Checking status**: This may be checked out with the command `stat /path`.
    Status describes the metadata of a specified znode, like timestamp or version
    number.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Removing/deleting a znode**: The command `rmr /path` removes the znode with
    all its children.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In that fragment, the term *znode* has appeared for the first time. When storing
    data, Zookeeper uses a tree structure, where each node is called a **znode**.
    The names of those znodes are based on the path taken from the root node. Each
    node has a name. It can be accessed using the absolute path that begins from the
    root node. This concept is similar to Consul folders, and has been used for creating
    keys in the key/value store.
  prefs: []
  type: TYPE_NORMAL
- en: Service discovery
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The most popular Java client library for Apache Zookeeper is Apache Curator.
    It provides an API framework and utilities to make using Apache Zookeeper much
    easier. It also includes recipes for common-use cases and extensions, such as
    service discovery or Java 8 asynchronous DSL. Spring Cloud Zookeeper leverages
    one such extension for service discovery implementation. The usage of the Curator
    library by Spring Cloud Zookeeper is completely transparent for the developer,
    so I wouldn't like to describe it in more detail here.
  prefs: []
  type: TYPE_NORMAL
- en: Client implementation
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The usage on the client side is the same as for other Spring Cloud projects
    related to service discovery. The application main class, or `@Configuration`
    class, should be annotated with `@EnableDiscoveryClient`. The default service
    name, instance ID, and port are taken from `spring.application.name`, the Spring
    Context ID, and `server.port`, respectively.
  prefs: []
  type: TYPE_NORMAL
- en: Sample application source code is available in the GitHub repository at [https://github.com/piomin/sample-spring-cloud-zookeeper.git](https://github.com/piomin/sample-spring-cloud-zookeeper.git).
    Fundamentally, it is no different than the sample system introduced for Consul,
    other than the dependency on Spring Cloud Zookeeper Discovery. It still consists
    of four microservices, which communicate with each other. Now, after cloning the
    repository, build it with the `mvn clean install` command. Then, run every service
    with an active profile name using `java -jar` command, for example, `java -jar
    --spring.profiles.active=zone1 order-service/target/order-service-1.0-SNAPSHOT.jar`.
  prefs: []
  type: TYPE_NORMAL
- en: 'You may see the list of registered services and instances by using the CLI
    commands `ls` and `get`. Spring Cloud Zookeeper, by default, registers all instances
    in the `/services` root folder. It may be overridden with the `spring.cloud.zookeeper.discovery.root`
    property. You may check out a list of currently registered services by using the
    Docker container with the command-line client:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/fdbd83d4-a14c-43f6-8302-5a761da38a9d.png)'
  prefs: []
  type: TYPE_IMG
- en: Zookeeper dependencies
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Spring Cloud Zookeeper has one additional feature, called **Zookeeper dependencies**.
    Dependencies are to be understood as the other applications registered in Zookeeper,
    which are called via the Feign client or the Spring `RestTemplate`. These dependencies
    may be provided as properties of the application. The functionality is enabled
    through auto-configuration after you include the `spring-cloud-starter-zookeeper-discovery`
    starter to the project. It may be disabled by setting the `spring.cloud.zookeeper.dependency.enabled`
    property to `false`.
  prefs: []
  type: TYPE_NORMAL
- en: 'The configuration of the Zookeeper Dependency mechanism is provided with `spring.cloud.zookeeper.dependencies.*`
    properties. Here''s the fragment of the `bootstrap.yml` file from `order-service`.
    This service integrates with all other available services:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s take a closer look at the preceding configuration. The root property
    of every called service is the alias, which may then be used as the service name
    by the Feign client or `@LoadBalanced RestTemplate`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: The next very important field in the configuration is the path. It sets the
    path under which the dependency is registered in Zookeeper. So, if that property
    has the value `customer-service`, it means Spring Cloud Zookeeper tries to look
    up the appropriate service znode under the path `/services/customer-service`.
    There are some other properties that may customize the behavior of the client.
    One of them is `loadBalancerType`, used for applying the load balancing strategy.
    We can choose between three available strategies—`ROUND_ROBIN`, `RANDOM`, and
    `STICKY`. I also set the `required` property to `true` for every service mapping. Now,
    if your application can’t detect the required dependency during boot time, it
    fails to start. Spring Cloud Zookeeper dependencies also allow managing API versions
    (the properties `contentTypeTemplate` and `versions`), and request headers (the
    `headers` property).
  prefs: []
  type: TYPE_NORMAL
- en: By default, Spring Cloud Zookeeper enables `RestTemplate` for communication
    with dependencies. In the sample application available in branch dependencies
    ([https://github.com/piomin/sample-spring-cloud-zookeeper/tree/dependencies](https://github.com/piomin/sample-spring-cloud-zookeeper/tree/dependencies)),
    we use the Feign client instead of `@LoadBalanced RestTemplate`. In order to disable
    that feature, we should set the property `spring.cloud.zookeeper.dependency.resttemplate.enabled`
    to `false`.
  prefs: []
  type: TYPE_NORMAL
- en: Distributed configuration
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Configuration management with Zookeeper is pretty similar to that described
    for Spring Cloud Consul Config. By default, all the property sources are stored
    in the `/config` folder (or znode in Zookeeper nomenclature). Let me point it
    out one more time. Assuming we have the `spring.application.name` property set
    to `order-service` in the `bootstrap.yml` file, and the `spring.profiles.active`
    running argument set to `zone1`, it tries to locate the property sources in the
    following order: `config/order-service,zone1/`, `config/order-service/`, `config/application,zone1/`,
    `config/application/`. Properties stored in the folder with the prefix `config/application`
    in the namespace are available for all applications that use Zookeeper for distributed
    configuration.'
  prefs: []
  type: TYPE_NORMAL
- en: 'To access the sample application, you need to switch to the branch configuration
    in the [https://github.com/piomin/sample-spring-cloud-zookeeper.git](https://github.com/piomin/sample-spring-cloud-zookeeper.git)
    repository. The configuration defined in the local `application.yml` or `bootstrap.yml`
    file, visible here, has now been moved to Zookeeper:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'The required znodes have to be created using CLI. Here''s the list of Zookeeper
    commands that create znodes with the given path. I have used the `create /path
    /data` command:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/7494c667-24b5-4a33-aef6-fbb27e519e61.png)'
  prefs: []
  type: TYPE_IMG
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, I have guided you through the main features of two Spring Cloud
    projects—Consul and Zookeeper. I haven't focused only on Spring Cloud functionalities,
    but have also given you the instructions on how to start, configure, and maintain
    instances of its tools. We have discussed even more advanced scenarios, such as
    setting up a cluster consisting of numerous members using Docker. There, you had
    a chance to see the true power of Docker as a development tool. It allowed us
    to initialize a cluster that consists of three members just by using three simple
    commands, without any additional configuration.
  prefs: []
  type: TYPE_NORMAL
- en: Consul seems to be an important alternative to Eureka as a discovery server
    when using Spring Cloud. I cannot say the same about Zookeeper. As you have probably
    noticed, I have written much more about Consul than Zookeeper. Also, Spring Cloud
    treats Zookeeper as a second choice. It still does not have a zoning mechanism
    or watching capability for configuration changes that are implemented, in contrast
    to Spring Cloud Consul. You shouldn't be surprised by this. Consul is a modern
    solution designed in order to meet needs of the newest architectures, such as
    microservices-based systems, while Zookeeper is a key/value store adopted as a
    service discovery tool for applications running in a distributed environment.
    However, it is worth considering this tool if you use an Apache Foundation stack
    in your system. Thanks to that, you may take advantage of integration between
    Zookeeper and other Apache components, such as Camel or Karaf, and easily discover
    services created using the Spring Cloud framework.
  prefs: []
  type: TYPE_NORMAL
- en: To conclude, after reading this chapter, you should be able to use the main
    features of Spring Cloud Consul and Spring Cloud Zookeeper in your microservice-based
    architecture. You should also know the major advantages and disadvantages of all
    available discovery and configuration tools within Spring Cloud, in order to choose
    the most appropriate solution for your system.
  prefs: []
  type: TYPE_NORMAL
