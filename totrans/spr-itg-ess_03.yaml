- en: Chapter 3. Message Processing
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In [Chapter 1](part0018_split_000.html#page "Chapter 1. Getting Started"),
    *Getting Started*, we discussed that the need for enterprise integration was evolved
    to solve the problem of intercommunication between heterogeneous systems: how
    will they share data, how will they understand other systems'' data, how cross-cutting
    concerns across applications will be handled, and so on. In the previous chapter,
    we covered one of the aspects, that is, how the systems will exchange data. Channels
    provide a logical unit over which data can be dropped off for other interested
    applications. However, it introduces the next set of challenges: what if the format
    of data is not understandable by other modules, or what if the rate of producing
    a message versus the rate of consuming it is different? Let''s take an example;
    an RSS feed needs to be fetched from the Internet and put in a database for reporting,
    as well as on a mailing system to send out mails about the availability of new
    items. What challenges does it throw?'
  prefs: []
  type: TYPE_NORMAL
- en: The RSS feed is in the XML format, while for databases and mail it needs to
    be converted to the Java entity and the Java `MailMessage` format, respectively
    (assuming JPA and java mail is being used). This means the XML payload needs to
    be translated into the format expected by the next set of endpoints.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: There could be latency while sending out mails; hence, flooding the mail server
    might result in loss of messages, indicating the need for throttling.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Before the message can be handed over to the database, some audit information
    such as timestamp, user logged in, and others, needs to be augmented.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: There might be some XML payloads that are not valid or may be incomplete. We
    would like to discard those and retry!
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The mail server might not be available at the time the feed arrived—what to
    do then?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'These points provide a glimpse into a few of the aspects that need to be taken
    care of when two systems try to communicate. It''s definitely not a good idea
    to load the systems with all this heavy logic and in turn introduce tight coupling
    between them. Then, who takes care of all of these aspects? Let''s welcome message
    endpoints. In this chapter, we will cover the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Message endpoints
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Gateways
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Service activators
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Delayers
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Transactions
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Message endpoints
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In the simplest analogy, **message endpoints** are enablers that facilitate
    interaction between two systems—be it transformation of messages, throttling,
    intermediate business processing, or any other tasks that might be needed for
    the message to be successfully and seamlessly handled by the next system in the
    chain. To cater to different needs, different types of message endpoints are available,
    for example, *enrichers*, *delayers*, *service activators*, and others. However,
    before diving deep into each specific detail, let''s discuss the broad level of
    categorization for the endpoints:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Receivers or senders**: Endpoints can either receive messages from the channel
    or put messages on the channel for further processing.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Polling endpoints or event-driven endpoints**: Endpoints can either pull
    messages from the channel or can subscribe to it. Whenever a message is available,
    a registered callback method is called.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Unidirectional or bidirectional endpoints**: Unidirectional endpoints send
    off or receive messages, but do not expect or receive any acknowledgement. Spring
    Integration provides channel adapters for such types of interactions. Bidirectional
    adapters can send, receive, and acknowledge messages. Spring Integration provides
    gateways that are synonymous with synchronous two-way communication.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Inbound or outbound endpoints**: Outbound endpoints interact with external
    systems such as social networks, mail servers, enterprise JMS, and others, whereas
    inbound endpoints listen for events from outside entities such as mail connector,
    FTP connector, and so on.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Spring Integration has provided implementation of all of these types; let's
    explore them.
  prefs: []
  type: TYPE_NORMAL
- en: Gateways
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Abstraction and loose coupling is always desired. **Messaging gateways** is
    a mechanism to publish a contract that can be used by systems without exposing
    the underlying messaging implementation. For example, a gateway for a mailing
    subsystem can expose methods for sending and receiving mail. Internally, the implementation
    can be done using the raw Java mail API, or can be adapters from Spring Integration,
    or may be some custom implementation altogether. As long as the contract does
    not change, implementation can be easily switched or enhanced without impacting
    on the rest of the modules. It is an implementation of more generic *gateway*
    patterns. Gateways can be of two types: *synchronous* and *asynchronous*.'
  prefs: []
  type: TYPE_NORMAL
- en: Synchronous gateways
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Let''s quickly see what a declaration of a gateway looks like in Spring Integration,
    and then decimate it further to build our understanding:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'This basic code defines a gateway in Spring. Let''s understand the preceding
    declaration:'
  prefs: []
  type: TYPE_NORMAL
- en: '`int:gateway`: This is the Spring framework namespace for gateway'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`service-interface`: This is an interface that is the contract published by
    the gateway'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`default-request-channel`: This is the channel on which gateway puts the message
    for processing'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`default-reply-channel`: This is the channel on which gateway expects a reply'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The interface is a simple Java interface declaration:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'We defined an interface and then defined the channels on which messages will
    be sent and read through using the gateway—but where is the implementation class
    that the components use to process the message and acknowledge it? Here, some
    Spring Integration magic is involved—when this XML is parsed, a proxy for this
    interface is created by the framework''s `GatewayProxyFactoryBean` class. If there
    is a service request for a declared gateway, a proxy will forward the message
    on `default-request-channel` and will block the call until an acknowledgement
    is available on the `default-reply-channel`. The preceding declaration can be
    further extended to have channels per method call of the gateway:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: Now when the `createFeed` method is called, messages will be put on `createFeedRequestChannel`,
    while for the `readAllFeed` method of gateway, messages will be forwarded to `readFeedRequestChannel`.
    Hold on a second—where is the `default-reply-channel`? The reply channel is an
    optional parameter and if it's not declared, an anonymous point-to-point reply
    channel is created by the gateway and is added to message headers with the name
    `replyChannel`. Explicit declaration would be helpful if we need a publish-subscribe
    channel to which multiple endpoints can listen.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can easily leverage Spring Integration annotation support instead of using
    XML declarations:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: Asynchronous gateways
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Asynchronous gateways do not expect an acknowledgement. After putting messages
    on the request channel, they move onto other processing without blocking for a
    reply on the reply channel. The Java language''s `java.util.concurrent.Future`
    class provides a mechanism to fulfill this behavior; we can define our gateway
    service that returns a `Future` value. Let''s modify `FeedService`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: Nothing else changes and all XML declarations remain the same. When the return
    type is changed to `Future`, Spring framework's `GatewayProxyFactoryBean` class
    takes care of switching to asynchronous mode by leveraging `AsyncTaskExecutor`.
  prefs: []
  type: TYPE_NORMAL
- en: Service activators
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**Service** **activators** are one of the simplest and most useful endpoints—a
    plain java class whose methods can be invoked on the messages received on a channel.
    Service activators can either terminate the message processing or pass it on to
    the next channel for further processing. Let''s have a look at the following example.
    We would like to do some validation or business logic before passing the message
    on to the next channel. We can define a Java class and annotate it as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'In our XML, we can attach the class to a channel so that it processes each
    and every message on it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s quickly go through the elements used in the preceding declaration:'
  prefs: []
  type: TYPE_NORMAL
- en: '`@MessageEndpoint`: This annotation tells Spring to treat a class as a specific
    Spring bean—a message endpoint. Since we have annotated this call with `MessageEndpoint`,
    there is no need to declare this bean in XML. It will be discovered in the component
    scan of Spring.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`@ServiceActivator`: This annotation maps a method that should be invoked when
    a message arrives on the channel. This message is passed as a parameter.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`int:service-activator`: This is an XML namespace declaring the Spring endpoint
    type.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`input-channel`: This is the channel from which the service activator will
    read the messages.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`output-channel`: This is the channel on which the activator will dump the
    processed messages.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`ref`: This is a reference of the bean that performs the processing.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The preceding example restricts a single method in a class as `@ServiceActivator`.
    However, what if we want to delegate to an explicit method—maybe based on payloads?
    We define the method element for the service activator in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: In these two declarations, reference for the service activator is the same,
    that is, the class acting as the service is `feedDaoService`, but its different
    methods are invoked in different scenarios.
  prefs: []
  type: TYPE_NORMAL
- en: As we mentioned earlier, the output channel is optional. If the method return
    type is void, then it indicates that the message flow is terminated and Spring
    Integration is fine with it. However, what if the message type is not null and
    the output channel is also omitted? Spring Integration will try a fallback mechanism—it
    will try to look for a header with the name `replyChannel` in the message. If
    the value against the `replyChannel` header is of the type `MessageChannel`, then
    the messages will be sent to that channel. But if it's a string, then it will
    try looking for channels with that name. If both fail, then it will throw a `DestinationResolutionException`
    exception.
  prefs: []
  type: TYPE_NORMAL
- en: What type of message can a service activator process? The method argument can
    be either of the type `Message` or a Java `Object`. If it is `Message`, then we
    can read the payload and work upon it—but this introduces a dependency on the
    Spring `Message` type. A better approach is to declare the Java type as declared
    in the preceding example. Spring Integration will take care of extracting the
    payload and converting it to a declared object type before invoking the method
    on the service activator. If type conversion fails, an exception will be thrown.
    Similarly, returned data from the method is wrapped in a `Message` object and
    passed on to the next channel.
  prefs: []
  type: TYPE_NORMAL
- en: Can there be an activator method without any argument? Yes! This could be pretty
    useful in a scenario where we only care if an action was performed or not, for
    example, perhaps for an audit or for reporting purposes.
  prefs: []
  type: TYPE_NORMAL
- en: Delayers
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'As we already discussed in the introduction section, there could be a difference
    in the rate of messages produced and its rate of consumption—what if the consumer
    is slow? Since external systems are involved, it might not be in our control to
    influence the rate at which the producer produces messages. This is where a delayer
    is used. A **delayer** is a simple endpoint that introduces a delay before the
    message is delivered to the next endpoint. The most notable part is that the original
    sender is neither blocked nor slowed down; rather, the delayer will pick a message
    from a channel and use an instance of `org.springframework.scheduling.TaskScheduler`
    to schedule its delivery to the output channel after a configured interval. Let''s
    write a simple delayer:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: This simple configuration will delay the delivery of messages on the input channel
    to the output channel by 10 seconds.
  prefs: []
  type: TYPE_NORMAL
- en: 'What if we want to delay each message with a different time interval—let''s
    say based on payload size we want to increase or decrease the delay? The `expression`
    attribute comes in handy here. The preceding example can be modified as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: The delayer delays message by certain intervals—what if the system goes down
    while there were delayed messages yet to be delivered on the output channel? We
    can leverage `MessageStore`, especially persistent `MessageStore` interfaces such
    as `JdbcMessageStore`. If it is used, then all messages are persisted as soon
    as the system goes down. When it comes up, all of the messages for which a delay
    interval has expired will be delivered on the output channel immediately.
  prefs: []
  type: TYPE_NORMAL
- en: Transactions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We have been talking about how message endpoints enable communication across
    different subsystems. This brings up a very crucial question—what about transactions?
    How are they handled across the chain? What are the Spring Integration offerings
    on transactions?
  prefs: []
  type: TYPE_NORMAL
- en: 'Spring Integration, per se, does not provide additional support for transactions;
    rather, it builds upon the existing infrastructure of the transaction support
    provided by Spring. It just provides hooks that can be used to plug in the transactional
    behavior. Annotating a service activator or gateway with a transactional annotation
    will support the transaction boundaries of the message flow. Let''s say a user
    process was initiated with the transaction that is propagatory in nature and all
    Spring Integration components in the chain have been annotated as transactional,
    then a failure at any stage in the chain will result in a roll back. However,
    this will happen only if transaction boundaries have not been broken—put simply,
    everything is going on in a single thread. A single thread execution can break,
    for example, use cases such as task executor that spawns new threads, aggregators
    that can hold onto the messages, and time outs that can occur. Here is a quick
    example of making a poller transactional:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: Here, `"entity-manager"`, `"transaction-manager"`, and so on are all standard
    Spring components—only the namespace from Spring Integration, such as `int-jpa`
    and `int:transactional`, has been used to plug them in. Right now, the adapter
    is of no interest to us; we will cover all other tags in subsequent chapters.
  prefs: []
  type: TYPE_NORMAL
- en: 'What about a use case where a process was not initiated with a transaction
    but, down the line, we want to introduce transactions on a subsystem? For example,
    a batch job or a poller that polls on a channel and picks a file to put it on
    an FTP server. There is no propagation of transactions, but we want to make this
    aspect transactional so that we can retry in case of failures. Spring Integration
    provides transaction support for pollers that can help start a transaction so
    that the process beyond a poller can be handled in a single unit of work! Here
    is a quick example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: To summarize, Spring Integration hooks into the Spring transaction support and,
    with a little intuition and creativity, it can even be extended to systems that
    are nontransactional in nature!
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we understood the reason why messaging endpoints are required,
    and discovered a few of the endpoints provided by Spring Integration. We covered
    how gateways can abstract underlying messaging implementation, making life simpler
    for a developer, how service activators can be used for intermediate processing
    of messages in the system, and how delayers can be used to throttle message processing
    rates to match the producer's and consumer's speed! We touched upon the transactional
    support—we discussed it only because it does not provide any new implementation
    and hooks into the Spring framework's transactional support.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will dive deeper into one of the most important endpoints—message
    transformers.
  prefs: []
  type: TYPE_NORMAL
