- en: Best Practices and Common Principles
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: After all the hard work put in by you toward gaining the experience of developing
    a microservice sample project, you must be wondering how to avoid common mistakes
    and improve the overall process of developing microservice-based products and
    services. We can follow these principles or guidelines to simplify the process
    of developing microservices and avoid/reduce the potential limitations. We will
    focus on these key concepts in this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: 'This chapter is spread across the following three sections:'
  prefs: []
  type: TYPE_NORMAL
- en: Overview and mindset
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Best practices and principles
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Microservice frameworks and tools
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Overview and mindset
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: You can implement microservice-based design on both new and existing products
    and services. Contrary to the belief that it is easier to develop and design a
    new system from scratch rather than making changes to an existing one that is
    already live, each approach has its own respective challenges and advantages.
  prefs: []
  type: TYPE_NORMAL
- en: For example, since there is no existing system design for a new product or service,
    you have freedom and flexibility to design the system without giving any thought
    to its impact. However, you don't have the clarity on both functional and system
    requirements for a new system, as these mature and take shape over time. On the
    other hand, for mature products and services, you have detailed knowledge and
    information of the functional and system requirements. Nevertheless, you have
    a challenge to mitigate the risk of impact that design change brings to the table.
    Therefore, when it comes to updating a production system from monolithic to microservices,
    you will need to plan better than if you were building a system
  prefs: []
  type: TYPE_NORMAL
- en: from scratch.
  prefs: []
  type: TYPE_NORMAL
- en: Experienced and successful software design experts and architects always evaluate
    the pros and cons and take a cautious approach to making any change to existing
    live systems. One should not make changes to existing live system design simply
    because it may be cool or trendy. Therefore, if you would like to update the design
    of your existing production system to microservices, you need to evaluate all
    the pros and cons before making this call.
  prefs: []
  type: TYPE_NORMAL
- en: I believe that monolithic systems provide a great platform to upgrade to a successful
    microservice-based design. Obviously, we are not discussing cost here. You have
    ample knowledge of the existing system and functionality, which enables you to
    divide the existing system and build microservices based on functionalities and
    how those would interact with each other. Also, if your monolithic product is
    already modularized in some way, then directly transforming microservices by exposing
    an API instead of an **Application Binary Interface** (**ABI**) is possibly the
    easiest way of achieving a microservice architecture. A successful microservice-based
    system is more dependent on microservices and their interaction protocol than
    anything else.
  prefs: []
  type: TYPE_NORMAL
- en: Having said that, it does not mean that you cannot have a successful microservice-based
    system if you are starting from scratch. However, it is recommended to start a
    new project based on monolithic design that gives you perspective and understanding
    of the system and functionality. It allows you to find bottlenecks quickly and
    guides you to identify any potential feature that can be developed using microservices.
    Here, we have not discussed the size of the project, which is another important
    factor. We'll discuss this in the next section.
  prefs: []
  type: TYPE_NORMAL
- en: In today's cloud age and agile development world, it takes an hour between making
    any change and the change going live. In today's competitive environment, every
    organization would like to have the edge for quickly delivering features to the
    user. Continuous development, integration, and deployment are part of the production
    delivery process, a completely automatic process.
  prefs: []
  type: TYPE_NORMAL
- en: It makes more sense if you are offering cloud-based products or services. Then,
    a microservice-based system enables the team to respond with agility to fix any
    issue or provide a new feature to the user.
  prefs: []
  type: TYPE_NORMAL
- en: Therefore, you need to evaluate all the pros and cons before you make a call
    for starting a new microservice-based project from scratch or planning to upgrade
    the design of an existing monolithic system to a microservice-based system. You
    have to listen to and understand the different ideas and perspectives shared across
    your team, and you need to take a cautious approach.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, I would like to share the importance of having better processes and
    an efficient system in place for a successful production system. Having a microservice-based
    system does not guarantee a successful production system, and a monolithic application
    does not mean you cannot have a successful production system in today's age. Netflix,
    a microservice-based cloud video rental service, and Etsy, a monolithic e-commerce
    platform, are both examples of successful live production systems (see an interesting
    Twitter discussion link in the *References* section later in the chapter). Therefore,
    processes and agility are also key to a successful production system.
  prefs: []
  type: TYPE_NORMAL
- en: Best practices and principles
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As we have learned from the first chapter, microservices are a lightweight style
    of implementing **Service Oriented Architecture** (**SOA**). On top of that, microservices
    are not strictly defined, which gives you the flexibility of developing microservices
    the way you want and according to need. At the same time, you need to make sure
    that you follow a few of the standard practices and principles to make your job
    easier and implement microservice-based architecture successfully.
  prefs: []
  type: TYPE_NORMAL
- en: Nanoservice, size, and monolithic
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Each microservice in your project should be small in size and perform one functionality
    or feature (for example, user management), independently enough to perform the
    function on its own.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following two quotes from Mike Gancarz (a member who designed the X Window
    system), which defines one of the paramount precepts of Unix philosophy, suits
    the microservice paradigm as well:'
  prefs: []
  type: TYPE_NORMAL
- en: '"Small is beautiful."'
  prefs: []
  type: TYPE_NORMAL
- en: '"Make each program do one thing well."'
  prefs: []
  type: TYPE_NORMAL
- en: Now, how do we define the size, in today's age, when you have a framework (for
    example, Finangle) that reduces the **lines of code** (**LOC**)? In addition,
    many modern languages, such as Python and Erlang, are less verbose. This makes
    it difficult to decide whether you want to make this code microservice or not.
  prefs: []
  type: TYPE_NORMAL
- en: Apparently, you may implement a microservice for a small number of LOC; that
    is actually not a microservice but a nanoservice.
  prefs: []
  type: TYPE_NORMAL
- en: 'Arnon Rotem-Gal-Oz defined a nanoservice as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '"Nanoservice is an antipattern where a service is too fine-grained. A nanoservice
    is a service whose overhead (communications, maintenance, and so on) outweighs
    its utility."'
  prefs: []
  type: TYPE_NORMAL
- en: Therefore, it always makes sense to design microservices based on functionality.
    Domain-driven design makes it easier to define functionality at a domain level.
  prefs: []
  type: TYPE_NORMAL
- en: As discussed previously, the size of your project is a key factor when deciding
    whether to implement microservices or determining the number of microservices
    you want to have for your project. In a simple and small project, it makes sense
    to use monolithic architecture. For example, based on the domain design that we
    learned in [Chapter 3](8d3fd180-4f27-4bf7-bb86-c180ac200687.xhtml), *Domain-Driven
    Design*, you would get a clear understanding of your functional requirements and
    it makes facts available to draw the boundaries between various functionalities
    or features. For example, in the sample project (online table reservation system;
    OTRS) we have implemented, it is very easy to develop the same project using monolithic
    design, provided you don't want to expose the APIs to the customer, or you don't
    want to use it as SaaS, or there are plenty of similar parameters that you want
    to evaluate before making a call.
  prefs: []
  type: TYPE_NORMAL
- en: You can migrate the monolithic project to a microservices design later, when
    the need arises. Therefore, it is important that you should develop the monolithic
    project in modular fashion and have the loose coupling at every level and layer,
    and ensure there are predefined contact points and boundaries between different
    functionalities and features. In addition, your data source, such as DB, should
    be designed accordingly. Even if you are not planning to migrate to a microservice-based
    system, it would make bug fixes and enhancement easier to implement.
  prefs: []
  type: TYPE_NORMAL
- en: Paying attention to the previous points will mitigate any possible difficulties
    you may encounter when you migrate to microservices.
  prefs: []
  type: TYPE_NORMAL
- en: Generally, large or complex projects should be developed using microservices-based
    architecture, due to the many advantages it provides, as discussed in previous
    chapters.
  prefs: []
  type: TYPE_NORMAL
- en: I even recommend developing your initial project as monolithic; once you gain
    a better understanding of project functionalities and project complexity, then
    you can migrate it to microservices. Ideally, a developed initial prototype should
    give you the functional boundaries that will enable you to make the right choice.
  prefs: []
  type: TYPE_NORMAL
- en: Continuous integration and deployment
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: You must have a continuous integration and deployment process in place. It gives
    you the edge to deliver changes faster and detect bugs early. Therefore, each
    service should have its own integration and deployment process. In addition, it
    must be automated. There are many tools available, such as Teamcity, Jenkins,
    and so on, that are used widely. It helps you to automate the build process—which
    catches build failure early, especially when you integrate your changes with the
    mainline (like either any release branch/tag or master branch).
  prefs: []
  type: TYPE_NORMAL
- en: You can also integrate your tests with each automated integration and deployment
    process. **Integration testing** tests the interactions of different parts of
    the system, such as between two interfaces (API provider and consumer), or between
    different components, or modules in a system, such as between DAO and database,
    and so on. Integration testing is important as it tests the interfaces between
    the modules. Individual modules are first tested in isolation. Then, integration
    testing is performed to check the combined behavior and validate that requirements
    are implemented correctly. Therefore, in microservices, integration testing is
    a key tool to validate the APIs. We will cover more about this in the next section.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, you can see the updated mainline changes on your CD (continuous deployment)
    machine where this process deploys the build.
  prefs: []
  type: TYPE_NORMAL
- en: 'The process does not end here: you can make a container, such as Docker, and
    hand it over to your WebOps team, or have a separate process that delivers to
    a configured location or deploys to a WebOps stage environment. From here, it
    could be deployed directly to your production system once approved by the designated
    authority.'
  prefs: []
  type: TYPE_NORMAL
- en: System/end-to-end test automation
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Testing is a very important part of any product and service delivery. You do
    not want to deliver buggy applications to customers. Earlier, at the time when
    the waterfall model was popular, an organization used to take 1 to 6 months or
    more for the testing stage before delivering to the customer. In recent years,
    after the agile process became popular, more emphasis is given to automation.
    Similar to prior point testing, automation is also mandatory.
  prefs: []
  type: TYPE_NORMAL
- en: Whether you follow **test-driven development** (**TDD**) or not, we must have
    system or end-to-end test automation in place. It's very important to test your
    business scenarios and that is also the case with end-to-end testing that may
    start from your REST call to database checks, or from UI app to database checks.
  prefs: []
  type: TYPE_NORMAL
- en: Also, it is important to test your APIs if you have public APIs.
  prefs: []
  type: TYPE_NORMAL
- en: Doing this makes sure that any change does not break any of the functionality
    and ensures seamless, bug-free production delivery. As discussed in the last section,
    each module is tested in isolation using unit testing to check everything is working
    as expected, then integration testing is performed between different modules to
    check the expected combined behavior and validate the requirements, whether implemented
    correctly or not. After integration tests, functional tests are executed that
    validate the functional and feature requirements.
  prefs: []
  type: TYPE_NORMAL
- en: So, if unit testing makes sure individual modules are working fine in isolation,
    integration testing makes sure that interaction among different modules works
    as expected. If unit tests are working fine, it implies that the chances of integration
    test failure is greatly reduced. Similarly, integration testing ensures that functional
    testing is likely to be successful.
  prefs: []
  type: TYPE_NORMAL
- en: It is presumed that one always keeps all types of tests updated, whether these
    are unit-level tests or end-to-end test scenarios.
  prefs: []
  type: TYPE_NORMAL
- en: Self-monitoring and logging
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A microservice should provide service information about itself and the state
    of the various resources it depends on. Service information represents statistics
    such as the average, minimum, and maximum time to process a request, the number
    of successful and failed requests, being able to track a request, memory usage,
    and so on.
  prefs: []
  type: TYPE_NORMAL
- en: 'Adrian Cockcroft highlighted a few practices which are very important for monitoring
    microservices at Glue Conference (Glue Con) 2015\. Most of them are valid for
    any monitoring system:'
  prefs: []
  type: TYPE_NORMAL
- en: Spend more time working on code that analyzes the meaning of metrics than code
    that collects, moves, stores, and displays metrics. This helps to not only increase
    the productivity, but also provide important parameters to fine-tune the microservices
    and increase the system efficiency. The idea is to develop more analysis tools
    rather than developing more monitoring tools.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The metric to display latency needs to be less than the human attention span.
    That means less than 10 seconds, according to Adrian.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Validate that your measurement system has enough accuracy and precision. Collect
    histograms of response time.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Accurate data makes decision-making faster and allows you to fine-tune untill
    you reach precision level. He also suggests that the best graph to show the response
    time is a histogram.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Monitoring systems need to be more available and scalable than the systems being
    monitored.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The statement says it all: you cannot rely on a system which itself is not
    stable or available 24/7.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Optimize for distributed, ephemeral, cloud-native, containerized microservices.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Fit metrics to models to understand relationships.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Monitoring is a key component of microservice architecture. You may have a dozen
    to thousands of microservices (true for a big enterprise's large project) based
    on project size. Even for scaling and high availability, organizations create
    a clustered or load balanced pool/pod for each microservice, even separate pools
    for each microservice based on versions. Ultimately, it increases the number of
    resources you need to monitor, including each microservice instance. In addition,
    it is important that you have a process in place so that whenever something goes
    wrong, you know it immediately, or better, receive a warning notification in advance
    before something goes wrong. Therefore, effective and efficient monitoring is
    crucial for building and using the microservice architecture. Netflix uses security
    monitoring using tools such as Netflix Atlas (real-time operational monitoring
    which processes 1.2 billion metrics), Security Monkey (for monitoring security
    on AWS-based environments), Scumblr (intelligence-gathering tool) and FIDO (for
    analyzing events and automated incident reporting).
  prefs: []
  type: TYPE_NORMAL
- en: Logging is another important aspect for microservices that should not be ignored.
    Having effective logging makes all the difference. As there could be 10 or more
    microservices, managing logging is a huge task.
  prefs: []
  type: TYPE_NORMAL
- en: For our sample project, we have used **Mapped Diagnostic Context** (**MDC**)
    logging, which is sufficient, in a way, for individual microservice logging. However,
    we also need logging for an entire system, or central logging. We also need aggregated
    statistics of logs. There are tools that do the job, such as Loggly or Logspout.
  prefs: []
  type: TYPE_NORMAL
- en: A request and generated correlated events gives you an overall view of the request.
    For tracing of any event and request, it is important to associate the event and
    request with service ID and request ID respectively. You can also associate the
    content of the event, such as message, severity, class name, and so on, to service
    ID.
  prefs: []
  type: TYPE_NORMAL
- en: A separate data store for each microservice
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: If you remember, the most important characteristics of microservices you can
    find out about is the way microservices run in isolation from other microservices,
    most commonly as standalone applications.
  prefs: []
  type: TYPE_NORMAL
- en: Abiding by this rule, it is recommended that you do not use the same database,
    or any other data store across multiple microservices. In large projects, you
    may have different teams working on the same project, and you want the flexibility
    to choose the database for each microservice that best suits the microservice.
  prefs: []
  type: TYPE_NORMAL
- en: Now, this also brings some challenges.
  prefs: []
  type: TYPE_NORMAL
- en: For instance, the following is relevant to teams who may be working on different
    microservices within the same project, if that project shares the same database
    structure. There is a possibility that a change in one microservice may impact
    the other microservice models. In such cases, change in one may affect the dependent
    microservice, so you also need to change the dependent model structure.
  prefs: []
  type: TYPE_NORMAL
- en: To resolve this issue, microservices should be developed based on an API-driven
    platform. Each microservice would expose its APIs, which could be consumed by
    the other microservices. Therefore, you also need to develop the APIs, which is
    required for the integration of different microservices.
  prefs: []
  type: TYPE_NORMAL
- en: Similarly, due to different data stores, actual project data is also spread
    across multiple data stores and it makes data management more complicated, because
    the separate storage systems can more easily get out of sync or become inconsistent,
    and foreign keys can change unexpectedly. To resolve such an issue, you need to
    use **master data management** (**MDM**) tools. MDM tools operate in the background
    and fix inconsistencies if they find any. For the OTRS sample example, it might
    check every database that stores booking request IDs, to verify that the same
    IDs exist in all of them (in other words, that there aren't any missing or extra
    IDs in any one database). MDM tools available in the market include Informatica,
    IBM MDM Advance Edition, Oracle Siebel UCM, Postgres (master streaming replication),
    mariadb (master/master configuration), and so on.
  prefs: []
  type: TYPE_NORMAL
- en: If none of the existing products suits your requirements, or you are not interested
    in any proprietary product, then you can write your own. Presently, API-driven
    development and platforms reduce such complexities; therefore, it is important
    that microservices should be developed along with an API platform.
  prefs: []
  type: TYPE_NORMAL
- en: Transaction boundaries
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We went through domain-driven design concepts in [Chapter 3](8d3fd180-4f27-4bf7-bb86-c180ac200687.xhtml),
    *Domain-Driven Design*. Please review this if you have not grasped it thoroughly,
    as it gives you an understanding of the state vertically. Since we are focusing
    on microservice-based design, the result is that we have a system of systems,
    where each microservice represents a system. In this environment, finding the
    state of a whole system at any given point in time is very challenging. If you
    are familiar with distributed applications, then you may be comfortable in such
    an environment, with respect to state.
  prefs: []
  type: TYPE_NORMAL
- en: It is very important to have transaction boundaries in place that describe which
    microservice owns a message at any given time. You need a way or process that
    can participate in transactions, transacted routes, and error handlers, idempotent
    consumers, and compensating actions. It is not an easy task to ensure transactional
    behavior across heterogeneous systems, but there are tools available that do the
    job for you.
  prefs: []
  type: TYPE_NORMAL
- en: For example, Camel has great transactional capabilities that help developers
    easily create services with transactional behavior.
  prefs: []
  type: TYPE_NORMAL
- en: Microservices frameworks and tools
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: It is always better not to reinvent the wheel. Therefore, we would like to explore
    what tools are already available and provide the platform, framework, and features
    that make microservice development and deployment easier.
  prefs: []
  type: TYPE_NORMAL
- en: 'Throughout the book, we have used Spring Cloud extensively, due to the same
    reason: it provides all of the tools and platforms required to make microservice
    development very easy. Spring Cloud uses Netflix **Open Source Software** (**OSS**).
    Let us explore Netflix OSS—a complete package.'
  prefs: []
  type: TYPE_NORMAL
- en: I have also added a brief overview about how each tool will help to build good
    microservice architecture.
  prefs: []
  type: TYPE_NORMAL
- en: Netflix Open Source Software (OSS)
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Netflix OSS center is the most popular and widely used open source software
    for Java-based microservice open source projects. The world's most successful
    video renting service is dependent on it. Netflix has more than 40 million users
    and is used across the globe. Netflix is a pure cloud-based solution, developed
    on microservice-based architecture. You can say that whenever anybody talks about
    microservices, Netflix is the first name that comes to mind. Let us discuss the
    wide variety of tools it provides. We have already discussed many of them while
    developing the sample OTRS application. However, there are a few which we have
    not explored. Here, we'll cover only the overview of each tool, instead of going
    into detail. It will give you an overall idea of the practical characteristics
    of microservice architecture and its use in the cloud.
  prefs: []
  type: TYPE_NORMAL
- en: Build - Nebula
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Netflix Nebula is a collection of Gradle plugins that makes your microservice
    builds easier using Gradle (a Maven-like build tool). For our sample project,
    we have made use of Maven, therefore we haven't had the opportunity to explore
    Nebula in this book. However, exploring it would be fun. The most significant
    Nebula feature for developers is eliminating the boilerplate code in Gradle build
    files, which allows developers to focus on coding.
  prefs: []
  type: TYPE_NORMAL
- en: Having a good build environment, especially CI/CD (continuous integration and
    continuous deployment) is a must for microservice development and keeping aligned
    with agile development. Netflix Nebula makes your build easier and more efficient.
  prefs: []
  type: TYPE_NORMAL
- en: Deployment and delivery - Spinnaker with Aminator
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Once your build is ready, you want to move that build to **Amazon Web Services**
    (**AWS**) EC2\. Aminator creates and packages images of builds in the form of
    **Amazon Machine Image** (**AMI**). Spinnaker then deploys these AMIs to AWS.
  prefs: []
  type: TYPE_NORMAL
- en: Spinnaker is a continuous delivery platform for releasing code changes with
    high velocity and efficiency. Spinnaker also supports other cloud services, such
    as Google Computer Engine and Cloud Foundry.
  prefs: []
  type: TYPE_NORMAL
- en: If you would like to deploy your latest microservice builds to cloud environments
    such as EC2, Spinnaker and Aminator help you to do that in an autonomous way.
  prefs: []
  type: TYPE_NORMAL
- en: Service registration and discovery - Eureka
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Eureka, as we have explored in this book, provides a service that is responsible
    for microservice registration and discovery. On top of that, Eureka is also used
    for load balancing the middle tier (processes hosting different microservices).
    Netflix also uses Eureka, along with other tools, such as Cassandra or memcached,
    to enhance its overall usability.
  prefs: []
  type: TYPE_NORMAL
- en: Service registration and discovery is a must for microservice architecture.
    Eureka serves this purpose. Please refer to [Chapter 4](4561ba72-866e-45f9-88ac-761a62242e26.xhtml),
    *Implementing a Microservice*, for more information about Eureka.
  prefs: []
  type: TYPE_NORMAL
- en: Service communication - Ribbon
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Microservice architecture is of no use if there is no interprocess or service
    communication. The Ribbon application provides this feature. Ribbon works with
    Eureka for load balancing and with Hystrix for fault tolerance or circuit breaker
    operations.
  prefs: []
  type: TYPE_NORMAL
- en: Ribbon also supports TCP and UDP protocols, apart from HTTP. It provides these
    protocol supports in both asynchronous and reactive models. It also provides the
    caching and batching capabilities.
  prefs: []
  type: TYPE_NORMAL
- en: Since you will have many microservices in your project, you need a way to process
    information using interprocess or service communication. Netflix provides the
    Ribbon tool for this purpose.
  prefs: []
  type: TYPE_NORMAL
- en: Circuit breaker - Hystrix
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Hystrix tool is for circuit breaker operations, that is, latency and fault tolerance.
    Therefore, Hystrix stops cascading failures. Hystrix performs the real-time operations
    for monitoring the services and property changes, and supports concurrency.
  prefs: []
  type: TYPE_NORMAL
- en: Circuit breaker, or fault tolerance, is an important concept for any project,
    including microservices. Failure of one microservice should not halt your entire
    system; to prevent this, and provide meaningful information to the customer on
    failure, is the job of Netflix Hystrix.
  prefs: []
  type: TYPE_NORMAL
- en: Edge (proxy) server - Zuul
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Zuul is an edge server or proxy server, and serves the requests of external
    applications such as UI client, Android/iOS application, or any third-party consumer
    of APIs offered by the product or service. Conceptually, it is a door to external
    applications.
  prefs: []
  type: TYPE_NORMAL
- en: Zuul allows dynamic routing and monitoring of requests. It also performs security
    operations such as authentication. It can identify authentication requirements
    for each resource and reject any request that does not satisfy them.
  prefs: []
  type: TYPE_NORMAL
- en: You need an edge server or API gateway for your microservices. Netflix Zuul
    provides this feature. Please refer to [Chapter 5](b1f93b4e-3475-4d8a-8c9f-697b0fd4410c.xhtml),
    *Deployment and Testing,* for more information.
  prefs: []
  type: TYPE_NORMAL
- en: Operational monitoring - Atlas
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Atlas is an operational monitoring tool that provides near-real-time information
    on dimensional time-series data. It captures operational intelligence that provides
    a picture of what is currently happening within a system. It features in-memory
    data storage, allowing it to gather and report very large numbers of metrics very
    quickly. At present, it processes 1.3 billion metrics for Netflix.
  prefs: []
  type: TYPE_NORMAL
- en: Atlas is a scalable tool. This is why it can now process 1.3 billion metrics,
    from 1 million metrics a few years back. Atlas not only provides scalability in
    terms of reading the data, but also aggregating it as a part of graph request.
  prefs: []
  type: TYPE_NORMAL
- en: Atlas uses the Netflix Spectator library for recording dimensional time-series
    data.
  prefs: []
  type: TYPE_NORMAL
- en: Once you deploy microservices in a cloud environment, you need to have a monitoring
    system in place to track and monitor all microservices. Netflix Atlas does this
    job for you.
  prefs: []
  type: TYPE_NORMAL
- en: Reliability monitoring service - Simian Army
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In Cloud, no single component can guarantee 100% uptime. Therefore, it is a
    requirement for successful microservice architecture to make the entire system
    available in case a single cloud component fails. Netflix has developed a tool
    named Simian Army to avoid system failure. Simian Army keeps a cloud environment
    safe, secure, and highly available. To achieve high availability and security,
    it uses various services (Monkeys) in the cloud for generating various kinds of
    failures, detecting abnormal conditions, and testing the cloud's ability to survive
    these challenges.
  prefs: []
  type: TYPE_NORMAL
- en: 'It uses the following services (Monkeys), which are taken from the Netflix
    blog:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Chaos Monkey**: Chaos Monkey is a service which identifies groups of systems
    and randomly terminates one of the systems in a group. The service operates at
    a controlled time and interval. Chaos Monkey only runs in business hours with
    the intent that engineers will be alert and able to respond.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Janitor Monkey**: Janitor Monkey is a service which runs in the AWS cloud
    looking for unused resources to clean up. It can be extended to work with other
    cloud providers and cloud resources. The schedule of service is configurable.
    Janitor Monkey determines whether a resource should be a cleanup candidate, by
    applying a set of rules on it. If any of the rules determines that the resource
    is a cleanup candidate, Janitor Monkey marks the resource and schedules a time
    to clean it up. For exceptional cases, when you want to keep an unused resource
    longer, before Janitor Monkey deletes a resource, the owner of the resource will
    receive a notification a configurable number of days ahead of the cleanup time.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Conformity Monkey**: Conformity Monkey is a service which runs in the AWS
    cloud looking for instances that are not conforming to predefined rules for the
    best practices. It can be extended to work with other cloud providers and cloud
    resources. The schedule of service is configurable. If any of the rules determines
    that the instance is not conforming, the monkey sends an email notification to
    the owner of the instance. There could be exceptional cases where you want to
    ignore warnings of a specific conformity rule for some applications.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Security Monkey**: Security Monkey monitors policy changes and alerts on
    insecure configurations in an AWS account. The main purpose of Security Monkey
    is security, though it also proves a useful tool for tracking down potential problems,
    as it is essentially a change-tracking system.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Successful microservice architecture makes sure that your system is always up,
    and failure of a single cloud component should not fail the entire system. Simian
    Army uses many services to achieve high availability.
  prefs: []
  type: TYPE_NORMAL
- en: AWS resource monitoring - Edda
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In a cloud environment, nothing is static. For example, virtual host instances
    change frequently, an IP address could be reused by various applications, or a
    firewall or related changes may take place.
  prefs: []
  type: TYPE_NORMAL
- en: Edda is a service that keeps track of these dynamic AWS resources. Netflix named
    it Edda (meaning *a tale of Norse mythology*), as it records the tales of cloud
    management and deployments. Edda uses the AWS APIs to poll AWS resources and records
    the results. These records allow you to search and see how the cloud has changed
    over time. For instance, if any host of the API server is causing any issue, then
    you need to find out what that host is and which team is responsible for it.
  prefs: []
  type: TYPE_NORMAL
- en: 'These are the features it offers:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Dynamic querying**: Edda provides the REST APIs, and it supports the matrix
    arguments and provides fields selectors that let you retrieve only the desired
    data.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**History**/c**hanges**: Edda maintains the history of all AWS resources. This
    information helps you when you analyze the causes and impact of outage. Edda can
    also provide the different view of current and historical information about resources.
    It stores the information in MongoDB at the time of writing.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Configuration**: Edda supports many configuration options. In general, you
    can poll information from multiple accounts and multiple regions and can use the
    combination of account and regions that account points. Similarly, it provides
    different configurations for AWS, Crawler, Elector, and MongoDB.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If you are using the AWS for hosting your microservice-based product, then Edda
    serves the purpose of monitoring the AWS resources.
  prefs: []
  type: TYPE_NORMAL
- en: On-host performance monitoring - Vector
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Vector is a static web application and runs inside a web browser. It allows
    it to monitor the performance of those hosts where **Performance Co-Pilot** (**PCP**)
    is installed. Vector supports PCP version 3.10+. PCP collects metrics and makes
    them available to Vector.
  prefs: []
  type: TYPE_NORMAL
- en: It provides high-resolution right metrics available on demand. This helps engineers
    to understand how a system behaves and correctly troubleshoot performance issues.
  prefs: []
  type: TYPE_NORMAL
- en: Vector is a monitoring tool that helps you to monitor the performance of a remote
    host.
  prefs: []
  type: TYPE_NORMAL
- en: Distributed configuration management - Archaius
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Archaius is a distributed configuration management tool that allows you to
    do the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Use dynamic and typed properties.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Perform thread-safe configuration operations.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Check for property changes using a polling framework.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Use a callback mechanism in an ordered hierarchy of configurations.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Inspect and perform operations on properties using JConsole, as Archaius provides
    the JMX MBean.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A good configuration management tool is required when you have a microservice-based
    product. Archaius helps to configure different types of properties in a distributed
    environment.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Scheduler for Apache Mesos - Fenzo
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Fenzo is a scheduler library for Apache Mesos frameworks written in Java. Apache
    Mesos frameworks match and assign resources to pending tasks. The following are
    its key features:'
  prefs: []
  type: TYPE_NORMAL
- en: It supports long-running service style tasks and for batch
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It can auto-scale the execution host cluster, based on resource demands
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It supports plugins that you can create based on requirements
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You can monitor resource-allocation failures, which allows you to debug the
    root cause
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Cost and cloud utilization - Ice
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Ice provides a bird's-eye view of cloud resources from a cost and usage perspective.
    It provides the latest information about provisioned cloud resource allocation
    to different teams that adds value for optimal utilization of the cloud resources.
  prefs: []
  type: TYPE_NORMAL
- en: Ice is a grail project. Users interact with the Ice UI component that displays
    the information sent via the Ice reader component. The reader fetches information
    from the data generated by the Ice processor component. The Ice processor component
    reads data information from a detailed cloud billing file and converts it into
    data that is readable by the Ice reader component.
  prefs: []
  type: TYPE_NORMAL
- en: Other security tools - Scumblr and FIDO
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Along with Security Monkey, Netflix OSS also makes use of Scumblr and **Fully
    Integrated Defense** **Operation** (**FIDO**) tools.
  prefs: []
  type: TYPE_NORMAL
- en: To keep track of and protect your microservices from regular threats and attacks,
    you need an automated way to secure and monitor your microservices. Netflix Scumblr
    and FIDO do this job for you.
  prefs: []
  type: TYPE_NORMAL
- en: Scumblr
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Scumblr is a Ruby on Rails based web application that allows you to perform
    periodic searches and store/take action on the identified results. Basically,
    it gathers intelligence that leverages internet-wide targeted searches to surface
    specific security issues for investigation.
  prefs: []
  type: TYPE_NORMAL
- en: 'Scumblr makes use of the Workflowable gem to allow flexible workflows to be
    set up for different types of results. Scumblr searches utilize plugins called
    **Search Providers**. It checks anomalies such as the following. Since it is extensible,
    you can add as many as you want:'
  prefs: []
  type: TYPE_NORMAL
- en: Compromised credentials
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Vulnerability/hacking discussion
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Attack discussion
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Security-relevant social media discussion
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Fully Integrated Defence Operation (FIDO)
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: FIDO is a security orchestration framework for analyzing events and automating
    incident responses. It automates the incident response process by evaluating,
    assessing, and responding to malware. FIDO's primary purpose is to handle the
    heavy manual effort needed to evaluate threats coming from today's security stack
    and the large number of alerts generated by them.
  prefs: []
  type: TYPE_NORMAL
- en: 'As an orchestration platform, FIDO can make using your existing security tools
    more efficient and accurate by heavily reducing the manual effort needed to detect,
    notify, and respond to attacks against a network. For more information, you can
    refer to the following links:'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://github.com/Netflix/Fido](https://github.com/Netflix/Fido)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[https://github.com/Netflix](https://github.com/Netflix)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: References
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Monolithic (Etsy) versus Microservices (Netflix) Twitter discussion: [https://twitter.com/adrianco/status/441169921863860225](https://twitter.com/adrianco/status/441169921863860225)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Monitoring Microservice and Containers Presentation* by Adrian Cockcroft:
    [http://www.slideshare.net/adriancockcroft/gluecon-monitoring-microservices-and-containers-a-challenge](http://www.slideshare.net/adriancockcroft/gluecon-monitoring-microservices-and-containers-a-challenge)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Nanoservice Antipattern: [http://arnon.me/2014/03/services-microservices-nanoservices/](http://arnon.me/2014/03/services-microservices-nanoservices/%20)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Apache Camel for Micro­service Architectures: [https://www.javacodegeeks.com/2014/09/apache-camel-for-micro%C2%ADservice-architectures.html](https://www.javacodegeeks.com/2014/09/apache-camel-for-micro%C2%ADservice-architectures.html)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Teamcity: [https://www.jetbrains.com/teamcity/](https://www.jetbrains.com/teamcity/)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Jenkins: [https://jenkins-ci.org/](https://jenkins-ci.org/)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Loggly: [https://www.loggly.com/](https://www.loggly.com/)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we have explored various practices and principles which are
    best-suited for microservice-based products and services. Microservice architecture
    is a result of cloud environments, which are being used widely in comparison to
    on-premises-based monolithic systems. We have identified a few of the principles
    related to size, agility, and testing, that have to be in place for successful
    implementation.
  prefs: []
  type: TYPE_NORMAL
- en: We have also got an overview of different tools used by Netflix OSS for the
    various key features required for successful implementation of microservice-architecture-based
    products and services. Netflix offers a video rental service, using the same tools
    successfully.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, readers may encounter issues and they may get stuck on
    those problems. The chapter explains the common problems encountered during the
    development of microservices, and their solutions.
  prefs: []
  type: TYPE_NORMAL
