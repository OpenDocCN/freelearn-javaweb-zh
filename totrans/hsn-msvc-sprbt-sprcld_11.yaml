- en: Adding Service Discovery Using Netflix Eureka and Ribbon
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we will learn how to use Netflix Eureka as a discovery server
    for microservices based on Spring Boot. To allow our microservices to communicate
    with Netflix Eureka, we will use the Spring Cloud module for Netflix Eureka clients.
    Before we delve into the details, we will elaborate on why a discovery server
    is needed and why a DNS server isn't sufficient.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following topics will be covered in this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: Introduction to service discovery
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The problem with DNS-based service discovery
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Challenges with service discovery
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Service discovery with Netflix Eureka in Spring Cloud
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Setting up a Netflix Eureka server
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Connecting microservices to a Netflix Eureka server
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Setting up configuration for use in the development process
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Trying out the discovery service
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Introducing service discovery
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The concept of service discovery was described in [Chapter 1](282e7b49-42b8-4649-af81-b4b6830d391d.xhtml),
    *Introduction to Microservices*; please refer to the *Service discovery* section for
    more information. Netflix Eureka was introduced as a discovery service in [Chapter
    8](9878a36a-5760-41a4-a132-1a2387b61037.xhtml), *Introduction to Spring Cloud*;
    please refer to the *Netflix Eureka as a discovery service* section for more information.
    Before we jump into the implementation details, we will look at the following
    topics:'
  prefs: []
  type: TYPE_NORMAL
- en: The problem with DNS-based service discovery
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Challenges with service discovery
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Service discovery with Netflix Eureka in Spring Cloud
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The problem with DNS-based service discovery
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: So, what's the problem?
  prefs: []
  type: TYPE_NORMAL
- en: Why can't we simply start new instances of a microservice and rely on round-robin
    DNS? In essence, given that the microservice instances have the same DNS name,
    the DNS server will resolve it to a list of IP addresses for the available instances.
    Due to this, the client can call the service instances in a round-robin fashion.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s try it out and see what happens, shall we? Follow these steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Assuming that you have followed the instructions from [Chapter 7](436fb8c1-0c4d-410c-a3ec-da251aba4ca1.xhtml),
    *Developing Reactive Microservices*, start the system landscape and insert some
    test data with the following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'Scale up the `review` microservice to two instances:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'Ask the composite product service for the IP addresses it finds for the `review`
    microservice:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'Expect an answer like the following:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: Great, the composite product service sees two IP addresses—in my case, `172.19.0.8`
    and `172.19.0.9`—one for each instance of the `review` microservice instances!
  prefs: []
  type: TYPE_NORMAL
- en: 'If you want to, you can verify that these are the correct IP addresses by using
    the following commands:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: The last line in the output from each command should contain one of the IP addresses,
    as shown in the preceding code.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let''s try out a couple of calls to the composite product service and
    see whether it uses both instances of the `review` microservice:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'Unfortunately, we will only get responses from one of the microservice instances,
    as in this example:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/70f0682d-4f5b-4fae-a1a0-d96ea3c3c254.png)'
  prefs: []
  type: TYPE_IMG
- en: That was disappointing!
  prefs: []
  type: TYPE_NORMAL
- en: Okay, so what is going on here?
  prefs: []
  type: TYPE_NORMAL
- en: A DNS client typically caches the resolved IP addresses and hangs on to the
    first working IP address it tries out when it receives a list of IP addresses
    that have been resolved for a DNS name. Neither the DNS servers nor the DNS protocol
    is well-suited for handling volatile microservices instances that come and go
    all of the time. Because of this, DNS-based service discovery isn't very appealing
    from a practical standpoint.
  prefs: []
  type: TYPE_NORMAL
- en: Using Spring Cloud Config for centralized configuration
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: To manage the configuration of a system landscape of microservices, Spring Cloud
    contains Spring Cloud Config, which provides the centralized management of configuration
    files according to the requirements described in [Chapter 1](282e7b49-42b8-4649-af81-b4b6830d391d.xhtml),
    *Introduction to Microservices*, in the *Central configuration* section.
  prefs: []
  type: TYPE_NORMAL
- en: 'Spring Cloud Config supports storing configuration files in a number of different
    backends, such as the following:'
  prefs: []
  type: TYPE_NORMAL
- en: A Git repository, for example, on GitHub or Bitbucket
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Local filesystem
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: HashiCorp Vault
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A JDBC database
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Spring Cloud Config allows us to handle configuration in a hierarchical structure;
    for example, we can place common parts of the configuration in a common file and
    microservice-specific settings in separate configuration files.
  prefs: []
  type: TYPE_NORMAL
- en: Spring Cloud Config also supports detecting changes in the configuration and
    pushing notifications to the affected microservices. It uses **Spring Cloud Bus**
    to transport the notifications. Spring Cloud Bus is an abstraction on top of Spring
    Cloud Stream that we already are familiar with; that is, it supports the use of
    either RabbitMQ or Kafka as the messaging system for transporting notifications
    out of the box.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following diagram illustrates the cooperation between Spring Cloud Config,
    its clients, a Git repository, and Spring Cloud Bus:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/a6dc8c02-132d-482d-bf64-2b2994b29eca.png)'
  prefs: []
  type: TYPE_IMG
- en: 'The diagram shows the following:'
  prefs: []
  type: TYPE_NORMAL
- en: When the microservices starts up, they ask the configuration server for its
    configuration.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The configuration server gets the configuration from, in this case, a Git repository.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Optionally, the Git repository can be configured to send notifications to the configuration
    server when Git commits are pushed to the Git repository.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The configuration server will publish change events using Spring Cloud Bus.
    The microservices that are affected by the change will react and retrieve its
    updated configuration from the configuration server.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Finally, Spring Cloud Config also supports the encryption of sensitive information
    in the configuration, such as credentials.
  prefs: []
  type: TYPE_NORMAL
- en: We will learn about Spring Cloud Config in [Chapter 12](a250774a-03a1-41b1-b935-cbeb9624b6e3.xhtml),
    *Centralized Configuration*.
  prefs: []
  type: TYPE_NORMAL
- en: With Spring Cloud Config introduced, let's get introduced to how to use Resilience4j
    for improved resilience.
  prefs: []
  type: TYPE_NORMAL
- en: Using Resilience4j for improved resilience
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As we already mentioned in [Chapter 1](282e7b49-42b8-4649-af81-b4b6830d391d.xhtml), *Introduction
    to Microservices*, in the*Circuit breaker* section, things go wrong occasionally.
    In a fairly large-scaled system landscape of cooperating microservices, we must
    assume that there is something going wrong all of the time. Failures must be seen
    as a normal state, and the system landscape must be designed to handle it!
  prefs: []
  type: TYPE_NORMAL
- en: Initially, Spring Cloud came with Netflix Hystrix, a well-proven circuit breaker.
    But since the Spring Cloud Greenwich release, it is recommended to replace Netflix
    Hystrix with Resilience4j. The reason for this is that Netflix recently put Hystrix
    into maintenance mode. For more details, see [https://github.com/Netflix/Hystrix#hystrix-status](https://github.com/Netflix/Hystrix#hystrix-status).
  prefs: []
  type: TYPE_NORMAL
- en: '**Resilience4j** is an open source-based fault tolerance library. You can discover
    more about it at [https://github.com/resilience4j/resilience4j](http://resilience4j.github.io/resilience4j/).
    It comes with the following fault tolerance mechanisms built-in:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Circuit breaker** is used to prevent a chain of failure reactions if a remote
    service stops to respond.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Rate limiter** is used to limit the number of requests to service during
    a specified time period.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Bulkhead** is used to limit the number of concurrent requests to a service.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Retries** is used to handle random errors that might happen from time to
    time.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Timeout** is used to avoid waiting too long for a response from slow or not
    responding service.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'In [Chapter 13](23795d34-4068-4961-842d-989cde26b642.xhtml), *Improving Resilience
    Using Resilience4j*, we will focus on the circuit breaker in Resilience4j.It follows
    the classic design of a circuit breaker, as illustrated in the following state
    diagram:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/39bdb1ab-dd3a-4238-8fe8-9b112d5f2125.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Let''s take a look at the state diagram in more detail:'
  prefs: []
  type: TYPE_NORMAL
- en: A circuit breaker starts as **Closed**, that is, allowing requests to be processed.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: As long as the requests are processed successfully, it stays in the **Closed**
    state.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If failures start to happen, a counter starts to count up.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If a configured threshold of failures is reached, the circuit breaker will **trip**,
    that is, go to the **Open** state, not allowing further requests to be processed.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Instead, a request will **fast fail**, that is, return immediately with an exception.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: After a configurable time, the circuit breaker will enter a **Half Open** state
    and allow one request to go through, such as a probe, to see whether the failure
    has been resolved.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If the probe request fails, the circuit breaker goes back to the **Open** state.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If the probe request succeeds, the circuit breaker goes to the initial **Closed**
    state, that is, allowing new requests to be processed.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Sample usage of the circuit breaker in Resilience4j
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Let's assume we have a REST service that is protected by a circuit breaker via Resilience4j
    called `myService`.
  prefs: []
  type: TYPE_NORMAL
- en: If the service starts to produce internal errors, for example, because it can't
    reach a service it depends on, we might get a response from the service such as `500
    Internal Server Error`. After a number of configurable attempts, the circuit will
    open and we will get a fast failure that returns an error message such as `CircuitBreaker
    'myService' is open`. When the error is resolved and we make a new attempt (after
    the configurable wait time), the circuit breaker will allow a new attempt as a
    probe. If the call succeeds, the circuit breaker will be closed again; that is,
    it is operating normally.
  prefs: []
  type: TYPE_NORMAL
- en: 'When using Resilience4j together with Spring Boot, we will be able to monitor
    the state of the circuit breakers in a microservice using its Spring Boot Actuator
    `health` endpoint. We can, for example, use `curl` to see the state of the circuit
    breaker, that is, `myService`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'If it operates normally, that is, the circuit is `closed`, it will respond
    with something such as the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/3fb19393-c8f6-46e4-a14b-f0850f75131e.png)'
  prefs: []
  type: TYPE_IMG
- en: 'If something is wrong and the circuit is **open**, it will respond with something
    such as the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/0256fdb6-55bb-4ad8-9e24-532f801c9916.png)'
  prefs: []
  type: TYPE_IMG
- en: With Resilience4j and specifically its circuit breaker introduced, we have seen
    an example of how the circuit breaker can be used to handle errors for a REST
    client. Let's get introduced to how to use Spring Cloud Sleuth and Zipkin for
    distributed tracing.
  prefs: []
  type: TYPE_NORMAL
- en: Using Spring Cloud Sleuth and Zipkin for distributed tracing
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: To understand what is going on in a distributed system such as a system landscape
    of cooperating microservices, it is crucial to be able to track and visualize
    how requests and messages flow between microservices when processing an external
    call to the system landscape.
  prefs: []
  type: TYPE_NORMAL
- en: Refer to [Chapter 1](282e7b49-42b8-4649-af81-b4b6830d391d.xhtml),* Introduction
    to Microservices*, the *Distributed tracing*section, for more information on this
    subject.
  prefs: []
  type: TYPE_NORMAL
- en: Spring Cloud comes with **Spring Cloud Sleuth**, which can mark requests and
    messages/events that are part of the same processing flow with a common *correlation
    ID*.
  prefs: []
  type: TYPE_NORMAL
- en: Spring Cloud Sleuth can also decorate log messages with correlation IDs to make
    it easier to track log messages from different microservices that come from the
    same processing flow. **Zipkin** is a distributed tracing system ([http://zipkin.io](http://zipkin.io/))
    that Spring Cloud Sleuth can send tracing data to for storage and visualization.
  prefs: []
  type: TYPE_NORMAL
- en: The infrastructure for handling distributed tracing information in Spring Cloud
    Sleuth and Zipkinis based on Google Dapper ([https://ai.google/research/pubs/pub36356](https://ai.google/research/pubs/pub36356)).
    In Dapper, the tracing information from a complete workflow is called a **trace tree**,
    and subparts of the tree, such as the basic units of work, are called **spans**.
    Spans can, in turn, consist of sub-spans, which form the trace tree. A correlation
    ID is called `TraceId`, and a span is identified by its own unique `SpanId`, along
    with `TraceId` of the trace tree it belongs to.
  prefs: []
  type: TYPE_NORMAL
- en: 'Spring Cloud Sleuth can send requests to Zipkin either synchronously over HTTP
    or asynchronously using either RabbitMQ or Kafka. To avoid creating runtime dependencies
    to the Zipkin server from our microservices, we prefer sending trace information
    to Zipkin asynchronously using either RabbitMQ or Kafka. This is illustrated by
    the following diagram:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/0b718675-03d1-4367-8114-0def71168052.png)'
  prefs: []
  type: TYPE_IMG
- en: 'In [Chapter 14](42f456c5-d911-494a-a1ba-4631863068b6.xhtml), *Understanding
    Distributed Tracing*, we will see how we can use Spring Cloud Sleuth and Zipkin
    to trace the processing that goes on in our microservice landscape. The following
    is a screenshot from the Zipkin UI, which visualizes the trace tree that was created
    as a result of processing the creation of an aggregated product:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/6b7b0b09-bac1-4528-ad88-ab30d6410fde.png)'
  prefs: []
  type: TYPE_IMG
- en: An HTTP `POST` request is sent to the product-composite service and responds
    by publishing create events to the topics for products, recommendations, and reviews.
    These events are consumed by the three core microservices in parallel and the
    data in the create events are stored in each microservice's database.
  prefs: []
  type: TYPE_NORMAL
- en: With Spring Cloud Sleuth and Zipkin for distributed tracing being introduced,
    we have seen an example of distributed tracing of the processing of an external
    synchronous HTTP request that includes asynchronous passing of events between
    the involved microservices.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we have seen how Spring Cloud has evolved from being rather
    Netflix OSS-centric to having a much larger scope as of today. We also introduced
    how components from the latest release of Spring Cloud Greenwich can be used to
    implement some of the design patterns we described in [Chapter 1](282e7b49-42b8-4649-af81-b4b6830d391d.xhtml),
    *Introduction to Microservices*, in the *Design patterns for microservices* section.
    These design patterns are required to make a landscape of cooperating microservices
    production-ready.
  prefs: []
  type: TYPE_NORMAL
- en: Head over to the next chapter to see how we can implement service discovery
    using Netflix Eureka and Spring Cloud load balancer!
  prefs: []
  type: TYPE_NORMAL
- en: Questions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: What is the purpose of Netflix Eureka?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What are the main features of Spring Cloud Gateway?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What backends are supported by Spring Cloud Config?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What are the capabilities that Resilience4j provides?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What are the concepts of trace tree and span used for in distributed tracing,
    and what is the paper called that defined them?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: All of the commands that are described in this book have been run on a MacBook
    Pro using macOS Mojave, but it should be straightforward to modify it so that
    it can run on another platform, such as Linux or Windows.
  prefs: []
  type: TYPE_NORMAL
- en: No new tools need to be installed in this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: The source code for this chapter can be found on GitHub: [https://github.com/PacktPublishing/Hands-On-Microservices-with-Spring-Boot-and-Spring-Cloud/tree/master/Chapter09](https://github.com/PacktPublishing/Hands-On-Microservices-with-Spring-Boot-and-Spring-Cloud/tree/master/Chapter09).
  prefs: []
  type: TYPE_NORMAL
- en: 'To be able to run the commands that are described in this book, download the
    source code to a folder and set up an environment variable, `$BOOK_HOME`, that
    points to that folder. Some sample commands are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: The Java source code is written for Java 8 and has been tested on Java 12\.
    This chapter uses Spring Cloud 2.1.0 (also known as the **Greenwich** release),
    Spring Boot 2.1.3, and Spring 5.1.5—that is, the latest available version of the
    Spring components at the time of writing this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: 'The source code contains the following Gradle projects:'
  prefs: []
  type: TYPE_NORMAL
- en: '`api`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`util`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`microservices/product-service`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`microservices/review-service`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`microservices/recommendation-service`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`microservices/product-composite-service`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`spring-cloud/eureka-server`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The code examples in this chapter all come from the source code in the `$BOOK_HOME/Chapter09` directory
    but have been edited in several places in order to remove irrelevant parts of
    the source code, such as comments and import and log statements.
  prefs: []
  type: TYPE_NORMAL
- en: If you want to look at the changes that were applied to the source code in [Chapter
    9](9a514887-19f2-4962-9736-2c0d457bfd9e.xhtml), *Adding Service Discovery Using
    Netflix Eureka and Ribbon*, to see what it took to add Netflix Eureka as a discovery
    service to the microservices landscape, you can compare it with the source code
    for [Chapter 7](436fb8c1-0c4d-410c-a3ec-da251aba4ca1.xhtml), *Developing Reactive
    Microservices*. You can use your favorite `diff` tool and compare the two folders,
    `$BOOK_HOME/Chapter07` and `$BOOK_HOME/Chapter09`, respectively.
  prefs: []
  type: TYPE_NORMAL
- en: Challenges with service discovery
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: So, we need something a bit more powerful than a plain DNS to keep track of
    available microservice instances!
  prefs: []
  type: TYPE_NORMAL
- en: 'We must take the following into consideration when we''re keeping track of
    many small moving parts, that is, microservice instances:'
  prefs: []
  type: TYPE_NORMAL
- en: New instances can start up at any point in time.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Existing instances can stop responding and eventually crash at any point in
    time.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Some of the failing instances might be okay after a while and should start to
    receive traffic again, while others will not and should be removed from the service
    registry.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Some microservice instances might take some time to start up; that is, just
    because they can receive HTTP requests doesn't mean that traffic should be routed
    to them.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Unintended network partitioning and other network-related errors can occur at
    any time.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Building a robust and resilient discovery server is not an easy task, to say
    the least. Let's see how we can use Netflix Eureka to handle these challenges!
  prefs: []
  type: TYPE_NORMAL
- en: Service discovery with Netflix Eureka in Spring Cloud
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Netflix Eureka implements client-side service discovery, meaning that the clients
    run software that talks to the discovery service, Netflix Eureka, to get information
    about the available microservice instances. This is illustrated in the following
    diagram:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/3e46d604-73a8-4747-8af4-23865c058d65.png)'
  prefs: []
  type: TYPE_IMG
- en: 'The process is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Whenever a microservice instance starts up—for example, the **Review** service—it
    registers itself to one of the Eureka servers.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: On a regular basis, each microservice instance sends a heartbeat message to
    the Eureka server, telling it that the microservice instance is okay and is ready
    to receive requests.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Clients—for example, the **Product Composite** service—use a client library
    that regularly asks the Eureka service for information about available services.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: When the client needs to send a request to another microservice, it already
    has a list of available instances in its client library and can pick one of them
    without asking the discovery server. Typically available instances are chosen
    in a round-robin fashion; that is, they are called one after another before the
    first one is called once more.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In [Chapter 17](a9327ecc-49e7-4f72-9221-3321b7158d83.xhtml), *Implementing Kubernetes
    Features as an Alternative*, we will look at an alternative approach to how to
    provide a discovery service using a server-side *service* concept in Kubernetes.
  prefs: []
  type: TYPE_NORMAL
- en: Spring Cloud comes with an abstraction of how to communicate with a discovery
    service such as Netflix Eureka and provides an interface called `DiscoveryClient`.
    This can be used to interact with a discovery service to get information regarding
    available services and instances. Implementations of the `DiscoveryClient` interface
    are also capable of automatically registering a Spring Boot application with the
    discovery server.
  prefs: []
  type: TYPE_NORMAL
- en: Spring Boot can find implementations of the `DiscoveryClient` interface automatically
    during startup, so we only need to bring in a dependency on the corresponding
    implementation to connect to a discovery server. In the case of Netflix Eureka,
    the dependency that's used by our microservices is `spring-cloud-starter-netflix-eureka-client`.
  prefs: []
  type: TYPE_NORMAL
- en: Spring Cloud also has `DiscoveryClient` implementations that support the use
    of either Apache Zookeeper or HashiCorp Consul as a discovery server.
  prefs: []
  type: TYPE_NORMAL
- en: Spring Cloud also comes with an abstraction—the `LoadBalancerClient` interface—for
    clients that want to make requests through a load balancer to registered instances
    in the discovery service. The standard reactive HTTP client, `WebClient`, can
    be configured to use the `LoadBalancerClient` implementation. By adding the `@LoadBalanced`
    annotation to an `@Bean` declaration that returns a `WebClient.Builder` object,
    a `LoadBalancerClient` implementation will be injected into the `Builder` instance
    as `ExchangeFilterFunction`. With the `spring-cloud-starter-netflix-eureka-client` dependency
    on the classpath, `RibbonLoadBalancerClient` will be automatically injected, that
    is, a load balancer based on Netflix Ribbon. So, even though a Netflix Ribbon
    is placed in maintenance mode, as described in [Chapter 8](9878a36a-5760-41a4-a132-1a2387b61037.xhtml),
    *Introduction to Spring Cloud*, it is still used under the hood. Later in this
    chapter in the *Connecting microservices to a Netflix Eureka server *section,
    we will look at some source code examples of how this can be used.
  prefs: []
  type: TYPE_NORMAL
- en: In summary, Spring Cloud makes it very easy to use Netflix Eureka as a discovery
    service. With this introduction to service discovery and its challenges and how
    Netflix Eureka can be used together with Spring Cloud, we are ready to learn how
    to set up a Netflix Eureka server.
  prefs: []
  type: TYPE_NORMAL
- en: Trying out the discovery service
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'With all of the details in place, we are ready to try out the service:'
  prefs: []
  type: TYPE_NORMAL
- en: 'First, build the Docker images with the following commands:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, start the system landscape and run the usual tests with the following
    command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'Expect output similar to what we have seen in previous chapters:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/841fe8fc-968b-40e7-85fa-60fa73153679.png)'
  prefs: []
  type: TYPE_IMG
- en: With the system landscape up and running, we can start with testing how to scale
    up the number of instances for one of the microservices.
  prefs: []
  type: TYPE_NORMAL
- en: Setting up a Netflix Eureka server
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this section, we will learn how to set up a Netflix Eureka server for service
    discovery. Setting up a Netflix Eureka server using Spring Cloud is really easy—just
    follow these steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Create a Spring Boot project using Spring Initializr, as described in [Chapter
    3](d26f4e61-20bf-4f55-b96d-060c7dd6f20c.xhtml), *Creating a Set of Cooperating
    Microservices*, in the*Using Spring Initializr to generate skeleton code* section.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Add a dependency to `spring-cloud-starter-netflix-eureka-server`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Add the `@EnableEurekaServer` annotation to the application class.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Add a Dockerfile, similar to the Dockerfiles that are used for our microservices,
    with the exception that we export the Eureka default port, `8761`, instead of
    the default port for our microservices, `8080`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Add the Eureka server to our three Docker Compose files, that is, `docker-compose.yml`,
    `docker-compose-partitions.yml`, and `docker-compose-kafka.yml`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: Finally, add some configuration. Please go to the *Setting up configuration
    for use in the development process* section in this chapter, where we will go
    through the configuration for both the Eureka server and our microservices.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: That's all it takes!
  prefs: []
  type: TYPE_NORMAL
- en: You can find the source code for the Eureka server in the `$BOOK_HOME/Chapter09/spring-cloud/eureka-server`
    folder.
  prefs: []
  type: TYPE_NORMAL
- en: Knowing how to set up a Netflix Eureka server for service discovery, we are
    ready to learn how to connect microservices to a Netflix Eureka server.
  prefs: []
  type: TYPE_NORMAL
- en: Connecting microservices to a Netflix Eureka server
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section, we will learn how to connect microservice instances to a Netflix
    Eureka server. We will learn both how microservices instances register themselves
    to the Eureka server during their startup and how clients can use the Eureka server to
    find microservice instances it wants to call.
  prefs: []
  type: TYPE_NORMAL
- en: 'To be able to register a microservice instance in the Eureka server, we need
    to do the following:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Add a dependency to `spring-cloud-starter-netflix-eureka-client` in the build
    file, `build.gradle`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'When running tests on a single microservice, we don''t want to depend on having
    the Eureka server up and running. Therefore, we will disable the use of Netflix
    Eureka in all Spring Boot tests, that is, JUnit tests annotated with `@SpringBootTest`. This
    can be done by adding the `eureka.client.enabled` property and setting it to `false`
    in the annotation, like so:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: Finally, add some configuration. Please go to the *Set**ting up configuration
    for use in the development process* section, where we will go through the configuration
    for both the Eureka server and our microservices.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: There is, however, one property in the configuration that is extra important: `spring.application.name`.
    It is used to give each microservice a virtual hostname, that is, a name used
    by the Eureka service to identify each microservice. Eureka clients will use this virtual
    hostname in the URLs that are used to make HTTP calls to the microservice, as
    we will see as we proceed.
  prefs: []
  type: TYPE_NORMAL
- en: 'To be able to look up available microservices instances through the Eureka
    server in the `product-composite` microservice, we also need to do the following:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Add a load balancer-aware `WebClient` builder, as described previously, in
    an application class, that is, `se.magnus.microservices.composite.product.ProductCompositeServiceApplication`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'Update how the `WebClient` object is created in the integration class, `se.magnus.microservices.composite.product.services.ProductCompositeIntegration`.
    The `@LoadBalanced` annotation will, as described previously, result in that Spring
    will inject a load balancer-aware filter into the `WebClient.Builder` bean. Unfortunately,
    this isn''t done until after the constructor runs in the integration class. This
    means that we have to move the construction of `webClient` away from the constructor,
    as we did in [Chapter 7](436fb8c1-0c4d-410c-a3ec-da251aba4ca1.xhtml), *Developing
    Reactive Microservices*, to a separate getter method that creates the `webClient`
    lazily, that is, once it''s used for the first time. This is shown in the following
    code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'Whenever `WebClient` is used to create an outgoing HTTP request, it is accessed
    via the `getWebClient()` getter method (instead of using the `webClient` field
    directly). See the following example:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'We can now get rid of our hardcoded configuration of available microservices
    in `application.yml`. For example, consider the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'The corresponding code in the integration class that handled the hardcoded
    configuration is replaced by a declaration of the base URLs to the APIs of the
    core microservices. This is shown in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: The hostnames in the preceding URLs are not actual DNS names. Instead, they
    are the virtual hostnames that are used by the microservices when they register
    themselves to the Eureka server, that is, the values of the `spring.application.name` property.
  prefs: []
  type: TYPE_NORMAL
- en: Knowing how to connect microservice instances to a Netflix Eureka server, we
    can move on and learn how to configure both a Eureka server and microservice instances
    that need to connect to a Eureka server.
  prefs: []
  type: TYPE_NORMAL
- en: Setting up configuration for use in the development process
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Now, it''s time for the trickiest part of setting up Netflix Eureka as a discovery
    service, that is, setting up a working configuration for both the Eureka server
    and its clients: our microservice instances.'
  prefs: []
  type: TYPE_NORMAL
- en: Netflix Eureka is a highly configurable discovery server that can be set up
    for a number of different use cases, and it provides robust, resilient, and fault-tolerant
    runtime characteristics. One downside of this flexibility and robustness is that
    it has an almost overwhelming number of configuration options. Fortunately, Netflix
    Eureka comes with good default values for most of the configurable parameters—at
    least when it comes to using them in a production environment.
  prefs: []
  type: TYPE_NORMAL
- en: When it comes to using Netflix Eureka during development, the default values
    cause long startup times. For example, it can take a long time for a client to
    make an initial successful call to a microservices instance that is registered
    in the Eureka server.
  prefs: []
  type: TYPE_NORMAL
- en: Up to two minutes of wait time can be experienced when using the default configuration
    values. This wait time is added to the time it takes for the Eureka service and
    the microservices to start up. The reason for this wait time is that the involved
    processes need to synchronize registration information with each other.
  prefs: []
  type: TYPE_NORMAL
- en: The microservices instances need to register with the Eureka server, and the
    client needs to gather information from the Eureka server. This communication
    is mainly based on heartbeats, which happen every 30 seconds by default. A couple
    of caches are also involved, which slows down the propagation of updates.
  prefs: []
  type: TYPE_NORMAL
- en: We will use a configuration that minimizes this wait time, which is useful during
    development. For use in production environments, the default values should be
    used as a starting point!
  prefs: []
  type: TYPE_NORMAL
- en: We will only use one Netflix Eureka server instance, which is okay in a development
    environment. In a production environment, you should always use two or more instances to
    ensure high availability for the Netflix Eureka server.
  prefs: []
  type: TYPE_NORMAL
- en: Let's start to learn what types of configuration parameters we need to know
    about.
  prefs: []
  type: TYPE_NORMAL
- en: Eureka configuration parameters
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The configuration parameters for Eureka are divided into three groups:'
  prefs: []
  type: TYPE_NORMAL
- en: There are parameters for the Eureka server, prefixed with `eureka.server`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: There are parameters for Eureka clients, prefixed with `eureka.client`. This
    is for clients who want to communicate with a Eureka server.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: There are parameters for Eureka instances, prefixed with `eureka.instance`.
    This is for the microservices instances that want to register themselves in the
    Eureka server.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Some of the available parameters are described in the Spring Cloud documentation:
    *Service Discovery: Eureka Server*: [https://cloud.spring.io/spring-cloud-static/Greenwich.RELEASE/single/spring-cloud.html#spring-cloud-eureka-server](https://cloud.spring.io/spring-cloud-static/Greenwich.RELEASE/single/spring-cloud.html#spring-cloud-eureka-server)
    *Service Discovery: Eureka Clients*: [https://cloud.spring.io/spring-cloud-static/Greenwich.RELEASE/single/spring-cloud.html#_service_discovery_eureka_clients](https://cloud.spring.io/spring-cloud-static/Greenwich.RELEASE/single/spring-cloud.html#_service_discovery_eureka_clients)'
  prefs: []
  type: TYPE_NORMAL
- en: 'For an extensive list of available parameters, I recommend reading the source
    code:'
  prefs: []
  type: TYPE_NORMAL
- en: For Eureka server parameters, look at the `org.springframework.cloud.netflix.eureka.server.EurekaServerConfigBean` class
    for default values and the `com.netflix.eureka.EurekaServerConfig` interface for
    the relevant documentation.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: For Eureka client parameters, look at the `org.springframework.cloud.netflix.eureka.EurekaClientConfigBean`
    class for the default values anddocumentation.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: For Eureka instance parameters, look at the `org.springframework.cloud.netflix.eureka.EurekaInstanceConfigBean`
    class for default values and documentation.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Let's start to learn about configuration parameters for the Eureka server.
  prefs: []
  type: TYPE_NORMAL
- en: Configuring the Eureka server
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To configure the Eureka server for use in a development environment, the following
    configuration can be used:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: The first part of the configuration, for a Eureka `instance` and `client` is
    a standard configuration of a standalone Eureka server. For details, see the Spring
    Cloud documentation that we referred to previously. The last two parameters used
    for the Eureka `server`, `waitTimeInMsWhenSyncEmpty` and `response-cache-update-interval-ms`,
    are used to minimize the startup time.
  prefs: []
  type: TYPE_NORMAL
- en: With the Eureka server configured, we are ready to see how clients to the Eureka
    server, that is, the microservice instances, can be configured.
  prefs: []
  type: TYPE_NORMAL
- en: Configuring clients to the Eureka server
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To be able to connect to the Eureka server, the microservices have the following
    configuration:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: The `eureka.client.serviceUrl.defaultZone` parameter is used to find the Eureka
    server, whereas the other parameters are used to minimize the startup time and
    the time it takes to deregister a microservice instance that is stopped.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `product-composite` microservice, which uses the Eureka server to look
    up the other microservices, also has two Netflix Ribbon-specific parameters:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: These two parameters are also used to minimize startup time.
  prefs: []
  type: TYPE_NORMAL
- en: Now, we have everything in place required to actually try out discovery service
    using the Netflix Eureka server together with our microservices.
  prefs: []
  type: TYPE_NORMAL
- en: Scaling up
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Now, we can try out the discovery service by launching two extra `review` microservice
    instances:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: With the preceding command, we ask Docker Compose to run three instances of
    the `review` service. Since one instance is already running, two new instances
    will be started up.
  prefs: []
  type: TYPE_NORMAL
- en: 'Once the new instances are up and running, browse to `http://localhost:8761/`
    and expect something like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/b53f6c5c-f964-4731-8907-8482ddd11cca.png)'
  prefs: []
  type: TYPE_IMG
- en: After running this localhost, verify that you can see three `review` instances
    in the Netflix Eureka web UI, as shown in the preceding screenshot.
  prefs: []
  type: TYPE_NORMAL
- en: 'One way of knowing when the new instances are up and running is to run the
    `docker-compose logs -f review` command and look for output that looks as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/249647b6-1f89-4d9a-800c-d84d740893f6.png)'
  prefs: []
  type: TYPE_IMG
- en: 'We can also use a REST API that the Eureka service exposes. To get a list of
    instance IDs, we can issue a `curl` command, like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'Expect a response that looks similar to the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/66ef4c5e-20f9-4056-8bdb-e4398a194d4e.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Now that we have all of the instances up and running, let''s try out the client-side
    load balancer by making some requests and focusing on the address of the `review`
    service in the responses, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'Expect responses similar to the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/ccd79bc6-a3e1-43aa-891f-553c6f727741.png)'
  prefs: []
  type: TYPE_IMG
- en: Note that the address of the `review` service changes in each response; that
    is, the load balancer uses a round-robin to call the available `review` instances,
    one at a time!
  prefs: []
  type: TYPE_NORMAL
- en: 'We can also take a look into the `review` instances log with the following
    command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'After this, you will see output that looks similar to the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/cadd482e-aa89-4949-972e-d8fb4f3f1145.png)'
  prefs: []
  type: TYPE_IMG
- en: In the preceding output, we can see how the three review microservice instances, `review_1`, `review_2`,
    and `review_3`, in turn, have responded to the requests.
  prefs: []
  type: TYPE_NORMAL
- en: After trying out scaling up microservice instances we will try out what happens
    when we scale down the instances.
  prefs: []
  type: TYPE_NORMAL
- en: Scaling down
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s also see what happens if we lose one instance of the `review` microservice.
    We can simulate that one instance stops unexpectedly by running the following
    command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'After the shutdown of the `review` instance, there is a short time slot when
    calls to the API might fail. This is caused by the time it takes for information
    regarding the lost instance to propagate to the client, that is, the `product-composite`
    service. During this time frame, the client-side load balancer might choose the
    instance that no longer exists. To prevent this from occurring, resilience mechanisms
    such as timeouts and retries can be used. In [Chapter 13](23795d34-4068-4961-842d-989cde26b642.xhtml), *Improving
    Resilience Using Resilience4j*, we will see how this can be applied. For now,
    let''s specify a timeout on our `curl` command, using the `-m 2` switch to specify
    that we will wait no longer than two seconds for a response:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'If a timeout occurs, that is, the client-side load balancer tries to call an
    instance that no longer exists, the following response is expected from `curl`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'Besides that, we should expect normal responses from the two remaining instances;
    that is, the `serviceAddresses.rev` field should contain the addresses of the
    two instances, as in the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/25abdb94-b95c-4cb9-baea-c5917f2ce8af.png)'
  prefs: []
  type: TYPE_IMG
- en: In the preceding sample output, we can see that two different container names
    and IP addresses are reported. This means that the requests have been served by
    different microservice instances.
  prefs: []
  type: TYPE_NORMAL
- en: 'After trying out the scaling down of microservice instances, we can try out
    something that is a bit more disruptive: stopping the Eureka server and seeing
    what happens when the discovery service is temporarily unavailable.'
  prefs: []
  type: TYPE_NORMAL
- en: Disruptive tests with the Eureka server
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Let's bring some disorder to our Eureka server and see how the system landscape
    manages it!
  prefs: []
  type: TYPE_NORMAL
- en: To start with, what happens if we crash the Eureka server?
  prefs: []
  type: TYPE_NORMAL
- en: As long as clients have read the information regarding available microservice
    instances from the Eureka server before it is stopped, the clients will be fine
    since they cache the information locally. However, new instances will not be made
    available to clients, and they will not be notified if any running instances are
    terminated. So, calls to instances that are no longer running will cause failures.
  prefs: []
  type: TYPE_NORMAL
- en: Let's try this out!
  prefs: []
  type: TYPE_NORMAL
- en: Stopping the Eureka server
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To simulate that the Eureka server crashes, follow these steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'First, stop the Eureka server and keep the two `review` instances up and running:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'Try a couple of calls to the API and extract the service address of the `review`
    service:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'The response will—just like before we stopped the Eureka server—contain the
    addresses of the two `review` instances, like so:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/91291ded-566c-4cea-b151-aeea0e4c6390.png)'
  prefs: []
  type: TYPE_IMG
- en: This shows that the client can make calls to existing instances, even though
    the Eureka server is no longer running!
  prefs: []
  type: TYPE_NORMAL
- en: Stopping a review instance
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To further investigate what the effects are of a crashed Eureka server, let''s
    simulate that one of the remaining `review` microservice instances also crashes.
    Terminate one of the two `review` instances with the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: The client, that is, the `product-composite` service, will not be notified that
    one of the `review` instances has disappeared since no Eureka server is running.
    Due to this, it still thinks that there are two instances up and running. Every
    second call to the client will cause it to call a `review` instance that no longer
    exists, resulting in the response from the client not containing any information
    from the `review` service. The service address of the `review` service will be
    empty.
  prefs: []
  type: TYPE_NORMAL
- en: Try out the preceding `curl` command to verify that the service address of the
    `review` service will be empty every second time. This can be prevented, as described
    previously, by using resilience mechanisms such as timeouts and retries.
  prefs: []
  type: TYPE_NORMAL
- en: Starting up an extra instance of the product service
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'As a final test of the effects of a crashed Eureka server, let''s see what
    happens if we start up a new instance of the `product` microservice. Perform the
    following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s try starting a new instance of the `product` service:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'Call the API a couple of times and extract the address of the `product` service
    with the following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'Since no Eureka server is running, the client will not be notified of the new
    `product` instance, and so all calls will go to the first instance, as in the
    following example:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/a783eca8-e0b7-48be-947d-c972032e4c9b.png)'
  prefs: []
  type: TYPE_IMG
- en: Now we have seen some of the most important aspects of not having a Netflix
    Eureka server up and running. Let's conclude the section on disruptive tests by
    starting up the Netflix Eureka server again and seeing how the system landscape
    handles self-heals, that is, resilience.
  prefs: []
  type: TYPE_NORMAL
- en: Starting up the Eureka server again
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this section, we will wrap up the disruptive tests by starting up the Eureka
    server again. We shall also verify that the system landscape self-heals, that
    is, verify that the new instance of the `product` microservice gets registered
    with the Netflix Eureka server and that the client gets updated by the Eureka
    server. Perform the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Start the Eureka server with the following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'Make some new calls to the API and verify that the following happens:'
  prefs: []
  type: TYPE_NORMAL
- en: All calls go to the remaining `review` instance, that is, the client has detected
    that the second `review` instance has gone.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Calls to the `product` service are load-balanced over the two `product` instances,
    that is, the client has detected that there are two `product` instances available.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Make the following call a couple of times to extract the addresses of the product
    and the `review` service:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'Verify that the responses from the API calls contain addresses to the involved
    `product` and `review` instances, like so:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/4c8c141a-2404-4b8c-bf33-b7a0b59c5476.png)'
  prefs: []
  type: TYPE_IMG
- en: 'This is the second response:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/03c25c97-63a7-49d6-82b1-72ea5a69ac79.png)'
  prefs: []
  type: TYPE_IMG
- en: The `192.168.128.3` and `192.168.128.7` IP addresses belong to the two `product`
    instances. `192.168.128.9` is the IP address of the `review` instance.
  prefs: []
  type: TYPE_NORMAL
- en: To summarize, the Eureka server provides a very robust and resilient implementation
    of a discovery service. If even higher availability is desired, multiple Eureka
    servers can be launched and configured to communicate with each other. Details
    on how to set up multiple Eureka servers can be found in the Spring Cloud documentation: [https://cloud.spring.io/spring-cloud-static/Greenwich.RELEASE/single/spring-cloud.html#spring-cloud-eureka-server-peer-awareness](https://cloud.spring.io/spring-cloud-static/Greenwich.RELEASE/single/spring-cloud.html#spring-cloud-eureka-server-peer-awareness).
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, shut down the system landscape with the command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: This completes the tests of the discovery server, Netflix Eureka, where we have
    learned both how to scale up and scale down microservice instances and learned
    what happens if a Netflix Eureka server crashes and later on comes back online.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we learned how to use Netflix Eureka for service discovery.
    First, we looked into the shortcomings of a simple DNS-based service discovery
    solution and the challenges that a robust and resilient service discovery solution
    must be able to handle.
  prefs: []
  type: TYPE_NORMAL
- en: Netflix Eureka is a very capable service discovery solution that provides robust,
    resilient, and fault-tolerant runtime characteristics. However, it can be challenging
    to configure correctly, especially for smooth developer experience. With Spring
    Cloud, it becomes easy to set up a Netflix Eureka server and adapt Spring Boot-based
    microservices, both so that they can register themselves to Eureka during startup
    and, when acting as a client to other microservices, to keep track of available
    microservices instances.
  prefs: []
  type: TYPE_NORMAL
- en: With a discovery service in place, it's time to see how we can handle external
    traffic using Spring Cloud Gateway as an edge server. Head over to the next chapter
    to find out how!
  prefs: []
  type: TYPE_NORMAL
- en: Questions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: What is required to turn a Spring Boot application created with Spring Initializr
    into a fully-fledged Netflix Eureka Server?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What is required to make a Spring Boot-based microservice register itself automatically
    as a startup with Netflix Eureka?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What is required to make it possible for a Spring Boot-based microservice to
    call another microservice that is registered in a Netflix Eureka server?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Let''s assume that you have a Netflix Eureka server up and running, along with
    one instance of microservice *A* and two instances of microservice *B*. All microservice
    instances register themselves with the Netflix Eureka server. Microservice *A*
    makes HTTP requests to microservice *B* based on the information it gets from
    the Eureka server. What will happen if, in turn, the following happens:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The Netflix Eureka server crashes
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: One of the instances of microservice *B* crashes
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: A new instance of microservice *A* starts up
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: A new instance of microservice *B* starts up
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: The Netflix Eureka server starts up again
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
