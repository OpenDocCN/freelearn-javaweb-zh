- en: Additional Spring Security Features
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this chapter, we will explore several additional Spring Security features
    that we have not covered so far in this book, including the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Cross-Site Scripting** (**XSS**)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Cross-Site Request Forgery** (**CSRF**)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Synchronizer tokens
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Clickjacking**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'We will understand how to include various HTTP headers to protect against common
    security vulnerabilities, using the following methods:'
  prefs: []
  type: TYPE_NORMAL
- en: '`Cache-Control`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Content-Type Options`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**HTTP Strict Transport Security** (**HSTS**)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`X-Frame-Options`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`X-XSS-Protection`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Before you read this chapter, you should already have an understanding of how
    Spring Security works. This means you should already be able to set up authentication
    and authorization in a simple web application. If you are unable to do this, you
    will want to ensure you have read up to [Chapter 3](03.html), *Custom Authentication*,
    before proceeding with this chapter. If you keep the basic concepts of Spring
    Security in mind and you understand the framework you are integrating with, then
    integrating with other frameworks is fairly straightforward.
  prefs: []
  type: TYPE_NORMAL
- en: Security vulnerabilities
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the age of the internet, there is a multitude of possible vulnerabilities
    that can be exploited. A great resource to learn more about web-based vulnerabilities
    is **The Open Web Application Security Project** (**OWASP**), which is located
    at [https://www.owasp.org](https://www.owasp.org/).
  prefs: []
  type: TYPE_NORMAL
- en: In addition to being a great resource to understand various vulnerabilities,
    OWASP categorizes the top 10 vulnerabilities based on industry trends.
  prefs: []
  type: TYPE_NORMAL
- en: Cross-Site Scripting
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: XSS attacks involve malicious scripts that have been injected into a trusted
    site.
  prefs: []
  type: TYPE_NORMAL
- en: XSS attacks occur when an attacker exploits a given web application that is
    allowing unventilated input to be sent into the site generally in the form of
    browser-based scripts, which are then executed by a different user of the website.
  prefs: []
  type: TYPE_NORMAL
- en: There are many forms that attackers can exploit, based on validated or unencoded
    information provided to websites.
  prefs: []
  type: TYPE_NORMAL
- en: At the core of this issue is expecting a user to trust the site's information
    that is being sent. The end user's browser has no way to know that the script
    should not be trusted because there has been an implicit trust of the website
    they're browsing. Because it thinks the script came from a trusted source, the
    malicious script can access any cookies, session tokens, or other sensitive information
    retained by the browser and used with that website.
  prefs: []
  type: TYPE_NORMAL
- en: 'XSS can be described by the following sequence diagram:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/da789fd6-805c-4ab2-bcc8-ec95e763c00a.png)'
  prefs: []
  type: TYPE_IMG
- en: Cross-Site Request Forgery
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: CSRF is an attack that tricks the victim into submitting a malicious request.
    This type of attack inherits or hijacks the identity and privileges of the victim
    and performs unauthorized functions and access on the victim's behalf.
  prefs: []
  type: TYPE_NORMAL
- en: For web applications, most browsers automatically include credentials associated
    with the site, which includes a user session, cookie, IP address, Windows domain
    credentials, and so forth.
  prefs: []
  type: TYPE_NORMAL
- en: So, if a user is currently authenticated on a site, that given site will have
    no way to distinguish between the forged request sent by the victim and a legitimate
    court request.
  prefs: []
  type: TYPE_NORMAL
- en: CSRF attacks target functionality that causes a state change on the server,
    such as changing the victim's email address or password, or engaging in a financial
    transaction.
  prefs: []
  type: TYPE_NORMAL
- en: This forces the victim to retrieve data that doesn't benefit an attacker because
    the attacker does not receive the response; the victim does. Thus, CSRF attacks
    target state-changing requests.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following sequence diagram details how a CSRF attack would occur:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/c0a2cc8f-d6c0-4d2e-85cc-55c6ee3fcb83.png)'
  prefs: []
  type: TYPE_IMG
- en: There are several different design measures that may be taken to attempt to
    prevent CSRF, however, measures such as secret cookies, HTTP POST requests, multistep
    transactions, URL rewriting, and HTTPS, in no way prevent this type of attack.
  prefs: []
  type: TYPE_NORMAL
- en: OWASP's top 10 security vulnerabilities list details CSRF as the eighth most
    common attack at [https://www.owasp.org/index.php/Cross-Site_Request_Forgery_(CSRF)](https://www.owasp.org/index.php/Cross-Site_Request_Forgery_(CSRF)).
  prefs: []
  type: TYPE_NORMAL
- en: Synchronizer tokens
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A solution to this is to use the synchronizer token pattern. This solution is
    to ensure that each request requires, in addition to our session cookie, a randomly
    generated token as an HTTP parameter. When a request is submitted, the server
    must look up the expected value for the parameter and compare it to the actual
    value in the request. If the values do not match, the request should fail.
  prefs: []
  type: TYPE_NORMAL
- en: 'The *Cross-Site Request Forgery (CSRF) Prevention Cheat Sheet* recommends the
    synchronizer token pattern as a viable solution for CSRF attacks: [https://www.owasp.org/index.php/Cross-Site_Request_Forgery_(CSRF)_Prevention_Cheat_Sheet#General_Recommendation:_Synchronizer_Token_Pattern](https://www.owasp.org/index.php/Cross-Site_Request_Forgery_(CSRF)_Prevention_Cheat_Sheet#General_Recommendation:_Synchronizer_Token_Pattern)'
  prefs: []
  type: TYPE_NORMAL
- en: Relaxing the expectation is to only require the token for each HTTP request
    that updates state. This can be safely done since the same origin policy ensures
    the evil site cannot read the response. Additionally, we do not want to include
    the random token in HTTP `GET`, as this can cause the tokens to be leaked.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s take a look at how our example would change. Assume the randomly generated
    token is present in an HTTP parameter `named _csrf`. For example, the request
    to transfer money would look like as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: You will notice that we added the `_csrf` parameter with a random value. Now,
    the malicious website will not be able to guess the correct value for the `_csrf`
    parameter (which must be explicitly provided on the malicious website) and the
    transfer will fail when the server compares the actual token to the expected token.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following diagram shows a standard use case for a synchronizer token pattern:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/a55eec39-0e93-4503-82d8-af9c17f44ce6.png)'
  prefs: []
  type: TYPE_IMG
- en: Synchronizer token support in Spring Security
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Spring Security provides synchronizer token support that is turned on by default.
    You might have noticed from the previous chapters that in our `SecurityConfig.java`
    file, we have disabled CSRF protection, as shown in the following code snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: Up to this point in the book, we have disabled synchronizer token protection
    so we could focus on other security concerns.
  prefs: []
  type: TYPE_NORMAL
- en: If we start the application at this point, we can run through the security and
    there will be no synchronizer token support added to any of the pages.
  prefs: []
  type: TYPE_NORMAL
- en: You should start with the code from `chapter16.00-calendar`.
  prefs: []
  type: TYPE_NORMAL
- en: When to use CSRF protection
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: It is recommended you use CSRF protection for any request that could be processed
    by a browser or by normal users. If you are only creating a service that is used
    by non-browser clients, you will most likely want to disable CSRF protection.
  prefs: []
  type: TYPE_NORMAL
- en: CSRF protection and JSON
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'A common question is: do I need to protect JSON requests made by JavaScript?
    The short answer is, it depends. However, you must be very careful, as there are
    CSRF exploits that can impact JSON requests. For example, a malicious user can
    create a CSRF with JSON using the following form:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'If an application were not validating the Content-Type method, then it would
    be exposed to this exploit. Depending on the setup, a Spring MVC application that
    validates the Content-Type method could still be exploited by updating the URL
    suffix to end with `.json`, as shown in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: CSRF and stateless browser applications
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: What if your application is stateless? That doesn't necessarily mean you are
    protected. In fact, if a user does not need to perform any actions in the web
    browser for a given request, they are likely still vulnerable to CSRF attacks.
  prefs: []
  type: TYPE_NORMAL
- en: For example, consider an application using a custom cookie that contains all
    of the states within it for authentication instead of the `JSESSIONID` cookie.
    When the CSRF attack happens, the custom cookie will be sent with the request
    in the same manner that the `JSESSIONID` cookie was sent in our previous example.
  prefs: []
  type: TYPE_NORMAL
- en: Users using basic authentication are also vulnerable to CSRF attacks, since
    the browser will automatically include the username and password in any requests,
    in the same manner, that the `JSESSIONID` cookie was sent in our previous example.
  prefs: []
  type: TYPE_NORMAL
- en: Using Spring Security CSRF protection
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'So, what are the steps necessary to use Spring Security to protect our site
    against CSRF attacks? The steps for using Spring Security''s CSRF protection are
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Use proper HTTP verbs.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Configure CSRF protection.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Include the CSRF token.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Using proper HTTP verbs
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The first step to protecting against CSRF attacks is to ensure your website
    uses proper HTTP verbs. Specifically, before Spring Security's CSRF support can
    be of use, you need to be certain that your application is using `PATCH`, `POST`,
    `PUT`, and/or `DELETE` for anything that modifies state.
  prefs: []
  type: TYPE_NORMAL
- en: This is not a limitation of Spring Security's support, but instead a general
    requirement for proper CSRF prevention. The reason is that including private information
    in an HTTP `GET` method can cause the information to be leaked.
  prefs: []
  type: TYPE_NORMAL
- en: Refer to *RFC 2616*, *Section 15.1.3*, *Encoding Sensitive Information in URI's*
    for general guidance on using `POST` instead of `GET` for sensitive information
    ([https://www.w3.org/Protocols/rfc2616/rfc2616-sec15.html#sec15.1.3](https://www.w3.org/Protocols/rfc2616/rfc2616-sec15.html#sec15.1.3)).
  prefs: []
  type: TYPE_NORMAL
- en: Configuring CSRF protection
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The next step is to include Spring Security's CSRF protection within your application.
    Some frameworks handle invalid CSRF tokens by invaliding the user's session, but
    this causes its own problems. Instead, by default, Spring Security's CSRF protection
    will produce HTTP 403 access denied. This can be customized by configuring `AccessDeniedHandler`
    to process `InvalidCsrfTokenException` differently.
  prefs: []
  type: TYPE_NORMAL
- en: For passivity reasons, if you are using the XML configuration, CSRF protection
    must be explicitly enabled using the `<csrf>` element. Refer to the `<csrf>` element's
    documentation for additional customizations.
  prefs: []
  type: TYPE_NORMAL
- en: SEC-2347 is logged to ensure Spring Security 4.x's XML namespace configuration
    will enable CSRF protection by default ([https://github.com/spring-projects/spring-security/issues/2574](https://github.com/spring-projects/spring-security/issues/2574)).
  prefs: []
  type: TYPE_NORMAL
- en: Default CSRF support
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: CSRF protection is enabled by default with Java configuration. Refer to the
    Javadoc of `csrf()` for additional customizations regarding how CSRF protection
    is configured.
  prefs: []
  type: TYPE_NORMAL
- en: 'Just to be verbose in this configuration, we are going to add the CSRS method
    to our `SecurityConfig.java` file as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: Including the CSRF token in the <Form> submissions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The last step is to ensure that you include the CSRF token in all `PATCH`,
    `POST`, `PUT`, and `DELETE` methods. One way to approach this is to use the `_csrf`
    request attribute to obtain the current `CsrfToken` token. An example of doing
    this with a JSP is shown as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: Including the CSRF token using the Spring Security JSP tag library
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: If CSRF protection is enabled, this tag inserts a hidden form field with the
    correct name and value for the CSRF protection token. If CSRF protection is not
    enabled, this tag has no output.
  prefs: []
  type: TYPE_NORMAL
- en: Normally, Spring Security automatically inserts a CSRF form field for any `<form:form>`
    tags you use, but if for some reason you cannot use `<form:form>`, `csrfInput`
    is a handy replacement.
  prefs: []
  type: TYPE_NORMAL
- en: 'You should place this tag within an HTML `<form></form>` block, where you would
    normally place other input fields. Do not place this tag within a Spring `<form:form></form:form>`
    block. Spring Security handles Spring forms automatically as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: Default CSRF token support
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: If you are using the Spring MVC `<form:form>` tag, or Thymeleaf 2.1+, and you
    replace `@EnableWebSecurity` with `@EnableWebMvcSecurity`, the `CsrfToken` token
    is automatically included for you (using the `CsrfRequestDataValue` token we have
    been processing).
  prefs: []
  type: TYPE_NORMAL
- en: So, for this book, we have been using Thymeleaf for all of our web pages. Thymeleaf
    has CSRF support enabled by default if we enable CSRF support in Spring Security.
  prefs: []
  type: TYPE_NORMAL
- en: You should start with the code from `chapter16.01-calendar`.
  prefs: []
  type: TYPE_NORMAL
- en: 'If we start up the JBCP calendar application and navigate to the login page
    at `https://localhost:8443/login.html`, we can view the generated source for the
    `login.html` page, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: Ajax and JSON requests
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'If you are using JSON, then it is not possible to submit the CSRF token within
    an HTTP parameter. Instead, you can submit the token within a HTTP header. A typical
    pattern would be to include the CSRF token within your `<meta>` HTML tags. An
    example with a JSP is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: Instead of manually creating the meta tags, you can use the simpler `csrfMetaTags`
    tag from the Spring Security JSP tag library.
  prefs: []
  type: TYPE_NORMAL
- en: The csrfMetaTags tag
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: If CSRF protection is enabled, this tag inserts meta tags containing the CSRF
    protection token form field, header names, and CSRF protection token value. These
    meta tags are useful for employing CSRF protection within JavaScript in your applications.
  prefs: []
  type: TYPE_NORMAL
- en: 'You should place the `csrfMetaTags` tag within an HTML `<head></head>` block,
    where you would normally place other meta tags. Once you use this tag, you can
    access the form field name, header name, and token value easily using JavaScript,
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: If CSRF protection is not enabled, `csrfMetaTags` outputs nothing.
  prefs: []
  type: TYPE_NORMAL
- en: jQuery usage
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'You can then include the token within all of your Ajax requests. If you were
    using jQuery, this could be done with the following code snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: Using the cujoJS's rest.js module
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'As an alternative to jQuery, we recommend using the `rest.js` module of cujoJS.
    The `rest.js` module provides advanced support for working with HTTP requests
    and responses in RESTful ways. A core capability is the ability to contextualize
    the HTTP client, adding behavior as needed by chaining interceptors onto the client,
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: The configured client can be shared with any component of the application that
    needs to make a request to the CSRF protected resource. One significant difference
    between `rest.js` and jQuery is that the only requests made with the configured
    client will contain the CSRF token, versus in jQuery, where all requests will
    include the token. The ability to determine which requests receive the token helps
    guard against leaking the CSRF token to a third-party.
  prefs: []
  type: TYPE_NORMAL
- en: Please refer to the `rest.js` reference documentation for more information on
    `rest.js`
  prefs: []
  type: TYPE_NORMAL
- en: '[(](https://github.com/cujojs/rest/tree/master/docs)[https://github.com/cujojs/rest/tree/master/docs](https://github.com/cujojs/rest/tree/master/docs)[).](https://github.com/cujojs/rest/tree/master/docs)'
  prefs: []
  type: TYPE_NORMAL
- en: CSRF caveats
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: There are a few caveats when implementing CSRF in Spring Security that you need
    to be aware of.
  prefs: []
  type: TYPE_NORMAL
- en: Timeouts
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: One issue is that the expected CSRF token is stored in the `HttpSession` method,
    so as soon as the `HttpSession` method expires, your configured `AccessDeniedHandler`
    handler will receive `InvalidCsrfTokenException`. If you are using the default
    `AccessDeniedHandler` handler, the browser will get an HTTP 403 and display a
    poor error message.
  prefs: []
  type: TYPE_NORMAL
- en: You might ask why the expected `CsrfToken` token isn't stored in a cookie. This
    is because there are known exploits in which headers (specifying the cookies)
    can be set by another domain.
  prefs: []
  type: TYPE_NORMAL
- en: This is the same reason Ruby on Rails no longer skips CSRF checks when the header
    X-Requested-With is present ([http://weblog.rubyonrails.org/2011/2/8/csrf-protection-bypass-in-ruby-on-rails/](http://weblog.rubyonrails.org/2011/2/8/csrf-protection-bypass-in-ruby-on-rails/)).
  prefs: []
  type: TYPE_NORMAL
- en: The *Web Application Security Consortium* ([http://www.webappsec.org](http://www.webappsec.org/))
    has a detailed thread on using CSRF and an HTTP 307 redirect to perform exploit
    CSRF cookies.
  prefs: []
  type: TYPE_NORMAL
- en: See this [www.webappsec.org](http://www.webappsec.org/) thread for details on
    how to perform the exploit at [http://lists.webappsec.org/pipermail/websecurity_lists.webappsec.org/2011-February/007533.html](http://lists.webappsec.org/pipermail/websecurity_lists.webappsec.org/2011-February/007533.html).
  prefs: []
  type: TYPE_NORMAL
- en: Another disadvantage is that by removing the state (the timeout), you lose the
    ability to forcibly terminate the token if something is compromised.
  prefs: []
  type: TYPE_NORMAL
- en: A simple way to mitigate an active user experiencing a timeout is to have some
    JavaScript that lets the user know their session is about to expire. The user
    can click a button to continue and refresh the session.
  prefs: []
  type: TYPE_NORMAL
- en: 'Alternatively, specifying a custom `AccessDeniedHandler` handler allows you
    to process `InvalidCsrfTokenException` any way you like, as we can see in the
    following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: Logging in
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In order to protect against forged login requests, the login form should be
    protected against CSRF attacks, too. Since the `CsrfToken` token is stored in
    `HttpSession`, this means an `HttpSession` mehthod will be created as soon as
    the `CsrfToken` attribute is accessed. While this sounds bad in a RESTful/stateless
    architecture, the reality is that the state is necessary to implement practical
    security. Without the state, we have nothing we can do if a token is compromised.
    Practically speaking, the CSRF token is quite small in size and should have a
    negligible impact on our architecture.
  prefs: []
  type: TYPE_NORMAL
- en: An attacker may forge a request to log the victim into a target website using
    the attacker's credentials; this is known as login CSRF ([https://en.wikipedia.org/wiki/Cross-site_request_forgery#Forging_login_requests](https://en.wikipedia.org/wiki/Cross-site_request_forgery#Forging_login_requests)).
  prefs: []
  type: TYPE_NORMAL
- en: Logging out
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Adding CSRF will update the `LogoutFilter` filter to only use HTTP `POST`. This
    ensures that logging out requires a CSRF token and that a malicious user cannot
    forcibly log out your users.
  prefs: []
  type: TYPE_NORMAL
- en: One approach is to use a `<form>` tag for logout. If you want an HTML link,
    you can use JavaScript to have the link perform an HTTP `POST` (which can be in
    a hidden form). For browsers with JavaScript disabled, you can optionally have
    the link take the user to a logout confirmation page that will perform the HTTP
    `POST`.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you want to use HTTP `GET` with logout, you can do so, but remember, this
    is generally not recommended. For example, the following Java configuration will
    perform logout when the logout URL pattern is requested with any HTTP method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: Security HTTP response headers
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The following sections discuss Spring Security's support for adding various
    security headers to the response.
  prefs: []
  type: TYPE_NORMAL
- en: Default security headers
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Spring Security allows users to easily inject default security headers to assist
    in protecting their application. The following is a list of the current default
    security headers provided by Spring Security:'
  prefs: []
  type: TYPE_NORMAL
- en: '`Cache-Control`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Content-Type Options`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: HTTP Strict Transport Security
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`X-Frame-Options`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`X-XSS-Protection`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: While each of these headers is considered best practice, it should be noted
    that not all clients utilize these headers, so additional testing is encouraged.
    For passivity reasons, if you are using Spring Security's XML namespace support,
    you must explicitly enable the security headers. All of the default headers can
    be easily added using the `<headers>` element with no child elements.
  prefs: []
  type: TYPE_NORMAL
- en: '*SEC-2348* is logged to ensure Spring Security 4.x''s XML namespace configuration
    will enable Security headers by default ([https://github.com/spring-projects/spring-security/issues/2575](https://github.com/spring-projects/spring-security/issues/2575)).'
  prefs: []
  type: TYPE_NORMAL
- en: 'If you are using Spring Security''s Java configuration, all of the default
    security headers are added by default. They can be disabled using Java configuration,
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'The following code adds the security headers to the response. This is activated
    by default when using the default constructor of `WebSecurityConfigurerAdapter`.
    Accepting the default provided by `WebSecurityConfigurerAdapter`, or only invoking
    the `headers()` method without invoking additional methods, is the equivalent
    of the following code snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'As soon as you specify any headers that should be included, then only those
    headers will be included. For example, the following configuration will include
    support for X-Frame-Options only:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: Cache-Control
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the past, Spring Security required you to provide your own `Cache-Control`
    method for your web application. This seemed reasonable at the time, but browser
    caches have evolved to include caches for secure connections as well. This means
    that a user may view an authenticated page, log out, and then a malicious user
    can use the browser history to view the cached page.
  prefs: []
  type: TYPE_NORMAL
- en: 'To help mitigate this, Spring Security has added `Cache-Control` support, which
    will insert the following headers into your response:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'Simply adding the `headers()` method with no child elements will automatically
    add `Cache-Control` and quite a few other protection options. However, if you
    only want `Cache-Control`, you can enable this feature using Spring Security''s
    Java Configuration with the `cacheControl()` method, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: If you want to cache specific responses, your application can selectively invoke
    `HttpServletResponse.setHeader(String,String)` to override the header set by Spring
    Security. This is useful to ensure things such as CSS, JavaScript, and images
    are properly cached.
  prefs: []
  type: TYPE_NORMAL
- en: 'When using Spring Web MVC, this is typically done within your configuration.
    For example, the following configuration will ensure that the cache headers are
    set for all of your resources:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: Content-Type Options
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Historically, browsers, including Internet Explorer, would try to guess the
    content type of a request using content sniffing. This allowed browsers to improve
    the user experience by guessing the content type of resources that had not specified
    the content type. For example, if a browser encountered a JavaScript file that
    did not have the content type specified, it would be able to guess the content
    type and then execute it.
  prefs: []
  type: TYPE_NORMAL
- en: There are many additional things one should do, such as only displaying the
    document in a distinct domain, ensuring the Content-Type header is set, sanitizing
    the document, and so on, when allowing content to be uploaded. However, these
    measures are out of the scope of what Spring Security provides. It is also important
    to point out that when disabling content sniffing, you must specify the content
    type in order for things to work properly.
  prefs: []
  type: TYPE_NORMAL
- en: The problem with content sniffing is that this allows malicious users to use
    polyglots (a file that is valid as multiple content types) to execute XSS attacks.
    For example, some sites may allow users to submit a valid postscript document
    to a website and view it. A malicious user might create a postscript document
    that is also a valid JavaScript file and execute an XSS attack with it ([http://webblaze.cs.berkeley.edu/papers/barth-caballero-song.pdf](http://webblaze.cs.berkeley.edu/papers/barth-caballero-song.pdf)).
  prefs: []
  type: TYPE_NORMAL
- en: 'Content sniffing can be disabled by adding the following header to our response:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'Just as with the `Cache-Control` element, the `nosniff` directive is added
    by default when using the `headers()` method with no child elements. The X-Content-Type-Options
    header is added by default within the Spring Security Java configuration. If you
    want more control over the headers, you can explicitly specify the content type
    options with the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: HTTP Strict Transport Security
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When you type in your bank's website, do you enter `mybank.example.com`, or
    do you enter `https://mybank.example.com`? If you omit the HTTPS protocol, you
    are potentially vulnerable to man in the middle attacks. Even if the website performs
    a redirect to `https://**my**bank.example.com`, a malicious user could intercept
    the initial HTTP request and manipulate the response (redirect to `https://**mi**bank.example.com`
    and steal their credentials).
  prefs: []
  type: TYPE_NORMAL
- en: Many users omit the HTTPS protocol, and this is why HSTS was created.
  prefs: []
  type: TYPE_NORMAL
- en: In accordance with *RFC6797*, the HSTS header is only injected into HTTPS responses.
    In order for the browser to acknowledge the header, the browser must first trust
    the CA that signed the SSL certificate used to make the connection, not just the
    SSL certificate ([https://tools.ietf.org/html/rfc6797](https://tools.ietf.org/html/rfc6797)).
  prefs: []
  type: TYPE_NORMAL
- en: Once `mybank.example.com` is added as an HSTS host, a browser can know beforehand
    that any request to `mybank.example.com` should be interpreted as `https://mybank.example.com`.
    This greatly reduces the possibility of a man in the middle attack occurring.
  prefs: []
  type: TYPE_NORMAL
- en: 'One way for a site to be marked as an HSTS host is to have the host preloaded
    into the browser. Another is to add the `Strict-Transport-Security` header to
    the response. For example, the following would instruct the browser to treat the
    domain as an HSTS host for a year (there are approximately `31,536,000` seconds
    in a year):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: The optional `includeSubDomains` directive instructs Spring Security that subdomains
    (such as `secure.mybank.example.com`) should also be treated as an HSTS domain.
  prefs: []
  type: TYPE_NORMAL
- en: 'As with the other headers, Spring Security adds the previous header to the
    response when the `headers()` method is specified with no child elements, but
    it is automatically added when you are using Java configuration. You can also
    only use HSTS headers with the `hsts()` method, as shown in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: X-Frame-Options
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Allowing your website to be added to a frame can be a security issue. For example,
    using clever CSS styling, users could be tricked into clicking on something that
    they did not intend to.
  prefs: []
  type: TYPE_NORMAL
- en: View a Clickjacking video demo here at [https://www.youtube.com/watch?v=3mk0RySeNsU](https://www.youtube.com/watch?v=3mk0RySeNsU).
  prefs: []
  type: TYPE_NORMAL
- en: For example, a user that is logged in to their bank might click a button that
    grants access to other users. This sort of attack is known as Clickjacking.
  prefs: []
  type: TYPE_NORMAL
- en: Read more about Clickjacking at [https://www.owasp.org/index.php/Clickjacking](https://www.owasp.org/index.php/Clickjacking).
  prefs: []
  type: TYPE_NORMAL
- en: Another modern approach to dealing with Clickjacking is using a content security
    policy. Spring Security does not provide support for this as the specification
    has not been released, and it is quite a bit more complicated. However, you could
    use the static headers feature to implement this. To stay up to date on this issue
    and to see how you can implement it with Spring Security, refer to *SEC-2117*
    at [https://github.com/spring-projects/spring-security/issues/2342](https://github.com/spring-projects/spring-security/issues/2342).
  prefs: []
  type: TYPE_NORMAL
- en: There are a number of ways to mitigate Clickjacking attacks. For example, to
    protect legacy browsers from Clickjacking attacks, you can use frame-breaking
    code. While not perfect, a frame-breaking code is the best you can do for legacy
    browsers.
  prefs: []
  type: TYPE_NORMAL
- en: 'A more modern approach to address Clickjacking is to use the X-Frame-Options
    header, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'The `X-Frame-Options` response header instructs the browser to prevent any
    site with this header in the response from being rendered within a frame. As with
    the other response headers, this is automatically included when the `headers()`
    method is specified with no child elements. You can also explicitly specify the
    frame-options element to control which headers are added to the response, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: If you want to change the value for the X-Frame-Options header, then you can
    use a `XFrameOptionsHeaderWriter instance`.
  prefs: []
  type: TYPE_NORMAL
- en: Some browsers have built-in support for filtering out reflected XSS attacks.
    This is by no means foolproof, but it does assist with XSS protection.
  prefs: []
  type: TYPE_NORMAL
- en: 'Filtering is typically enabled by default, so adding the header just ensures
    it is enabled and instructs the browser as to what to do when an XSS attack is
    detected. For example, the filter might try to change the content in the least
    invasive way to still render everything. At times, this type of replacement can
    become an XSS vulnerability in itself. Instead, it is best to block the content,
    rather than attempt to fix it. To do this, we can add the following header:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'This header is included by default when the `headers()` method is specified
    with no child elements. We can explicitly state it using the `xssProtection` element,
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: Custom Headers
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Spring Security has mechanisms to make it convenient to add more common security
    headers to your application. However, it also provides hooks to enable the adding
    of custom headers.
  prefs: []
  type: TYPE_NORMAL
- en: Static headers
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'There may be times you wish to inject custom security headers into your application
    that are not supported out of the box. For example, perhaps you wish to have early
    support for a content security policy in order to ensure that resources are only
    loaded from the same origin. Since support for a content security policy has not
    been finalized, browsers use one of two common extension headers to implement
    the feature. This means we will need to inject the policy twice. An example of
    the headers can be seen in the following code snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'When using Java configuration, these headers can be added to the response using
    the `header()` method, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: The HeadersWriter instance
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When the namespace or Java configuration does not support the headers you want,
    you can create a custom `HeadersWriter` instance or even provide a custom implementation
    of `HeadersWriter`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s take a look at an example of using a custom instance of `XFrameOptionsHeaderWriter`.
    Perhaps you want to allow the framing of content for the same origin. This is
    easily supported by setting the policy attribute to `SAMEORIGIN`, but let''s take
    a look at a more explicit example using the `ref` attribute, as shown in the following
    code snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: The DelegatingRequestMatcherHeaderWriter class
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'At times, you may want to only write a header for certain requests. For example,
    perhaps you want to only protect your login page from being framed. You could
    use the `DelegatingRequestMatcherHeaderWriter` class to do so. When using Java
    configuration, this can be done with the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we covered several security vulnerabilities, as well employing
    Spring Security to circumvent those vulnerabilities. After reading this chapter,
    you should understand the threat of CSRF and use of the synchronizer tokens to
    prevent CSRF.
  prefs: []
  type: TYPE_NORMAL
- en: You should also know how to include various HTTP headers to protect against
    common security vulnerabilities using the `Cache-Control`, `Content-Type Options`,
    HSTS, `X-Frame-Options`, and `X-XSS-Protection` methods.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will discuss how to migrate from Spring Security 3.x
    to Spring Security 4.2.
  prefs: []
  type: TYPE_NORMAL
