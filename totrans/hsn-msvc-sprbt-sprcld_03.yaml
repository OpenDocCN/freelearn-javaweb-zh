- en: Introduction to Spring Boot
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we will be introduced to how to build a set of cooperating
    microservices using Spring Boot, focusing on how to develop functionality that
    delivers business value. The challenges that we pointed out in the previous chapter
    will be considered only to some degree, but they will be addressed to their full
    extent in later chapters.
  prefs: []
  type: TYPE_NORMAL
- en: We will develop microservices that contain business logic based on plain Spring
    Beans and REST APIs using Spring WebFlux, the Swagger/OpenAPI-based documentation
    of the REST APIs, and SpringFox and data persistence, while using Spring Data
    to store data in both SQL and NoSQL databases
  prefs: []
  type: TYPE_NORMAL
- en: Since Spring Boot v2.0 was released in March 2018, it has become much easier
    to develop reactive microservices (refer to [Chapter 1](282e7b49-42b8-4649-af81-b4b6830d391d.xhtml), *Introduction
    to Microservices*, the *Reactive mi**croservices* section for more information).
    Therefore, we will also cover how to create reactive microservices in this chapter,
    including both non-blocking synchronous REST APIs and message-based asynchronous
    services. We will use Spring WebFlux to develop non-blocking synchronous REST
    APIs and Spring Cloud Stream to develop message-based asynchronous services.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, we will use Docker to run our microservices as containers. This will
    allow us to start and stop our microservice landscape, including database servers
    and a message broker, with a single command.
  prefs: []
  type: TYPE_NORMAL
- en: That's a lot of technologies and frameworks, so let's go through each of them
    briefly to see what they are about!
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Learning about Spring Boot
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Beginning with Spring WebFlux
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Exploring SpringFox
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Understanding Spring Data
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Understanding Spring Cloud Stream
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Learning about Docker
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: More details about each product will be provided in upcoming chapters.
  prefs: []
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This chapter does not contain any source code that can be downloaded, nor does
    it require any tools to be installed.
  prefs: []
  type: TYPE_NORMAL
- en: Learning about Spring Boot
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Spring Boot, and the Spring Framework that Spring Boot is based on, is a great
    framework for developing microservices in Java.
  prefs: []
  type: TYPE_NORMAL
- en: When the Spring Framework was released in v1.0 back in 2004, it was released
    in order to fix the overly complex **J2EE** standard (short for **Java 2 Platforms,
    Enterprise Edition**) with its infamous and heavyweight deployment descriptors.
    Spring Framework provided a much more lightweight development model based on the
    concept of **dependency injection** (**DI**). Spring Framework also used far more
    lightweight XML configuration files compared to the deployment descriptors in
    J2EE.
  prefs: []
  type: TYPE_NORMAL
- en: 'To make things even worse with the J2EE standard, the heavyweight deployment
    descriptors actually came in two types:'
  prefs: []
  type: TYPE_NORMAL
- en: Standard deployment descriptors, describing the configuration in a standardized
    way
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Vendor-specific deployment descriptors, mapping the configuration to vendor-specific
    features in the vendor's application server
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: J2EE was renamed in 2006 to **Java EE**, short for **Java Platform, Enterprise
    Edition**, and recently, Oracle submitted Jave EE to the Eclipse foundation. In
    February 2018, Java EE was renamed Jakarta EE.
  prefs: []
  type: TYPE_NORMAL
- en: Over the years, while the Spring Framework gained increasing popularity, the
    functionality in the Spring Framework grew significantly. Slowly, the burden of
    setting up a Spring application using the no-longer-so-lightweight XML configuration
    file became a problem.
  prefs: []
  type: TYPE_NORMAL
- en: In 2014, Spring Boot v1.0 was released, addressing these problems!
  prefs: []
  type: TYPE_NORMAL
- en: Convention over configuration and fat JAR files
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Spring Boot targets the fast development of production-ready Spring applications
    by being strongly opinionated about how to set up both core modules from the Spring
    Framework and third-party products, such as libraries that are used for logging
    or connecting to a database. Spring Boot does that by applying a number of conventions
    by default, minimizing the need for configuration. Whenever required, each convention
    can be overridden by writing some configuration, case by case. This design pattern
    is known as **convention over configuration** and minimizes the need for initial
    configuration.
  prefs: []
  type: TYPE_NORMAL
- en: Configuration, when required, is in my opinion written best using Java and annotations.
    The good old XML-based configuration files can still be used, although they are
    significantly smaller than before Spring Boot was introduced.
  prefs: []
  type: TYPE_NORMAL
- en: Added to the usage of *c**onvention over configuration*, Spring Boot also favors
    a runtime model based on a standalone JAR file, also known as a fat JAR file.
    Before Spring Boot, the most common way to run a Spring application was to deploy
    it as a WAR file on a Java EE web server, such as Apache Tomcat. WAR file deployment
    is still supported by Spring Boot.
  prefs: []
  type: TYPE_NORMAL
- en: A fat JAR file contains not only the classes and resource files of the application
    itself, but also all the `.jar` files the application depends on. This means that
    the fat JAR file is the only JAR file required to run the application; that is,
    we only need to transfer one JAR file to an environment where we want to run the
    application instead of transferring the application's JAR file along with all
    the JAR files the application depends on.
  prefs: []
  type: TYPE_NORMAL
- en: Starting a fat JAR requires no separately installed Java EE web server, such
    as Apache Tomcat. Instead, it can be started with a simple command such as `java
    -jar app.jar`, making it a perfect choice for running in a Docker container! If
    the Spring Boot application uses HTTP, for example, to expose a REST API, it will
    contain an embedded web server.
  prefs: []
  type: TYPE_NORMAL
- en: Code examples for setting up a Spring Boot application
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: To better understand what this means, let's look at some source code examples.
  prefs: []
  type: TYPE_NORMAL
- en: We will only look at some small fragments of code here to point out the main
    features. For a fully working example, you'll have to wait until the next chapter!
  prefs: []
  type: TYPE_NORMAL
- en: The magic @SpringBootApplication annotation
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The convention-based autoconfiguration mechanism can be initiated by annotating
    the application class, that is, the class that contains the static `main` method, 
    with the `@SpringBootApplication` annotation. The following code shows this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'The following functionality will be provided by this annotation:'
  prefs: []
  type: TYPE_NORMAL
- en: It enables component scanning, that is, looking for Spring components and configuration
    classes in the package of the application class and all its sub-packages.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The application class itself becomes a configuration class.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It enables autoconfiguration, where Spring Boot looks for JAR files in the classpath
    that it can configure automatically. If you, for example, have Tomcat in the classpath,
    Spring Boot will automatically configure Tomcat as an embedded web server.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Component scanning
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s assume we have the following Spring component in the package of the
    application class (or in one of its sub-packages):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'Another component in the application can get the component automatically injected,
    also known as **auto-wiring**, using the `@Autowired` annotation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: I prefer using constructor injection (over field and setter injection) to keep
    the state in my components immutable. The immutable state is important if you
    want to be able to run the component in a multithreaded runtime environment.
  prefs: []
  type: TYPE_NORMAL
- en: 'If we want to use components that are declared in a package outside the applications
    package, for example, a utility component shared by multiple Spring Boot applications,
    we can complement the `@SpringBootApplication` annotation in the application class
    with a `@ComponentScan` annotation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'We can now auto-wire components from the `se.magnus.util` package in the application
    code, for example, a utility component, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'This utility component can be auto-wired in an application component like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: Java-based configuration
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: If we want to override Spring Boot's default configuration or if we want to
    add our own configuration, we can simply annotate a class with `@Configuration` and
    it will be picked up by the component scanning mechanism we described previously.
  prefs: []
  type: TYPE_NORMAL
- en: 'If we, for example, want to set up a filter in the processing of HTTP requests
    (handled by Spring WebFlux, which is described as follows) that writes a log message
    at the beginning and at the end of the processing of the request, we can configure
    a log-filter, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: We can also place the configuration directly in the application class since
    the `@SpringBootApplication` annotation implies the `@Configuration` annotation.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have learned about Spring Boot, let's talk about Spring WebFlux.
  prefs: []
  type: TYPE_NORMAL
- en: Beginning with Spring WebFlux
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Spring Boot 2.0 is based on Spring Framework 5.0, which came with built-in support
    for developing reactive applications. Spring Framework uses **Project Reactor **as
    the base implementation of its reactive support, and also comes with a new web
    framework, Spring WebFlux, which supports the development of reactive, that is,
    non-blocking, HTTP clients and services.
  prefs: []
  type: TYPE_NORMAL
- en: 'Spring WebFlux supports two different programming models:'
  prefs: []
  type: TYPE_NORMAL
- en: An annotation-based imperative style, similar to the already existing web framework,
    Spring Web MVC, but with support for reactive services
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A new function-oriented model based on routers and handlers
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In this book, we will use the annotation-based imperative style to demonstrate
    how easy it is to move REST services from Spring Web MVC to Spring WebFlux and
    then start to refactor the services so that they become fully reactive.
  prefs: []
  type: TYPE_NORMAL
- en: Spring WebFlux also provides a fully reactive HTTP client, `WebClient`, as a
    complement to the existing `RestTemplate` client.
  prefs: []
  type: TYPE_NORMAL
- en: Spring WebFlux supports running on a servlet container (it requires Servlet
    v3.1 or higher), but also supports reactive non-servlet-based embedded web servers
    such as Netty ([https://netty.io/](https://netty.io/)).
  prefs: []
  type: TYPE_NORMAL
- en: Code examples of setting up a REST service using Spring WebFlux
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Before we can create a REST service based on Spring WebFlux, we need to add Spring
    WebFlux (and the dependencies that Spring WebFlux requires) to the classpath for
    Spring Boot to be detected and configured during startup. Spring Boot provides
    a large number of convenient *starter dependencies* that bring in a specific feature,
    together with the dependencies each feature normally requires. So, let's use the
    starter dependency for Spring WebFlux and then see what a simple REST service
    looks like!
  prefs: []
  type: TYPE_NORMAL
- en: Starter dependencies
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this book, we will use Gradle as our build tool, so the Spring WebFlux starter
    dependency will be added to the `build.gradle` file. It looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: You might be wondering why we don't specify a version number.
  prefs: []
  type: TYPE_NORMAL
- en: We will talk about that when we look at a complete example in  [Chapter 3](d26f4e61-20bf-4f55-b96d-060c7dd6f20c.xhtml),
    *Creating a Set of Cooperating Microservices*!
  prefs: []
  type: TYPE_NORMAL
- en: 'When the microservice is started up, Spring Boot will detect Spring WebFlux
    on the classpath and configure it, as well as other things that are used to start
    up an embedded web server. Netty is used by default, which we can see from the
    log output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'If we want to switch from Netty to Tomcat as our embedded web server, we can
    override the default configuration by excluding Netty from the starter dependency
    and add the starter dependency for Tomcat:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'After restarting the microservice, we can see that Spring Boot picked Tomcat
    instead:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: Property files
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As you can see from the preceding examples, the web server is started up using
    port `8080`. If you want to change the port, you can override the default value
    using a property file. Spring Boot application property files can either be a
    `.properties` file or a YAML file. By default, they are named `application.properties` and `application.yml`,
    respectively.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this book, we will use YAML files so that the HTTP port used by the embedded
    web server can be changed to `7001`. By doing this, we can avoid port collisions
    with other microservices running on the same server. To do this, add the following
    line to the `application.yml` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: Sample RestController
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Now, with Spring WebFlux and an embedded web server of our choice in place,
    we can write a REST service in the same way as when using Spring MVC, that is,
    as `RestController`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: The `@GetMapping` annotation on the `listResources()` method will map the Java
    method to an HTTP `GET` API on the `host:8080/myResource` URL. The return value
    of the `List<Resource>` type will be converted into JSON.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we've talked about Spring WebFlux, let's see what SpringFox is about.
  prefs: []
  type: TYPE_NORMAL
- en: Exploring SpringFox
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: One very important aspect of developing APIs, for example, RESTful services,
    is how to document them so that they are easy to use. When it comes to RESTful
    services, Swagger is one of the most widely used ways of documenting RESTful services.
    Many leading API gateways have native support for exposing the documentation of RESTful
    services using Swagger.
  prefs: []
  type: TYPE_NORMAL
- en: In 2015, SmartBear Software donated the Swagger specification to the Linux Foundation
    under the OpenAPI Initiative and created the OpenAPI Specification. The name Swagger
    is still used for the tooling provided by SmartBear Software.
  prefs: []
  type: TYPE_NORMAL
- en: SpringFox is an open-source project, separate from the Spring Framework, that
    can create Swagger-based API documentation at runtime. It does so by examining
    the application at startup, for example, inspecting `WebFlux` and Swagger-based annotations.
  prefs: []
  type: TYPE_NORMAL
- en: 'We will look at full source code examples in upcoming chapters, but for now
    the following screenshot of this sample API documentation will do:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/9c5f6fb1-6de7-4c81-996c-8c69ede17c43.png)'
  prefs: []
  type: TYPE_IMG
- en: Note the big Execute button, which can be used to actually try out the API,
    not just read its documentation!
  prefs: []
  type: TYPE_NORMAL
- en: SpringFox helped us understand how microservices delved into Spring Framework.
    Now, let's move on to Spring Data.
  prefs: []
  type: TYPE_NORMAL
- en: Understanding Spring Data
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Spring Data comes with a common programming model for persisting data in various
    types of database engine, ranging from traditional relational databases (SQL databases)
    to various types of NoSQL database engine, such as document databases (for example,
    MongoDB), key-value databases (for example, Redis), and graph databases (for example, Neo4J).
  prefs: []
  type: TYPE_NORMAL
- en: The Spring Data project is divided into several subprojects and in this book
    we will use Spring Data subprojects for MongoDB and JPA that have been mapped
    to a MySQL database.
  prefs: []
  type: TYPE_NORMAL
- en: '**JPA** stands for **Java Persistence API** and is a Java specification about
    how to handle relational data. Please go to [https://jcp.org/aboutJava/communityprocess/mrel/jsr338/index.html](https://jcp.org/aboutJava/communityprocess/mrel/jsr338/index.html)
    for the latest specification, which is JPA 2.2 at the time of writing.'
  prefs: []
  type: TYPE_NORMAL
- en: The two core concepts of the programming model in Spring Data are entities and
    repositories. Entities and repositories generalize how data is stored and accessed
    from the various types of database. They provide a common abstraction but still
    support adding database-specific behavior to the entities and repositories. These
    two core concepts are briefly explained together with some illustrative code examples
    as we proceed through this chapter. Remember that more details will be provided
    in the upcoming chapters!
  prefs: []
  type: TYPE_NORMAL
- en: Even though Spring Data provides a common programming model for different types
    of database, this doesn't mean that you will be able to write portable source
    code, for example, switching the database technology from a SQL database to a
    NoSQL database, without changes needing to be made to the source code!
  prefs: []
  type: TYPE_NORMAL
- en: Entity
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: An entity describes the data that will be stored by Spring Data. Entity classes
    are, in general, annotated with a mix of generic Spring Data annotations and annotations
    that are specific to each database technology.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, an entity that will be stored in a relational database can be
    annotated with JPA annotations such as the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'If an entity is to be stored in a MongoDB database, annotations from the Spring
    Data MongoDB subproject can be used together with generic Spring Data annotations.
    For example, consider the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: The `@Id` and `@Version` annotations are generic annotations, while the `@Document`
    annotation is specific to the Spring Data MongoDB subproject.
  prefs: []
  type: TYPE_NORMAL
- en: This can be revealed by studying the import statements; that is, the import
    statements that contain `mongodb` come from the Spring Data MongoDB subproject.
  prefs: []
  type: TYPE_NORMAL
- en: Repositories
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Repositories are used to store and access data from different types of database.
    In its most basic form, a repository can be declared as a Java interface, and
    Spring Data will generate its implementation on the fly using opinionated conventions.
    These conventions can be overridden and/or complemented by additional configuration
    and, if required, some Java code. Spring Data also comes with some base Java interfaces,
    for example, `CrudRepository`, to make the definition of a repository even simpler.
    The base interface, `CrudRepository`, provides us with standard methods for create,
    read, update, and delete operations.
  prefs: []
  type: TYPE_NORMAL
- en: 'To specify a repository for handling the JPA entity, `ReviewEntity`, we only
    need to declare the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'In this example we use a class, `ReviewEntityPK`, to describe a composite primary
    key. It looks as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: We have also added an extra method, `findByProductId`, which allows us to look
    up `Review` entities based on `productId` – a field that is part of the primary
    key. The naming of the method follows a naming convention defined by Spring Data
    that allows Spring Data to generate the implementation of this method on the fly
    as well.
  prefs: []
  type: TYPE_NORMAL
- en: 'If we want to use the repository, we can simply inject it and then start to
    use it, for example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: Also added to the `CrudRepository` interface, Spring Data also provides a reactive
    base interface, `ReactiveCrudRepository`, which enables reactive repositories.
    The methods in this interface do not return objects or collections of objects;
    instead, they return `Mono` and `Flux` objects.  `Mono` and `Flux` objects are,
    as we will see in later chapters, reactive streams that are capable of returning
    either `0`..`1` or `0`..`m` entities as they become available on the stream. The
    reactive-based interface can only be used by Spring Data subprojects that support
    reactive database drivers; that is, they are based on non-blocking I/O. The Spring
    Data MongoDB subproject supports reactive repositories, while Spring Data JPA
    does not.
  prefs: []
  type: TYPE_NORMAL
- en: 'Specifying a reactive repository for handling the MongoDB entity, `RecommendationEntity`,
    as described previously, might look something like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: This concludes the section on Spring Data. Now let's see what the Spring Cloud
    Stream is about.
  prefs: []
  type: TYPE_NORMAL
- en: Understanding Spring Cloud Stream
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We will not focus on Spring Cloud in this chapter; we will do that from [Chapter
    9](9a514887-19f2-4962-9736-2c0d457bfd9e.xhtml), *Adding Service Discovery Using
    Netflix Eureka and Ribbon* to [Chapter 14](42f456c5-d911-494a-a1ba-4631863068b6.xhtml),
    *Understanding Distributed Tracing*. However, we will bring in one of the modules
    that''s part of Spring Cloud: Spring Cloud Stream. Spring Cloud Stream provides
    a streaming abstraction over messaging, based on the publish-and-subscribe integration
    pattern. Spring Cloud Stream currently comes with support for Apache Kafka and
    RabbitMQ out of the box. A number of separate projects exist that provide integration
    with other popular messaging systems. See [https://github.com/spring-cloud?q=binder](https://github.com/spring-cloud?q=binder)
    for more details.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The core concepts in Spring Cloud Stream are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Message:** A data structure that''s used to describe data sent to and received
    from a messaging system.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Publisher:** Sends messages to the messaging system.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Subscriber**: Receives messages from the messaging system.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Channel:** Used to communicate with the messaging system. Publishers use
    output channels and subscribers use input channels.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Binder:** A binder provides the actual integration with a specific messaging
    system, similar to what a JDBC driver does for a specific type of database.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The actual messaging system to be used is determined at runtime, depending on
    what is found on the classpath. Spring Cloud Stream comes with opinionated conventions
    on how to handle messaging. These conventions can be overridden by specifying
    a configuration for messaging features such as consumer groups, partitioning,
    persistence, durability, and error handling, such as retries and dead letter queue
    handling.
  prefs: []
  type: TYPE_NORMAL
- en: Code examples for sending and receiving messages with Spring Cloud Stream
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: To better understand how all this fits together, let's look at some source code
    examples.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s assume that we have a simple message class such as the following (constructors,
    getters, and setters have been left out for improved readability):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'Spring Cloud Stream comes with default input and output channels, `Sink` and `Source`,
    so we don''t need to create our own to get started. To publish a message, we can
    use the following source code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'To receive messages, we can use the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'To bind to RabbitMQ, we will use a dedicated starter dependency in the build
    file, `build.gradle`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'For the subscriber to receive messages from the publisher, we need to configure
    the input and output channel to use the same destination. If we use YAML to describe
    our configuration, it might look like the following for the publisher:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'The configuration for the subscriber is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: We use `default.contentType` to specify that we prefer messages to be serialized
    in JSON format.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we understand the various Spring APIs, let's understand a concept relatively
    newer, Docker, in the next section.
  prefs: []
  type: TYPE_NORMAL
- en: Learning about Docker
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: I assume that Docker and the concept of containers need no in-depth presentation.
    Docker the concept of containers as a lightweight alternative to virtual machines
    very popular in 2013\. Containers are actually processed in a Linux host that
    uses Linux **namespaces** to provide between containers of global system resources,
    such as users, processes, filesystems, and networking. Linux control groups (also
    known as **cgroups**) are used to limit the amount of CPU and memory that a container
    is allowed to consume. Compared to a virtual machine that uses a hypervisor to
    run a complete copy of an operating system in each virtual machine, the overhead
    in a container is a fraction of the overhead in a virtual machine. This leads
    to much faster startup times and significantly lower overhead in terms of CPU
    and memory usage. The isolation that's provided for a container is, however, not
    considered to be as secure as the isolation that's provided for a virtual machine.
    With the release of Windows Server 2016, Microsoft supports the use of Docker
    in Windows servers.
  prefs: []
  type: TYPE_NORMAL
- en: Containers are very useful both during development and testing. Being able to
    start up a complete system landscape of cooperating microservices and resource
    managers (for example, database servers, messaging brokers, and so on) with a
    single command for testing is simply amazing.
  prefs: []
  type: TYPE_NORMAL
- en: For example, we can write scripts in order to automate end-to-end tests of our microservice
    landscape. A test script can start up the microservice landscape, run tests using
    the exposed services, and tear down the landscape. This type of automated test
    script is very useful, both for running locally on a developer PC before pushing
    code to a source code repository, and to be executed as a step in a delivery pipeline.
    A build server can run these types of test in its continuous integration and deployment
    process whenever a developer pushes code to the source repository.
  prefs: []
  type: TYPE_NORMAL
- en: For production usage, we need a container orchestrator such as Kubernetes. We
    will get back to container orchestrators and Kubernetes later in this book.
  prefs: []
  type: TYPE_NORMAL
- en: 'For most of the microservices we will look at in this book, a Dockerfile such
    as the following is all that is required to run the microservice as a Docker container:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'If we want to start and stop many containers with one command, Docker Compose
    is the perfect tool. Docker Compose uses a YAML file to describe the containers
    to be managed. For our microservices, it might look something like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'Let me explain the preceding source code a little:'
  prefs: []
  type: TYPE_NORMAL
- en: The `build` directive is used to specify which Dockerfile to use for each microservice.
    Docker Compose will use it to build a Docker image and then launch a Docker container
    based on that Docker image.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `ports` directive for the composite service is used to expose port `8080`
    on the server where Docker runs. On a developer's machine, this means that the
    port of the composite service can be reached simply by using `localhost:8080`!
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'All the containers in the YAML files can be managed with simple commands such
    as the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '`docker-compose up -d`: Starts all containers. `-d` means that the containers
    run in the background, not locking the Terminal from where the command was executed.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`docker-compose down`: Stops and removes all containers.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`docker-compose logs -f --tail=0`: Prints out log messages from all containers. `-f`
    means that the command will not complete, and instead waits for new log messages. `--tail=0`
    means that we don''t want to see any previous log messages, only new ones.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: This was a brief introduction to Docker. We will go into more detail about Docker
    in the last few chapters of this book.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we have been introduced to Spring Boot and complementary open
    source tools that can be used to build cooperating microservices.
  prefs: []
  type: TYPE_NORMAL
- en: Spring Boot is used to simplify the development of Spring-based, production-ready
    applications. It is strongly opinionated in terms of how to set up both core modules
    from the Spring Framework and third-party products.
  prefs: []
  type: TYPE_NORMAL
- en: Spring WebFlux is a new module in the Spring family and is used to develop reactive,
    that is, non-blocking, REST services. It runs on both lightweight web servers
    such as Netty and on any Servlet 3.1+ compatible web server. It also supports
    the programming model from the older Spring MVC module; it is easy to move REST
    services written for Spring MVC to Spring WebFlux without fully rewriting the
    code.
  prefs: []
  type: TYPE_NORMAL
- en: SpringFox can be used to create Swagger and OpenAPI-based documentation regarding
    REST services. It creates the documentation on the fly at runtime by inspecting
    the annotations for the REST services – both the Spring annotations and some Swagger
    specific annotations – if used.
  prefs: []
  type: TYPE_NORMAL
- en: Spring Data provides an elegant abstraction for accessing and manipulating persistent
    data using entities and repositories. The programming model is similar, but isn't
    portable between different types of database, for example, relational, document,
    key-value, and graph databases.
  prefs: []
  type: TYPE_NORMAL
- en: Spring Cloud Stream provides a streaming abstraction over messaging, based on
    the publish and subscribe integration pattern. Spring Cloud Stream comes with
    out of the box support for Apache Kafka and RabbitMQ but can be extended to support
    other messaging brokers using custom binders.
  prefs: []
  type: TYPE_NORMAL
- en: Docker makes the concept of containers as a lightweight alternative to virtual
    machines easy to use. Based on Linux Namespaces and Control Groups, containers
    provide isolation similar to what traditional virtual machines provide, but with
    a significantly lower overhead in terms of CPU and memory usage. Docker is a very
    good tool for development and testing but in most cases requires a container orchestrator
    such as Kubernetes to be used in a production environment.
  prefs: []
  type: TYPE_NORMAL
- en: Questions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: What is the purpose of the `@SpringBootApplication` annotation?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What are the main differences between the older Spring component for developing
    REST services, Spring Web MVC, and the new Spring WebFlux?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How does SpringFox help a developer document REST APIs?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What is the function of a repository in Spring Data and what is the simplest
    possible implementation of a repository?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What is the purpose of a binder in Spring Cloud Stream?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What is the purpose of Docker Compose?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
