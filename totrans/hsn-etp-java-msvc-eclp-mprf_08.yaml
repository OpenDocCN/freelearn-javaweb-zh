- en: MicroProfile OpenAPI and Type-Safe REST Client
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Eclipse MicroProfile has a rich set of specifications for Java microservices.
    Two of these, Eclipse MicroProfile OpenAPI and Eclipse MicroProfile REST Client,
    help with the API documentation for your microservices and provide an API for
    type-safe invocation on REST endpoints, respectively. OpenAPI simplifies the documentation
    for microservice endpoints and makes this metadata available for perusal by third-party
    developers. A type-safe REST client simplifies the marshalling and unmarshalling
    of objects to HTTP or JSON.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following topics will be covered in this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: The capabilities offered by each of these specifications
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Simple code examples of some of these capabilities
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to obtain further information about each of these specifications
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Introduction to MicroProfile OpenAPI and its capabilities
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The mobile force that fuels the digital economy led to the need for businesses
    to establish an omni-channel approach to development in order to optimize costs,
    increase efficiencies, and improve customer experience. A facilitator of this
    approach was APIs, which led to the API economy and concepts such as API-led or
    API-first development practices. In addition, the microservices architecture has
    become the architecture of choice for modern development. API-based (that is,
    RESTful) communication among microservices has been adopted as the *de facto*
    standard because it is a good fit for the *smart endpoints and dumb pipes*, *decentralized
    governance*, and *decentralized data management* characteristics of microservices.
  prefs: []
  type: TYPE_NORMAL
- en: However, as the number of microservices increases in a microservices architecture,
    their management can become unwieldy. However, you can manage your microservices
    via their APIs. You can apply management, security, load balancing, and throttling
    policies to the APIs that are fronting your microservices.
  prefs: []
  type: TYPE_NORMAL
- en: 'Eclipse MicroProfile OpenAPI provides Java interfaces to developers for generating
    OpenAPI v3 documents from their Java RESTful Web Services (JAX-RS) applications.
    The specification requires that a fully processed OpenAPI document be available
    at the root URL, `/openapi`, as an HTTP `GET` operation, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: The required protocol is `http`. However, implementors of the specification
    are strongly encouraged to also support the `https` protocol for secure connectivity
    to the OpenAPI endpoint.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are three sources from which the OpenAPI document is created. These three
    sources (described in later sections in this chapter) are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Generated by processing the JAX-RS annotations (and optional OpenAPI annotations)
    found in the application
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Programmatically built by an application by providing a Java class that implements
    `OasModelReader`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A static OpenAPI document included in application deployment
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: These three sources (any combination) are combined to produce a single OpenAPI
    document, which can be filtered (by providing a Java class that implements the
    `OasFilter` interface) and then served at the preceding `/openapi` endpoint.
  prefs: []
  type: TYPE_NORMAL
- en: Configuration
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The MicroProfile OpenAPI specification makes use of the MicroProfile configuration
    specification to configure its parameters and values. For example, for injecting
    configuration values, MicroProfile OpenAPI can use the default and custom ConfigSources.
  prefs: []
  type: TYPE_NORMAL
- en: For more information on ConfigSources, you can visit [https://github.com/eclipse/microprofile-config/blob/master/spec/src/main/asciidoc/configsources.asciidoc](https://github.com/eclipse/microprofile-config/blob/master/spec/src/main/asciidoc/configsources.asciidoc).
  prefs: []
  type: TYPE_NORMAL
- en: 'There are many configurable items. The following table contains a subset of
    them:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Configuration item** | **Description** |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `mp.openapi.scan.di sable` | Configuration property to disable annotation
    scanning. The default value is `false`. |'
  prefs: []
  type: TYPE_TB
- en: '| `mp.openapi.servers` | Configuration property to specify the list of global
    servers that ... |'
  prefs: []
  type: TYPE_TB
- en: Generating the OpenAPI document
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As already described, the MicroProfile OpenAPI specification requires that an
    OpenAPI document be generated from a combination of three sources.
  prefs: []
  type: TYPE_NORMAL
- en: 'You then have a number of choices:'
  prefs: []
  type: TYPE_NORMAL
- en: Extend the OpenAPI document generated by the JAX-RS annotations using the MicroProfile
    OpenAPI annotations.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Leverage the initial output from `/openapi`, which you can use as a reference
    to start documenting your APIs. In this case, you can write static OpenAPI files
    (described in a later section in this chapter) before any code is written, which
    is a usual approach adopted by organizations to lock-in the contract of the API,
    that is, it is an API-first development practice.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Bootstrap or complete the OpenAPI model tree by coding using the programming
    model, covered later in this chapter.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Additionally, you can use a filter to update the OpenAPI model after it has
    been built.
  prefs: []
  type: TYPE_NORMAL
- en: MicroProfile OpenAPI annotations
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Probably the most common source of OpenAPI information is the set of annotations
    that make up the definition of a standard JAX-RS application. These annotations,
    along with additional (optional) annotations defined by the MicroProfile OpenAPI
    specification, can be scanned and processed by the MicroProfile platform to produce
    an OpenAPI document.
  prefs: []
  type: TYPE_NORMAL
- en: The MP OpenAPI specification requires the generation of a valid OpenAPI document
    from pure JAX-RS 2.0 applications. If you are new to OpenAPI, you can simply deploy
    your existing JAX-RS application to a MicroProfile OpenAPI runtime and check out
    the output from `/openapi`.
  prefs: []
  type: TYPE_NORMAL
- en: To fill out additional details of the generated OpenAPI document, you may further
    annotate your ...
  prefs: []
  type: TYPE_NORMAL
- en: Usage examples
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Some usage examples of MicroProfile OpenAPI annotations are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Example 1 – Simple operation description (abbreviated):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'The following is the output for example 1:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'Example 2 – Operation with different responses (abbreviated):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'The following is the output for example 2:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: For more examples, please refer to the MicroProfile OpenAPI specification wiki
    at [https://github.com/eclipse/microprofile-open-api/wiki](https://github.com/eclipse/microprofile-open-api/wiki).
  prefs: []
  type: TYPE_NORMAL
- en: Static OpenAPI files
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As mentioned earlier in the chapter, static OpenAPI files are one of the three
    sources from which the OpenAPI document can be created. In the following, we give
    you a short introductory description of how you could generate one and how to
    include it in your deployment. Many organizations use an API-first development
    practice, which entails defining static OpenAPI files even before any code is
    implemented for them.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, you can create an OpenAPI document by using an open source editor such
    as Swagger Editor ([https://editor.swagger.io](https://editor.swagger.io)). The
    following is a screenshot shows this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/db11ee83-6eab-4cfd-a4c1-089959d1e197.png)'
  prefs: []
  type: TYPE_IMG
- en: Using this editor, you can start with sample ...
  prefs: []
  type: TYPE_NORMAL
- en: Programming model
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: You can provide OpenAPI elements via Java POJOs (Plain Old Java Objects) by
    using the MicroProfile OpenAPI programming model. The complete set of models is
    described in the `org.eclipse.microprofile.openapi.models` package. You can read
    more about it at [https:](https://github.com/eclipse/microprofile-open-api/tree/master/api/src/main/java/org/eclipse/microprofile/openapi/models)[//github.com/eclipse/microprofile-open-api/tree/master/api/src/main/java/org/eclipse/microprofile/openapi/models](https://github.com/eclipse/microprofile-open-api/tree/master/api/src/main/java/org/eclipse/microprofile/openapi/models).
  prefs: []
  type: TYPE_NORMAL
- en: 'You can create an OpenAPI tree by using `OASFactory`. Refer to the following
    code block by way of an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: To bootstrap the OpenAPI model tree, you can use the `OASModelReader` interface.
    You can then create an implementation of this interface and register it using
    the `mp.openapi.model.reader` configuration key.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following is globally an example of what its definition would look like
    in `META-INF/microprofile-config.properties`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: Like static files, the model reader can be used to provide either complete or
    partial model trees. To provide a complete OpenAPI model tree, you should set
    the `mp.openapi.scan.disable` configuration to `true`. Otherwise, this partial
    model will be assumed.
  prefs: []
  type: TYPE_NORMAL
- en: Using a filter for updates
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: To update or remove certain elements and fields of the OpenAPI document, you
    can use a filter. The OASFilter ([https://github.com/eclipse/microprofile-open-api/blob/master/api/src/main/java/org/eclipse/microprofile/openapi/OASFilter.java](https://github.com/eclipse/microprofile-open-api/blob/master/api/src/main/java/org/eclipse/microprofile/openapi/OASFilter.java))
    interface allows you to receive callbacks for various OpenAPI elements. It allows
    you to override the methods you care about. You can create an implementation of
    this interface and register it using the `mp.openapi.filter` configuration key.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here''s an example of what its definition would look like in `META-INF/microprofile-config.properties`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: A registered filter is called once for each model element. For example, the
    `filterPathItem` method is ...
  prefs: []
  type: TYPE_NORMAL
- en: Introduction to the MicroProfile REST Client and its capabilities
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The **MicroProfile REST Client** (**MP-RC**) provides an API for type-safe invocation
    on REST endpoints. It can be used from applications to perform remote invocations
    on other services.
  prefs: []
  type: TYPE_NORMAL
- en: It leverages JAX-RS annotations on Java interfaces to describe the actual contract
    with remotes services. These interfaces are then used to create client proxies
    that hide much of the underlying HTTP communication.
  prefs: []
  type: TYPE_NORMAL
- en: The MP-RC specification defines the requirements for leveraging the JAX-RS annotations
    on the Java interface, as well as MP-RC-specific annotations to augment behavior,
    including how incoming request headers should be propagated, how to augment JAX-RS
    behaviors using providers, exception mapping, CDI support, and integration with
    other MicroProfile specifications. We will look at MP-RC in more detail by starting
    with the definition of a type-safe endpoint interface.
  prefs: []
  type: TYPE_NORMAL
- en: Defining the endpoint Interface
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To define the type-safe interface for an endpoint, we create a Java interface
    that leverages JAX-RS annotations to map interface methods to the REST endpoint
    they proxy. A basic example is illustrated in the following `WorldClockApi` interface:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: MicroProfile REST Client programmatic API usage
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'MP-RC supports both programmatic lookup and CDI injection approaches for usage.
    An example of a REST service making use of `org.eclipse.microprofile.rest.client.RestClientBuilder`
    to create a type-safe client for the `WorldClockApi` interface is listed in the
    following as `WorldClockUser.java`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'The `baseUri()` method is used to specify the server URI against which the
    `WorldClockApi` method paths are to be resolved. The `build()` method takes the
    Java interface of the type-safe client that is to be built. Additional `RestClientBuilder`
    methods include the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '`baseUrl(URL)`: Similar to `baseUri`, but takes a `java.net.URL` type.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`connectTimeout(long timeout, TimeUnit unit)`: The amount of time to wait to
    connect to the remote server. A value of 0 indicates having to wait forever.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`readTimeout(long timeout, TimeUnit unit)`: The amount of time to wait on reads
    of the remote server connection. A value of 0 indicates having to wait forever.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`executorService(ExecutorService executor)`: Used for async requests. We will
    return to this in the async section.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: MicroProfile REST Client CDI usage
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'MP-RC type-safe interfaces may be injected as CDI beans. The runtime must create
    a CDI bean for each interface annotated with `@RegisterRestClient`. A CDI client
    injects bean created will include a qualifier, `@RestClient` , to differentiate
    use as an MP-RC injection point. The following update to our `WorldClockApi` interface
    illustrates the use of the `@RegisterRestClient` annotation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: MicroProfile Config integration
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'For CDI-defined interfaces, it is possible to use MicroProfile Config properties
    to define additional behaviors that are available via the `RestClientBuilder`
    API. Given our `io.pckt.restc.contract.WorldClockApi` interface, the following
    MicroProfile Config properties are available to control the generated proxy behavior:'
  prefs: []
  type: TYPE_NORMAL
- en: '`io.pckt.restc.contract.WorldClockApi/mp-rest/url`: The base URL to use for
    this service, the equivalent of the `RestClientBuilder#baseUrl` method.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`io.pckt.restc.contract.WorldClockApi/mp-rest/scope`: The fully qualified class
    name to a CDI scope to use for injection; it defaults to `javax.enterprise.context.Dependent`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`io.pckt.restc.contract.WorldClockApi/mp-rest/providers`: A comma-separated
    list of fully qualified provider class names to include in the client, the equivalent
    of the `RestClientBuilder#register` method or the `@RegisterProvider` annotation.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`io.pckt.restc.contract.WorldClockApi/mp-rest/providers/com.mycompany.MyProvider/priority`:
    This will override the priority of the `com.mycompany.MyProvider` provider for
    this interface.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`io.pckt.restc.contract.WorldClockApi/mp-rest/connectTimeout`: The timeout
    specified in milliseconds to wait to connect to the remote endpoint.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`io.pckt.restc.contract.WorldClockApi/mp-rest/readTimeout`: The timeout specified
    in milliseconds to wait for a response from the remote endpoint.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Simplifying configuration keys
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Since the default MP Config property names for a CDI interface can be quite
    long due to the inclusion of the interface package name, the MP-RC specification
    supports a way to simplify the property name prefix using the `configKey` attribute
    of the `@RegisterRestClient` annotation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'With the `worldClock` configKey, the previous list of property names simplifies
    to the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '`worldClock/mp-rest/url`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`worldClock/mp-rest/uri`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`worldClock/mp-rest/scope`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`worldClock/mp-rest/providers`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`worldClock/mp-rest/providers/com.mycompany.MyProvider/priority ...`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Dealing with client headers
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Let's say you want to specify credentials in the HTTP authorization header to
    a secure remote service, but you do not want to have a string `authHeader` parameter
    in the client interface method. The MP-RC `@ClientHeaderParam` annotation can
    be used to specify HTTP headers that should be sent without altering the client
    interface method signature.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following example illustrates two uses of the `@ClientHeaderParam` annotation
    to provide a `User-Agent` HTTP header in a variation of the `WorldClockApi` interface:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'It is also possible to add or propagate headers in bulk using a `ClientHeadersFactory`
    implementation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'In the preceding code snippet, the `incomingHeaders` and `clientOutgoingHeaders`
    parameters are used as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '`incomingHeaders`: Represents the map of headers for the inbound request'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`clientOutgoingHeaders`: Represents the read-only map of header values specified
    on the client interface, the union of header values from `@ClientHeaderParam`,
    `@HeaderParam`, and so on'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `update` method should return a `MultivaluedMap` that contains the headers
    to merge with the `clientOutgoingHeaders` map for the complete map of headers
    to be sent to the outbound request. Providers such as filters, interceptors, and
    message body writers could still modify the final map of headers prior to sending
    the HTTP request.
  prefs: []
  type: TYPE_NORMAL
- en: To enable a `ClientHeadersFactory`, the client interface must be annotated with
    the `@RegisterClientHeaders` annotation. If this annotation specifies a value,
    the client implementation must invoke an instance of the specified `ClientHeadersFactory`
    implementation class. If no value is specified, then the client implementation
    must invoke `DefaultClientHeadersFactoryImpl`. This default factory will propagate
    specified headers from the inbound JAX-RS request to the outbound request – these
    headers are specified with a comma-separated list using the MicroProfile Config
    property, `org.eclipse.microprofile.rest.client.propagateHeaders`.
  prefs: []
  type: TYPE_NORMAL
- en: Provider registration for advanced usage
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `RestClientBuilder` interface extends the `Configurable` interface from
    JAX-RS, allowing a user to register custom providers while it is being built.
    The behavior of the providers supported is defined by the JAX-RS Client API specification.
    An MP-RC implementation will support `ClientResponseFilter`, `ClientRequestFilter`,
    `MessageBodyReader`, `MessageBodyWriter`, `ParamConverter`, `ReaderInterceptor`,
    and `WriterInterceptor` from JAX-RS.
  prefs: []
  type: TYPE_NORMAL
- en: For the `ClientResponseFilter` and `ClientRequestFilter` interfaces that have
    a `ClientRequestContext` parameter in their `filter` method, MP-RC implementations
    add an `org.eclipse.microprofile.rest.client.invokedMethod` property, the value
    of which is the `java.lang.reflect.Method` object ...
  prefs: []
  type: TYPE_NORMAL
- en: Provider priority
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Providers may be registered via both annotations and `RestClientBuilder`. Providers
    registered via a builder will take precedence over the `@RegisterProvider` annotation.
    The `@RegisterProvider` annotation priority value takes precedence over any `@javax.annotation.Priority`
    annotation on the class. Provider priorities can be overridden when using the
    register methods on the `RestClientBuilder` interface as it allows for priority.
  prefs: []
  type: TYPE_NORMAL
- en: Feature registration
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: If the type of provider registered is a JAX-RS `Feature`, then the priority
    set by that `Feature` will be part of the builder as well. Implementations maintain
    the overall priority of registered providers, regardless of how they are registered.
    `Feature` will be used to register additional providers at runtime, and may be
    registered via `@RegisterProvider`, configuration, or via `RestClientBuilder`.
    `Feature` will be executed immediately. As a result, its priority is not taken
    into account (features are always executed).
  prefs: []
  type: TYPE_NORMAL
- en: Default providers
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'MP-RC implementations must provide a minimum set of providers, including the
    following:'
  prefs: []
  type: TYPE_NORMAL
- en: '`*/json` types:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: JSON-P, `javax.json.JsonValue`
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: JSON-B, `javax.json.bind`
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`*` types:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`byte[]`'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`java.lang.String`'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`java.io.InputStream`'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`java.io.Reader`'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`text/plain` types:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`java.lang.Number and subtypes`'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`int, long, float and double`'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`java.lang.Character and char`'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`java.lang.Boolean and boolean`'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Exception mapping
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'MP-RC provides support for mapping an invocation response into an exception
    via the `org.eclipse.microprofile.rest.client.ext.ResponseExceptionMapper` interface:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: Consider the following ...
  prefs: []
  type: TYPE_NORMAL
- en: Default exception mapping
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Each implementation provides a default `ResponseExceptionMapper` implementation
    that will map and invoke a response to `javax.ws.rs.WebApplicationException` when
    the response status code is >= 400\. It has a priority of `Integer.MAX_VALUE`,
    and is meant to be used as a fallback whenever an error is encountered. This mapper
    will be registered by default to all client interfaces, but this can be disabled
    by setting an MP Config property, `microprofile.rest.client.disable.default.mapper`,
    to `true`. It can also be disabled on a per-client basis by using the same property
    when building the client:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: Async support
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'MP-RC supports asynchronous method invocations. A client interface method is
    asynchronous when the return type of the method is of the `java.util.concurrent.CompletionStage<?>`
    type. An alternative version, called `WorldClockApiAsync.java`, of the `WorldClockApi`
    interface that declares an asynchronous method is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we have learned about two Eclipse MicroProfile specifications,
    namely, Eclipse MicroProfile OpenAPI and Eclipse MicroProfile REST Client. The
    former provides a specification for generating OpenAPI-compliant documentation
    for your microservices, and the latter supplies a specification for calling REST
    endpoints in a type-safe manner. In this chapter, we covered the specific capabilities
    of these specifications, provided some example code, and supplied pointers on
    how to get further information about these specifications. You have learned the
    features and capabilities of the Eclipse MicroProfile OpenAPI and Eclipse MicroProfile
    REST Client specifications, how to use their annotations and programmatic interfaces,
    and how you could incorporate them into your applications.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will discuss and delve into the open source implementations
    of Eclipse MicroProfile that currently exist on the market.
  prefs: []
  type: TYPE_NORMAL
- en: Questions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Do you need to do anything to get information supplied to the `/openapi` endpoint?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Can I enhance OpenAPI output with just one or two extra annotations?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What is the point of using static OpenAPI files?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Do I need the REST endpoint microservice I want to use to provide the MP-REST
    interface?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How do you externalize the base URL for a type-safe interface?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What if I need to propagate incoming request headers?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
