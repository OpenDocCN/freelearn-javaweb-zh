- en: Using Spring Cloud Gateway to Hide Microservices Behind an Edge Server
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we will learn how to use Spring Cloud Gateway as an edge server,
    that is, to control what APIs are exposed from our microservices-based system
    landscape. We will see how microservices that have public APIs will be made accessible
    from the outside through the edge server, while microservices that have private
    APIs only will be accessible from the inside of the microservice landscape. In
    our system landscape, this means that the product composite service and the discovery
    service, Netflix Eureka, will be exposed through the edge server. The three core
    services—`product`, `recommendation`, and `review`—will be hidden from the outside.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following topics will be covered in this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: Adding an edge server to our system landscape
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Setting up a Spring Cloud Gateway, including configuring routing rules
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Trying out the edge server
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: All commands described in this book are run on a MacBook Pro using macOS Mojave,
    but should be straightforward to modify in order to run on another platform such
    as Linux or Windows.
  prefs: []
  type: TYPE_NORMAL
- en: No new tools need to be installed in this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: The source code for this chapter can be found on GitHub: [https://github.com/PacktPublishing/Hands-On-Microservices-with-Spring-Boot-and-Spring-Cloud/tree/master/Chapter10](https://github.com/PacktPublishing/Hands-On-Microservices-with-Spring-Boot-and-Spring-Cloud/tree/master/Chapter10).
  prefs: []
  type: TYPE_NORMAL
- en: 'To be able to run the commands as described in this book, download the source
    code to a folder and set up an environment variable, `$BOOK_HOME`, that points
    to that folder. The following are sample commands:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: The Java source code is written for Java 8 and tested on Java 12\. This chapter
    uses Spring Cloud 2.1.0, SR1 (also known as the **Greenwich** release), Spring
    Boot 2.1.3, and Spring 5.1.5, which is the latest available version of the Spring
    components at the time of writing this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: 'The source code contains the following Gradle projects:'
  prefs: []
  type: TYPE_NORMAL
- en: '`api`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`util`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`microservices/product-service`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`microservices/review-service`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`microservices/recommendation-service`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`microservices/product-composite-service`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`spring-cloud/eureka-server`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`spring-cloud/gateway`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The code examples in this chapter all come from source code in `$BOOK_HOME/Chapter10` but
    are, in several cases, edited to remove non-relevant parts of the source code,
    such as comments, and import and log statements.
  prefs: []
  type: TYPE_NORMAL
- en: If you want to see the changes applied to the source code in [Chapter 10](a3383211-405d-4319-b142-ddb8cf3674fd.xhtml), *Using
    Spring Cloud Gateway to Hide Microservices Behind an Edge Server*, that is, see what
    it took to add Spring Cloud Gateway as an edge server to the microservices landscape, you
    can compare it with the source code for [Chapter 9](9a514887-19f2-4962-9736-2c0d457bfd9e.xhtml),
    *Adding Service Discovery Using Netflix Eureka and Ribbon*. You can use your favorite `diff` tool
    and compare the two folders, `$BOOK_HOME/Chapter09` and `$BOOK_HOME/Chapter10`.
  prefs: []
  type: TYPE_NORMAL
- en: Adding an edge server to our system landscape
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this section we will see how the edge server is added to the system landscape
    and how it affects the way external clients access the public APIs that the microservices
    expose. All incoming requests will now be routed through the edge server, as illustrated
    by the following diagram:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/3ec7ce9c-d8a1-48bd-a0af-932a2b44ed6b.png)'
  prefs: []
  type: TYPE_IMG
- en: As we can see from the preceding diagram, external clients send all their requests
    to the edge server. The edge server can route the incoming requests based on the
    URL path. For example, requests with a URL that starts with `/product-composite/`
    are routed to the **Product Composite** microservice, and a request with a URL
    that starts with `/eureka/` is routed to the **Discovery Server** based on Netflix
    Eureka.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the previous [Chapter 9](9a514887-19f2-4962-9736-2c0d457bfd9e.xhtml), *Adding
    Service Discovery Using Netflix Eureka and Ribbon*, we exposed both the `product-composite`
    service and the discovery service, Netflix Eureka, to the outside. When we introduce
    the edge server in this chapter, this will no longer be the case.  This is implemented
    by removing the following port declarations for the two services in the Docker
    Compose files:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: With the edge serve added to the system landscape, we will learn how to set
    up an edge server based on Spring Cloud Gateway in the next section.
  prefs: []
  type: TYPE_NORMAL
- en: Setting up a Spring Cloud Gateway
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section, we will learn how to set up an edge server based on Spring
    Cloud Gateway.
  prefs: []
  type: TYPE_NORMAL
- en: 'Setting up a Spring Cloud Gateway as an edge server is straightforward and
    can be done by means of the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Create a Spring Boot project using Spring Initializr as described in [Chapter
    3](d26f4e61-20bf-4f55-b96d-060c7dd6f20c.xhtml), *Creating a Set of Cooperating
    Microservices—*refer to the *Using Spring Initializr to generate skeleton code*
    section.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Add a dependency to `spring-cloud-starter-gateway`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: To be able to locate microservices instances though Netflix Eureka, also add
    the `spring-cloud-starter-netflix-eureka-client` dependency.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Add the edge server to the common build file, `settings.gradle`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: Add a Dockerfile with the same content as for our microservices.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Add the edge server to our three Docker Compose files:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: Port `8080` of the edge server is exposed outside the Docker engine. The memory
    limit of 350 MB is to ensure that all containers in this and the coming chapters
    will fit in the 6 GB of memory that we have allocated to the Docker engine
  prefs: []
  type: TYPE_NORMAL
- en: Add configuration for routing rules and more; refer to the *Configuring a Spring
    Cloud Gateway* section as we proceed in this chapter.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Since the edge server will handle all incoming traffic, we will move the composite health
    check from the product composite service to the edge server. This is described
    in *Adding a composite health check* section.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: You can find the source code for the Spring Cloud Gateway in `$BOOK_HOME/Chapter10/spring-cloud/gateway`.
  prefs: []
  type: TYPE_NORMAL
- en: Adding a composite health check
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: With an edge server in place, external health check requests also have to go through
    the edge server. Therefore, the composite health check that checks the status
    of all microservices been moved from the `product-composite` service to the edge
    server. See [Chapter 7](436fb8c1-0c4d-410c-a3ec-da251aba4ca1.xhtml), *Developing
    Reactive Microservices—*refer to the *Adding a health API* section for implementation
    details of the composite health check.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following has been added to the edge server:'
  prefs: []
  type: TYPE_NORMAL
- en: 'The `se.magnus.springcloud.gateway.HealthCheckConfiguration` class has been
    added, which declares the health indicator:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: We have added the `product-composite` service to the composite health check!
  prefs: []
  type: TYPE_NORMAL
- en: 'The main application class, `se.magnus.springcloud.gateway.GatewayApplication`, declares
    a `WebClient.builder` bean to be used by the implementation of the health indicator
    as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: From the preceding source code, we see that `WebClient.builder` is annotated
    with `@LoadBalanced`, which makes it aware of microservice instances registered
    in the discovery server, Netflix Eureka. Refer to the *Service discovery with
    Netflix Eureka in Spring Cloud* section in [Chapter 9](9a514887-19f2-4962-9736-2c0d457bfd9e.xhtml),
    *Adding Service Discovery Using Netflix Eureka and Ribbon, *for details.
  prefs: []
  type: TYPE_NORMAL
- en: With a composite health check in place in the edge server, we are ready to look
    at the configuration that can be set up for a Spring Cloud Gateway.
  prefs: []
  type: TYPE_NORMAL
- en: Configuring a Spring Cloud Gateway
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'When it comes to configuring a Spring Cloud Gateway, the most important thing is setting
    up the routing rules. We also need to set up a few other things in the configuration:'
  prefs: []
  type: TYPE_NORMAL
- en: Since Spring Cloud Gateway will use Netflix Eureka to find the microservices
    it will route traffic to, so it must be configured as a Eureka client in the same
    way as described in [Chapter 9](9a514887-19f2-4962-9736-2c0d457bfd9e.xhtml), *Adding
    Service Discovery Using Netflix Eureka and Ribbon*—refer to the *Configuration
    of clients to the Eureka server* section.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Configure Spring Boot Actuator for development usage as described in [Chapter
    7](436fb8c1-0c4d-410c-a3ec-da251aba4ca1.xhtml), *Developing Reactive Microservices—*refer
    to the *Adding a health API* section:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'Configure log levels so that we can see log messages from interesting parts
    of the internal processing in the Spring Cloud Gateway, for example, how it decides
    where to route incoming requests to:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'For the full source code, refer to the configuration file: `src/main/resources/application.yml`.'
  prefs: []
  type: TYPE_NORMAL
- en: Routing rules
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Setting up routing rules can be done in two ways; programmatically, using a
    Java DSL, or by configuration. Using the Java DSL to set up the routing rules
    programmatically can be useful in cases where the rules are stored in external
    storage, such as a database, or are given at runtime, for example, via a RESTful
    API or a message sent to the gateway. In most cases, I find it convenient to declare
    the routes in the configuration file, `src/main/resources/application.yml`.
  prefs: []
  type: TYPE_NORMAL
- en: 'A **route** is defined by the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Predicates**, which select a route based on information in the incoming HTTP
    request'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Filters**, which can modify both the request and/or the response'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: A **destination URI**, which describes where to send a request
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: An **ID**, that is, the name of the route
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: For a full list of available predicates and filters, refer to the reference
    documentation: [https://cloud.spring.io/spring-cloud-gateway/single/spring-cloud-gateway.html](https://cloud.spring.io/spring-cloud-gateway/single/spring-cloud-gateway.html).
  prefs: []
  type: TYPE_NORMAL
- en: Routing requests to the product-composite API
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'If we, for example, want to route incoming requests where the URL path starts
    with `/product-composite/` to our `product-composite` service, we can specify
    a routing rule like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'The following are some points to take from the preceding code:'
  prefs: []
  type: TYPE_NORMAL
- en: '`id: product-composite`: The name of the route is `product-composite`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`uri: lb://product-composite`: If the route is selected by its predicates,
    the request will be routed to the service that is named `product-composite` in
    the discovery service, that is, Netflix Eureka. `lb://` is used to direct Spring
    Cloud Gateway to use the client-side load balancer to look up the destination
    in the discovery service.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`predicates:- Path=/product-composite/**` is used to specify what requests
    this route should match. `**` matches zero or more elements in the path.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Routing requests to the Eureka server's API and web page
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Eureka exposes both an API and a web page for its clients. To provide a clean
    separation between the API and the web page in Eureka, we will set up routes as
    follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Requests sent to the edge server with the path starting with `/eureka/api/`
    should be handled as a call to the Eureka API.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Requests sent to the edge server with the path starting with `/eureka/web/`
    should be handled as a call to the Eureka web page.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'API requests will be routed to `http://${app.eureka-server}:8761/eureka`. The
    route rule for the Eureka API looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: The `{segment}` part in the `Path` value matches zero or more elements in the
    path and will be used to replace the `{segment}` part in the `SetPath` value.
  prefs: []
  type: TYPE_NORMAL
- en: 'Web page requests will be routed to `http://${app.eureka-server}:8761`. The
    web page will load several web resources, such as `.js`, `.css`, and `.png` files.
    These requests will be routed to `http://${app.eureka-server}:8761/eureka`. The
    route rules for the Eureka web page look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'From the preceding configuration, we can take the following notes: The `${app.eureka-server}`
    property is resolved by Spring''s property mechanism depending on what Spring
    profile is activated:'
  prefs: []
  type: TYPE_NORMAL
- en: When running the services on the same host without using Docker, for example,
    for debugging purposes, the property will be translated to `localhost` using the
    `default` profile.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: When running the services as Docker containers, the Netflix Eureka server will
    run in a container with the DNS name `eureka`. Therefore, the property will be
    translated into `eureka` using the `docker` profile.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The relevant parts in the `application.yml` file that defines this translation
    look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: Routing requests with predicates and filters
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: To learn a bit more about the routing capabilities in Spring Cloud Gateway,
    we will try out host-based routing; that is, where Spring Cloud Gateway uses the
    hostname of the incoming request to determine where to route the request. We will
    use one of my favorite websites for testing HTTP codes: [http://httpstat.us/](http://httpstat.us/).
  prefs: []
  type: TYPE_NORMAL
- en: 'A call to `http://httpstat.us/${CODE}` simply returns a response with the `${CODE}`
    HTTP code and a response body containing the HTTP code and a corresponding descriptive
    text. For example, see the following `curl` command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: This will return the HTTP code 200, and a response body with the text, 200 OK.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s assume that we want to route calls to `http://${hostname}:8080/headerrouting` as
    follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Calls to the `i.feel.lucky` host should return 200 OK.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Calls to the `im.a.teapot` host should return `418 I'm a teapot`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Calls to all other hostnames should return `501 Not Implemented`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'To implement these routing rules in Spring Cloud Gateway, we can use the `Host` route predicate
    to select requests with specific hostnames, and the `SetPath` filter to set the
    desired HTTP code in the request path. This can be done as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: 'To make calls to `http://i.feel.lucky:8080/headerrouting` return 200 OK, we
    can set up the following route:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'To make calls to `http://im.a.teapot:8080/headerrouting` return `418 I''m a
    teapot`, we can set up the following route:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, to make calls to all other hostnames return `501 Not Implemented`,
    we can set up the following route:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: Okay, that was quite a bit of configuration, so now let's try it out!
  prefs: []
  type: TYPE_NORMAL
- en: Trying out the edge server
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To try out the edge server, we perform the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'First, build the Docker images with the following commands:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, start the system landscape in Docker and run the usual tests with the
    following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'Expect output similar to what we have seen in previous chapters:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/fa1b108b-8607-4ced-a8b6-b24fc43ce34d.png)'
  prefs: []
  type: TYPE_IMG
- en: 'With the system landscape including the edge server, let''s explore the following
    topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Examine what is exposed by the edge server outside of the system landscape running
    in the Docker engine.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Try out some of the most frequently used routing rules as follows:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Use URL-based routing to call our APIs through the edge server.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Use URL-based routing to call Netflix Eureka through the edge server, both using
    its API and web-based UI.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Use header-based routing to see how we can route requests based on the hostname
    in the request.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Examining what is exposed outside the Docker engine
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To understand what the edge server exposes to the outside of the system landscape,
    perform the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Use the `docker-compose ps` command to see that what ports are exposed by our
    services:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'As we can see in the following output, only the edge server (named `gateway`) exposes
    its port (`8080`) outside the Docker engine:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/635db56b-5896-497a-a15d-2ca63833a1e8.png)'
  prefs: []
  type: TYPE_IMG
- en: 'If we want to see what routes the edge server has set up, we can use the `/actuator/gateway/routes` API.
    The response from this API is rather verbose. To limit the response to information
    we are interested in, we can apply a `jq` filter. In the following example, I
    have selected the `id` of the route and the first predicate in the route:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'This command will respond with the following:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/7e1c7cfb-3eb6-4299-9199-b4415b1b20b3.png)'
  prefs: []
  type: TYPE_IMG
- en: This gives us a good overview of the actual routes configured in the edge server.
    Now, let's try out the routes!
  prefs: []
  type: TYPE_NORMAL
- en: Trying out the routing rules
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section, we will try out the edge server and the routes it exposes to
    the outside of the system landscape. Let's start with calling the product composite
    API, then call the Eureka API and visit its web page, and conclude with testing
    the routes that are based on hostnames.
  prefs: []
  type: TYPE_NORMAL
- en: Calling the product composite API through the edge server
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s perform the following steps to call the product composite API through
    the edge server as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: 'To be able to see what is going on in the edge server, we can follow its log
    output:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, make the call to the product composite API through the edge server:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'Expect the normal type of response from the composite product API:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/20e4c6a4-4714-4990-b85f-964445d04b6a.png)'
  prefs: []
  type: TYPE_IMG
- en: 'We should be able to find the following interesting information in the log
    output:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: From the log output, we can see the pattern matching based on the predicate
    we specified in the configuration, and we can see what microservice instance the
    edge server selected from the available instances in the discovery server—in this
    case, `http://b8013440aea0:8080/product-composite/2`.
  prefs: []
  type: TYPE_NORMAL
- en: Calling Eureka through the edge server
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To call Eureka through an edge server, perform the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'First, call the Eureka API through the edge server to see what instances are
    currently registered in the discovery server:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'Expect a response along the lines of the following:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/d8b40a4a-a897-408e-9131-8dd8b7f52041.png)'
  prefs: []
  type: TYPE_IMG
- en: Note that the edge server (named `gateway`) is also present in the response.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, open the Eureka web page in a web browser using the URL, `http://localhost:8080/eureka/web`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/c1f75e90-3c3a-42c1-aac1-432c7428230e.png)'
  prefs: []
  type: TYPE_IMG
- en: From the preceding screenshot, we can see the Eureka web page reporting the
    same available instances as the API response in the previous step.
  prefs: []
  type: TYPE_NORMAL
- en: Routing based on the host header
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Let's wrap up by testing the route setup based on the hostname used in the requests!
  prefs: []
  type: TYPE_NORMAL
- en: 'Normally, the hostname in the request is set automatically in the `Host` header by
    the HTTP client. When testing the edge server locally, the hostname will be `localhost`—that
    is not so useful when testing hostname-based routing. But we can cheat by specifying
    another hostname in the `Host` header in the call to the API. Let''s see how this
    can be done:'
  prefs: []
  type: TYPE_NORMAL
- en: 'To call for the `i.feel.lucky` hostname, use this code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'Expect the response 200 OK. For the hostname `im.a.teapot`, use the following
    command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: Expect the response `418 I'm a teapot`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, if not specifying any `Host` header, use `localhost` as the `Host`
    header:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: Expect the response `501 Not Implemented`.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can also use `i.feel.lucky` and `im.a.teapot` as real hostnames in the requests
    if we add them to the local `/etc/hosts` file and specify that they should be
    translated into the same IP address as `localhost`, that is `127.0.0.1`. Run the
    following command to add a row to the `/etc/hosts` file with the required information:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'We can now perform the same routing based on the hostname, but without specifying
    the `Host` header. Try it out by running the following commands:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: Expect the same response as previously, that is, 200 OK and `418 I'm a teapot`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Wrap up the tests by shutting down the system landscape with the following
    command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: Also, clean up the `/etc/hosts` file from the DNS name translation we added
    for the hostnames, `i.feel.lucky` and `im.a.teapot`. Edit the `/etc/hosts` file and
    remove the line we added: `127.0.0.1 i.feel.lucky im.a.teapot`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: These tests of the routing capabilities in the system landscape's edge server
    end the chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we have seen how Spring Cloud Gateway can be used as an edge
    server to control what services are allowed to be called from the outside of the
    system landscape. Based on predicates, filters, and destination URIs, we can define
    routing rules in a very flexible way. If we want to, we can configure Spring Cloud
    Gateway to use a discovery service such as Netflix Eureka to look up the target
    microservice instances.
  prefs: []
  type: TYPE_NORMAL
- en: One important question still unanswered is how we prevent unauthorized access
    to the APIs exposed by the edge server and how we can prevent third parties from
    intercepting the traffic.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will see how we can secure access to the edge server
    using standard security mechanisms such as HTTPS, OAuth, and OpenID Connect.
  prefs: []
  type: TYPE_NORMAL
- en: Questions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: What are the elements used to build a routing rule in Spring Cloud Gateway called?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What are they used for?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How can we instruct Spring Cloud Gateway to locate microservice instances through
    a discovery service such as Netflix Eureka?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In a Docker environment, how can we ensure that external HTTP requests to the
    Docker engine can only reach the edge server?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How do we change the routing rules so that the edge server accepts calls to
    the `product-composite` service on the `http://$HOST:$PORT/api/product` URL instead
    of the currently used `http://$HOST:$PORT/product-composite`?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
