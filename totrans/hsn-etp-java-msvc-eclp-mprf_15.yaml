- en: Using MicroProfile in Multi-Cloud Environments
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Microservices and microservices architectures are ideal development approaches
    for cloud and multi-cloud environments, including hybrid cloud deployments, where
    your application comprises on-premise logic as well as logic that runs in the
    cloud. Eclipse MicroProfile is a specification that optimizes Java for microservices
    architecture and thus provides constructs so that you can implement microservices
    in Java and the cloud. These topics will help you to understand why Eclipse MicroProfile
    is ideal for developing applications in hybrid and multi-cloud environments, and
    what you must take into consideration when using it in these types of deployments.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we will discuss the following ...
  prefs: []
  type: TYPE_NORMAL
- en: Using Eclipse MicroProfile for cloud-native application development
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'What is a cloud-native application? Typically, a definition for **cloud-native**
    entails the following characteristics:'
  prefs: []
  type: TYPE_NORMAL
- en: Designed as loosely coupled services, such as microservices
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Loosely coupled services that interact via language-independent communication
    protocols, which allow microservices to be implemented in different programming
    languages and frameworks
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Lightweight containers that can scale up and down on-demand or via resource
    utilization metrics
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Managed through Agile DevOps processes, with each microservice of a cloud-native
    application going through an independent life cycle that's managed through an
    Agile process using **continuous integration/continuous delivery** (**CI/CD**)
    pipelines
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: However, Eclipse MicroProfile's goal is to optimize Java for microservice architectures,
    so does it make it suitable for cloud-native application development? What about
    container-native development? What is the relationship between microservices,
    cloud-native development, and container-native development? How do these differ
    or compare? Let's find out!
  prefs: []
  type: TYPE_NORMAL
- en: Microservices versus cloud native versus container native
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'First, let''s draw the differences between these three terms with respect to
    how an application is developed. As we discussed in [Chapter 1](96308ec7-7393-41b7-a17c-43c15d409f40.xhtml),
    *Introduction to Eclipse MicroProfile*, an Enterprise Java microservice has the
    following features:'
  prefs: []
  type: TYPE_NORMAL
- en: It is a microservice written using the Java language.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It can use any Java framework.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It can use any Java API.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It must be enterprise grade, which means it must have high reliability, availability,
    scalability, security, robustness, and performance.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It must fulfill the characteristics of a microservice, all of which are listed
    at [https://martinfowler.com/microservices/](https://martinfowler.com/microservices/).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: By its definition, a microservice does not prescribe specific details of the
    underlying ...
  prefs: []
  type: TYPE_NORMAL
- en: What about 12-factor applications?
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Just like the microservices and microservices architecture definitions, a 12-factor
    app does not prescribe the underlying technologies, for example, the programming
    language, database, caches, and so on, or frameworks that should be used to implement
    them. The 12-factor app is a methodology that''s used for implementing applications.
    These twelve factors are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: One codebase tracked in revision control, many deploys
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Explicitly declare and isolate dependencies
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Store config in the environment
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Treat backing services as attached resources
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Strictly separate build and run stages
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Execute the app as one or more stateless processes
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Export services via port binding
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Scale out via the process model
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Maximize robustness with fast startup and graceful shutdown
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Keep development, staging, and production as similar as possible
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Treat logs as event streams
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Run admin/management tasks as one-off processes
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Implementing an application using this methodology helps us do the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Minimize time and cost for new developers joining the project
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Offer portability between execution environments
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Easily deploy the application to cloud platforms
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Minimize the differences between development and production
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Scale it up without changes
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You can read all about the 12 factors at [https://12factor.net](https://12factor.net).
  prefs: []
  type: TYPE_NORMAL
- en: The 12-factor app is a methodology that a developer can follow while designing
    and implementing microservices and applications, independent of the programming
    language or framework that's being used to implement them. The framework that
    a developer can use to implement microservices using the 12-factor app is Eclipse
    MicroProfile. The 12-factor app and Eclipse MicroProfile are not mutually exclusive
    but really complement each other.
  prefs: []
  type: TYPE_NORMAL
- en: But what about a methodology for designing and implementing applications that's
    not the 12-factor app? What about serverless and **Function-as-a-Service** (**FaaS**)
    technologies? How does Eclipse MicroProfile fit into these newer cloud-native
    technologies?
  prefs: []
  type: TYPE_NORMAL
- en: What about serverless and FaaS?
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Serverless and FaaS cloud-native technologies have been experiencing steady
    interest and growth in the market, as evidenced by offerings from all the major
    cloud providers, that is, AWS Lambda, Azure Functions, Oracle Functions, and Google
    Cloud Functions. In an era where organizations are increasingly using the cloud
    for development and production workloads, and compute and memory costs are operational
    expenses that need to be tracked and monitored, FaaS is attractive because it
    abstracts compute and memory management away from the user, who is then able to
    focus on developing business logic, thereby becoming a lot more productive than
    ever before.
  prefs: []
  type: TYPE_NORMAL
- en: With FaaS, developers don't need to set up VMs and memory, ...
  prefs: []
  type: TYPE_NORMAL
- en: Cloud-native application development
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'There are two complementary aspects or components to cloud-native application
    development: application services and infrastructure services. Application services
    speed up the development of the business logic of a cloud-native application,
    and infrastructure services speed up its delivery and deployment. These two aspects
    are complementary and integral to cloud-native application development. You cannot
    have one without the other. They are essentially the yin and the yang of cloud-native application
    development, as depicted by the following diagram:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/5396deb8-7e59-4be5-9b20-a31287abeed3.png)'
  prefs: []
  type: TYPE_IMG
- en: 'As we mentioned earlier in this chapter, cloud-native application development
    is an approach to building and running applications that takes full advantage
    of the cloud computing model, which is based on four key tenets:'
  prefs: []
  type: TYPE_NORMAL
- en: A service-based architecture (miniservices, microservices, SOA services, and
    so on)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: An API-driven approach for inter-service communication
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: An underlying infrastructure that's based on containers
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: DevOps processes
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The following diagram depicts the four key tenets of cloud-native application
    development:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/5994cf8f-77e2-4906-b576-0a8742fe81b5.png)'
  prefs: []
  type: TYPE_IMG
- en: As shown in the previous diagram, the architecture and communication aspects
    are related to the development concerns of cloud-native applications, and the
    infrastructure and the process aspects are related to their delivery/deployment.
  prefs: []
  type: TYPE_NORMAL
- en: Organizations who are on their journey to adopting cloud-native application
    development can benefit from eight steps, as described by the e-Book titled *The
    path to cloud-native applications: **8 steps to guide your journey*.
  prefs: []
  type: TYPE_NORMAL
- en: To obtain the e-Book *The path to cloud-native applications: **8 steps to guide
    your journey*, please refer to [https://www.redhat.com/en/resources/path-to-cloud-native-applications-ebook](https://www.redhat.com/en/resources/path-to-cloud-native-applications-ebook).
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s discuss how Eclipse MicroProfile can play a role in these eight steps:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Evolve the DevOps culture and practices**: "*Take advantage of new technology,
    faster approaches, **and tighter collaboration by embracing the principles and
    cultural values of DevOps and organizing your organization around those values.*"
    Although this is an organizational and process-related step, Eclipse MicroProfile,
    as a specification for microservices, can be a good fit for this adaptation of
    culture and process because microservices, due to their characteristics, closely
    support DevOps processes.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Speed up existing applications using fast monoliths**: "*Accelerate existing
    applications by migrating to a modern, container-based platform – and break up
    monolithic applications into microservices or miniservices for additional efficiency
    gains.*" Eclipse MicroProfile can be of great help when breaking up your monolith
    into microservices. As you identify bounded contexts in your monolith, consider
    using Eclipse MicroProfile to implement each of the microservices that implement
    the logic of each bounded context.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Use application services to speed up development**: "*Speed up software development
    with reusability. Cloud-native application services are ready-to-use developer
    tools. However, these reusable components must be optimized and integrated into
    the underlying cloud-native infrastructure to maximize their benefits.*" An **In-Memory
    Data Grid** (**IMDG**) and Messaging Brokers are application services that help
    speed up the development of business logic. A microservice, developed using Eclipse
    MicroProfile, can leverage these application services by invoking them from within
    its method bodies. Eclipse MicroProfile does not impose any kind of restriction
    when integrating to application services, such as an IMDG or a Messaging Broker.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Choose the right tool for the right task**: "*Use a container-based application
    platform that supports the right mix of frameworks, languages, and architectures
    – and can be tailored to your specific business application need.*" Eclipse MicroProfile
    is one of the tools that a developer can use when choosing the right tool for
    the right task. For example, Red Hat Application Runtimes is a collection of runtimes
    and tools, which includes Eclipse MicroProfile, Node.js, Spring Boot, and Vertex.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Provide developers with a self-service, on-demand infrastructure**: "*Use
    containers and container orchestration technologies to simplify access to the
    underlying infrastructure, give control and visibility to IT operations teams,
    and provide robust application life cycle management across various infrastructure
    environments, such as data centers, private clouds, and public clouds.*" The microservices
    you develop with Eclipse MicroProfile can be deployed to one or more containers.
    By easily managing these containers and your microservices architecture, which
    is running on them, you can accelerate your development cycles to deliver value
    to the business faster.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Automate IT to accelerate application delivery**: "*Create a**utomation sandboxes
    in order to lea**rn about the automation language and process, establish collaborative
    dialog across organizations for defining service requirements, create self-service
    catalogs that empower users and speed delivery, and use metering, monitoring,
    and chargeback policies and processes.*" Eclipse MicroProfile provides capabilities
    for metrics, fault tolerance, and health checks, all of which can be used as input
    to the IT automation processes.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Implement continuous delivery and advanced deployment techniques**: "*Accelerate
    the delivery of your cloud-native applications with automated delivery, CI/CD
    pipelines, rolling blue/green and canary deployments, and A/B testing.*" The use
    of microservices in combination with CI/CD can facilitate advanced deployment
    techniques. For example, you can introduce a MicroProfile-based microservice with
    new functionality as part of a blue/green or canary deployment into production
    and switch all of the traffic to it once you have proven that the new functionality
    works as expected.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Evolve a more modular architecture**: "*Choose a modular design that makes
    sense for your specific needs, using microservices, a monolith-first approach,
    or miniservices – or a combination.*" For this step, you can use Eclipse MicroProfile
    to develop microservices for new applications or as you break specific bounded
    contexts of your monolith into microservices.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Now that we have discussed how Eclipse MicroProfile facilitates cloud-native
    application development and how it can help in each of the eight steps to guide
    you in your journey to cloud-native applications, let's turn to the topic of running
    MicroProfile-based applications across clouds.
  prefs: []
  type: TYPE_NORMAL
- en: Developing and running MicroProfile applications across clouds
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: What features does MicroProfile provide to support development across clouds?
    Microservices and support for language-agnostic communication based on HTTP REST
    API are two of the main features that are supported. In addition, MicroProfile
    Config supports the integration of cloud environment variables that define integration
    with the cloud environment. MicroProfile Health Check supports integration with
    the cloud environment health checks. MicroProfile Metrics and MicroProfile OpenTracing support
    integration with the DevOps monitoring tasks. Finally, MicroProfile fault tolerance
    supports fallback and recovery behaviors between the independent microservices.
  prefs: []
  type: TYPE_NORMAL
- en: Eclipse MicroProfile ...
  prefs: []
  type: TYPE_NORMAL
- en: Bare-metal machines versus VMs versus containers
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The decision of whether to run a MicroProfile-based microservice or application
    on bare-metal machines, VMs, or containers depends on the specific requirements
    of your application. In fact, the determination of what type of underlying cloud
    compute resource rests squarely on your application needs and not the framework
    being used for its development, that is, Eclipse MicroProfile. For example, if
    your application or microservice requires real or near-real-time response times,
    then you'd most likely favor a bare-metal or container (running on bare-metal)
    deployment. This decision would be made independent of the framework you are using
    to write your business logic, whether that be Eclipse MicroProfile or another
    one.
  prefs: []
  type: TYPE_NORMAL
- en: Since Eclipse MicroProfile supports microservices and language-agnostic communication
    based on HTTP REST, your inter-microservice communication is unaffected by the
    type of underlying compute on which your microservices are running; for example,
    you could have a microservice running on a VM communicating via REST with another
    microservice running on a bare-metal machine. But what if your application consists
    of microservices running on-premises and another running on the cloud, also known
    as a hybrid cloud application? What considerations do you need to have in mind?
  prefs: []
  type: TYPE_NORMAL
- en: Considerations when using MicroProfile in a hybrid cloud deployment
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'A hybrid cloud application comprises on-premises logic as well as on-cloud
    logic. In other words, if part of your application logic runs on-premises and
    part of it runs in the cloud, you effectively have a hybrid cloud application.
    When using Eclipse MicroProfile in this type of deployment, here are the things
    you need to consider:'
  prefs: []
  type: TYPE_NORMAL
- en: Configuration of communication routes between the cloud environment and the
    on-premises environment needs to be done using whatever DNS support the cloud
    environment supports
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Configuration of MicroProfile OpenTracing to enable the capture of tracing across
    cloud environments
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Monitoring of the split MicroProfile Metrics information across cloud ...
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Challenges when using MicroProfile OpenTracing in a multi-cloud deployment
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Distributed tracing in a multi-cloud environment can be challenging. We want
    to fulfill the same objective that we would with a single cloud environment, that
    is, to visualize the single end-to-end trace associated with a request as it passes
    through services within and across each cloud, but may face complications when
    dealing with different context propagation formats and storage of the tracing
    data in different formats per cloud.
  prefs: []
  type: TYPE_NORMAL
- en: The first challenge is to ensure that a trace continues across different cloud
    environments. This is a problem because, at the time of writing this book, there
    is not a widely adopted or standardized trace context format. Usually, each tracing
    system uses different headers and formats to propagate the tracing context. For
    instance, Zipkin uses B3 propagation, Jaeger uses a `ber-trace-id` header, Amazon
    X-Ray uses `X-Amzn-Trace-Id`, and Google uses `X-Cloud-Trace-Context`. Therefore,
    if a request has to be traced across heterogenous tracing systems, each time it
    leaves or enters a different environment, the trace context has to be converted.
    This can usually be done by configuring a tracer with a custom injector or extractor
    implementation. However, this is currently beyond the scope of the MicroProfile
    OpenTracing project. In the future, the trace context format might be standardized
    under the W3C Trace Context project ([https://www.w3.org/TR/trace-context/](https://www.w3.org/TR/trace-context/)).
  prefs: []
  type: TYPE_NORMAL
- en: The second challenge, even in a homogenous tracing environment, is to visualize
    tracing data from multi-cloud environments. This can be problematic because tracing
    data in each cloud might be stored in different databases or in different formats.
    This can be overcome by replicating the data to a single unified storage or sending
    missing tracing data between systems on-demand with the appropriate data format
    adjustments.
  prefs: []
  type: TYPE_NORMAL
- en: Next, we will discuss the challenges of using Eclipse MicroProfile in a service
    mesh, such as Istio.
  prefs: []
  type: TYPE_NORMAL
- en: Considerations when using Eclipse MicroProfile in a service mesh
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Service meshes such as Istio or LinkerD offer services at the platform level
    on top of Kubernetes in the areas of discovery, routing, and fault tolerance. Some
    of those services can also be found in MicroProfile. When you deploy a MicroProfile
    application into such a service mesh, you need to consider whether you want to
    use the version from MicroProfile or the one from the mesh.
  prefs: []
  type: TYPE_NORMAL
- en: The MicroProfile feature that is most likely affected here is fault tolerance,
    especially the retry logic.
  prefs: []
  type: TYPE_NORMAL
- en: Retry
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Retry in fault tolerance lets you retry a request to another service in case
    the first request fails (see [Chapter 3](73f2287d-1676-47c9-9887-cf74aa0aa6f0.xhtml), *MicroProfile
    Config and Fault Tolerance*, for more information). Now, consider that you have
    the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: Although this tells Istio to retry 5 times, you may end up with 15 retries (Istio
    will retry 5 times for each of the 3 retries in your code before it returns an
    error) before `aMethod` finally ends with an error. You may consider turning off
    the retries in code, as changes to the number of retries in Istio can be made
    on the fly without the need to restart a pod.
  prefs: []
  type: TYPE_NORMAL
- en: Fallback
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'On the other hand, Istio does not have a fallback policy for when all the retries
    fail – it is not possible to have Istio call another version of your workload. When
    you annotate the preceding code with the `@Fallback` annotation, it is possible
    to execute another action in case the original call fails:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: In this case, the `fallbackForA` fallback method will be called once all the
    retries from Istio, times those from MicroProfile, have been exhausted. If you
    remove the `@Retry` annotation from the preceding example, the fallback method
    is called when the Istio retries have been exhausted. ...
  prefs: []
  type: TYPE_NORMAL
- en: Fault injection in the service mesh
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Istio lets you inject faults into the results pretty easily. This sounds counterproductive
    at the start, but can be a very nice way of testing that you get the fault tolerance
    handling right. The following `VirtualService` for Istio defines such fault injection:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: Istio will hear for calls to the destination host, `myTarget`, and send a 404
    response for 20% of the calls instead of the real response code. On top of this,
    it will delay every other response by 200 milliseconds.
  prefs: []
  type: TYPE_NORMAL
- en: Conclusion
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: MicroProfile defines primitives in the area of fault tolerance that can also
    be provided by other means, such as in a service mesh. If this is the case for
    you, you have to consider which one to activate. Activating both may result in
    unexpected behavior.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, you have learned how Eclipse MicroProfile facilitates cloud-native
    application development, regardless of whether it is a hybrid cloud or multi-cloud
    application. We also discussed the relationship between microservices, cloud-native
    development, and container-native development, and how microservices running on
    containers are an ideal option for cloud-native development. You also learned
    how Eclipse MicroProfile relates to the 12-factor app, as well as serverless and
    FaaS environments.
  prefs: []
  type: TYPE_NORMAL
- en: We covered the eight steps to guide your journey into cloud-native applications
    and how Eclipse MicroProfile can help at each step. In addition, we discussed
    what you need to consider when using Eclipse MicroProfile for applications that
    span across clouds, when to run Eclipse MicroProfile on bare-metal machines versus
    VMs versus containers, what to consider when running Eclipse MicroProfile microservices
    in hybrid cloud applications, the challenges to be aware of when running Eclipse
    MicroProfile OpenTracing in a multi-cloud deployment, and finally what to consider
    when using Eclipse MicroProfile in a service mesh.
  prefs: []
  type: TYPE_NORMAL
- en: Throughout this book, we've covered the origins of MicroProfile, a specification
    for Java microservices, and the history behind how it came into being. We introduced
    the open source project, its mission, governance, benefits, how to contribute
    to it, and the life cycle of its sub-projects. We then delved into each of the
    MicroProfile APIs/sub-projects that make up the umbrella/platform release, as
    well as the sub-projects outside the umbrella release.
  prefs: []
  type: TYPE_NORMAL
- en: We also covered the current implementations of MicroProfile in the market, including
    Quarkus, and showed you how to "quark" a generated MicroProfile project by the
    MicroProfile Starter. We discussed the Conference Application, a community sample
    project that demonstrates the interoperability of MicroProfile across different
    vendor implementations. We also provided code examples throughout for reference
    and discussion purposes, and also provided a fully working project with source
    code that implemented all the MicroProfile APIs that you can freely access, download,
    compile, and reuse in your development efforts and to get jump-started with MicroProfile.
    Later, we discussed the reactive functionality offered by MicroProfile and its
    future developments, such as sub-projects in the pipeline and in the MicroProfile
    sandbox, as well as its likely future relationship with Jakarta EE.
  prefs: []
  type: TYPE_NORMAL
- en: Lastly, we went over how MicroProfile-based applications and microservices are
    a good fit for implementing solutions in containers, the cloud, and serverless/FaaS
    deployments. Whether you are new to Java microservices or an experienced Java
    developer, you can use all the knowledge you have gained from this book to start
    developing microservices that are based on this new and innovative community-driven
    specification for the creation of observable, scalable, secure, and highly available
    hybrid and multi-cloud applications so that you can deliver value to your business
    faster.
  prefs: []
  type: TYPE_NORMAL
- en: Questions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: How does Eclipse MicroProfile facilitate cloud-native application development?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What are the two complementary concerns of cloud-native application development?
    How does Eclipse MicroProfile fit into these concerns?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What are the four key tenets of cloud-native application development? How does
    Eclipse MicroProfile relate to these?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How does Eclipse MicroProfile contribute to each of the eight steps to guide
    your journey through cloud-native applications?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How does Eclipse MicroProfile relate to the 12-factor app?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How can Eclipse MicroProfile facilitate serverless and FaaS environments?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What should you consider when implementing and running Eclipse MicroProfile
    across clouds?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What are the challenges when using Eclipse MicroProfile ...
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
