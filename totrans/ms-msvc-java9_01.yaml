- en: A Solution Approach
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 解决方案方法
- en: As a prerequisite, you should have a basic understanding of microservices and
    software architecture style. Having a basic understanding could help you to understand
    the concepts and this book thoroughly.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 作为先决条件，你应该对微服务和软件架构风格有一个基本的理解。具备基本理解可以帮助你彻底理解概念和本书。
- en: After reading this book, you could implement microservices for on-premise or
    cloud production deployment and learn the complete life-cycle from design, development,
    testing, and deployment with continuous integration and deployment. This book
    is specifically written for practical use and to ignite your mind as a solution
    architect. Your learning will help you to develop and ship products for any type
    of premise, including SaaS, PaaS, and so on. We'll primarily use the Java and
    Java-based framework tools such as Spring Boot and Jetty, and we will use Docker
    as a container.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 阅读本书后，你可以实现用于本地或云生产部署的微服务，并学习从设计、开发、测试到部署的完整生命周期，以及持续集成和部署。本书专为实际应用和激发您作为解决方案架构师的思维而编写。你的学习将帮助你开发和交付任何类型的场所的产品，包括SaaS、PaaS等。我们将主要使用Java和基于Java的框架工具，如Spring
    Boot和Jetty，并且我们将使用Docker作为容器。
- en: In this chapter, you will learn the eternal existence of microservices, and
    how it has evolved. It highlights the large problems that on-premise and cloud-based
    products face and how microservices deals with it. It also explains the common
    problems encountered during the development of SaaS, enterprise, or large applications
    and their solutions.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你将学习微服务的永恒存在及其演变。它突出了本地和基于云的产品面临的重大问题以及微服务如何解决这些问题。它还解释了在开发SaaS、企业或大型应用程序过程中遇到的常见问题及其解决方案。
- en: 'In this chapter, we will learn the following topics:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 本章我们将学习以下主题：
- en: Microservices and a brief background
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 微服务及其简要背景
- en: Monolithic architecture
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 单体架构
- en: Limitation of monolithic architecture
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 单体架构的限制
- en: The benefits and flexibility that microservices offer
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 微服务提供的优势和灵活性
- en: Microservices deployment on containers such as Docker
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在Docker等容器上部署微服务
- en: Evolution of microservices
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 微服务的演变
- en: 'Martin Fowler explains:'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 马丁·福勒解释道：
- en: The term microservice was discussed at a workshop of software architects near
    Venice in May 2011 to describe what the participants saw as a common architectural
    style that many of them had been recently exploring. In May 2012, the same group
    decided on µServices as the most appropriate name.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 微服务的术语是在2011年5月靠近威尼斯的一次软件架构师研讨会上讨论的，以描述与会者认为的一种共同的架构风格，他们中很多人最近都在探索这种风格。2012年5月，同一群人决定将“微服务”（µServices）作为最合适的名称。
- en: Let's get some background on the way it has evolved over the years. Enterprise
    architecture evolved more from historic mainframe computing, through client-server
    architecture (two-tier to n-tier) to **Service-Oriented Architecture** (**SOA**).
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们回顾一下它是如何在过去几年中发展的。企业架构更多地是从历史的大型机计算，通过客户机-服务器架构（两层到多层）发展到**服务导向架构**（**SOA**）。
- en: The transformation from SOA to microservices is not a standard defined by an
    industry organization, but a practical approach practiced by many organizations.
    SOA eventually evolved to become microservices.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 从服务导向架构（SOA）到微服务的转变并非由某个行业协会定义的标准，而是许多组织实践的实用方法。SOA最终演变为微服务。
- en: 'Adrian Cockcroft, a former Netflix Architect, describes it as:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 前Netflix架构师阿德里安·科克洛夫特（Adrian Cockcroft）将其描述为：
- en: Fine grain SOA. So microservice is SOA with emphasis on small ephemeral components.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 细粒度SOA。因此，微服务是强调小型短暂组件的SOA。
- en: 'Similarly, the following quote from Mike Gancarz, a member that designed the
    X Windows system, which defines one of the paramount precepts of Unix philosophy,
    suits the microservice paradigm as well:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，来自设计X窗口系统的成员迈克·甘卡兹（Mike Gancarz）的以下引言，定义了Unix哲学的一个基本原则，同样适用于微服务范式：
- en: Small is beautiful.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 小即是美。
- en: Microservices shares many common characteristics with SOA, such as the focus
    on services and how one service decouples from another. SOA evolved around monolithic
    application integration by exposing API that was mostly **Simple Object Access
    Protocol** (**SOAP**) based. Therefore, middleware such as **Enterprise Service
    Bus** (**ESB**) is very important for SOA. Microservices are less complex, and
    even though they may use the message bus it is only used for message transport
    and it does not contain any logic. It is simply based on smart endpoints.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
- en: 'Tony Pujals defined microservices beautifully:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
- en: In my mental model, I think of self-contained (as in containers) lightweight
    processes communicating over HTTP, created and deployed with relatively small
    effort and ceremony, providing narrowly-focused APIs to their consumers.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
- en: Though Tony only talks about the HTTP, event-driven microservices may use the
    different protocol for communication. You can make use of Kafka for implementing
    the event-driven microservices. Kafka uses the wire protocol, a binary protocol
    over TCP.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
- en: Monolithic architecture overview
  id: totrans-23
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Microservices is not something new, it has been around for many years. For example,
    Stubby, a general purpose infrastructure based on **Remote** **Procedure** **Call**
    (**RPC**) was used in Google data centers in the early 2000s to connect a number
    of service with and across data centers. Its recent rise is owing to its popularity
    and visibility. Before microservices became popular, there was primarily monolithic
    architecture that was being used for developing on-premise and cloud applications.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
- en: Monolithic architecture allows the development of different components such
    as presentation, application logic, business logic, and **Data Access Objects**
    (**DAO**), and then you either bundle them together in **Enterprise Archive**
    (**EAR**) or **Web Archive** (**WAR**), or store them in a single directory hierarchy
    (for example, Rails, NodeJS, and so on).
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
- en: Many famous applications such as Netflix have been developed using microservices
    architecture. Moreover, eBay, Amazon, and Groupon have evolved from monolithic
    architecture to a microservices architecture.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
- en: Now that you have had an insight into the background and history of microservices,
    let's discuss the limitations of a traditional approach, namely monolithic application
    development, and compare how microservices would address them.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
- en: Limitation of monolithic architecture versus its solution with microservices
  id: totrans-28
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As we know, change is eternal. Humans always look for better solutions. This
    is how microservices became what it is today and it may evolve further in the
    future. Today, organizations are using Agile methodologies to develop applications--it
    is a fast-paced development environment and it is also on a much larger scale
    after the invention of cloud and distributed technologies. Many argue that monolithic
    architecture could also serve a similar purpose and be aligned with Agile methodologies,
    but microservices still provides a better solution to many aspects of production-ready
    applications.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
- en: To understand the design differences between monolithic and microservices, let's
    take an example of a restaurant table-booking application. This application may
    have many services such as customers, bookings, analytics and so on, as well as
    regular components such as presentation and database.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
- en: We'll explore three different designs here; traditional monolithic design, monolithic
    design with services, and microservices design.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
- en: Traditional monolithic design
  id: totrans-32
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The following diagram explains the traditional monolithic application design.
    This design was widely used before SOA became popular:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/8fb71694-894b-43f1-babd-d1bebad0c078.png)'
  id: totrans-34
  prefs: []
  type: TYPE_IMG
- en: Traditional monolithic application design
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
- en: In traditional monolithic design, everything is bundled in the same archive
    such as **Presentation** code, **Application Logic** and **Business Logic** code,
    and **DAO** and related code that interacts with the database files or another
    source.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
- en: Monolithic design with services
  id: totrans-37
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'After SOA, applications started being developed based on services, where each
    component provides the services to other components or external entities. The
    following diagram depicts the monolithic application with different services;
    here services are being used with a **Presentation** component. All services,
    the **Presentation** component, or any other components are bundled together:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/56e1f42d-382d-47e8-82da-b8014ad4e11a.png)'
  id: totrans-39
  prefs: []
  type: TYPE_IMG
- en: Services design
  id: totrans-40
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The following third design depicts the microservices. Here, each component represents
    autonomy. Each component could be developed, built, tested, and deployed independently.
    Here, even the application **User Interface** (**UI**) component could also be
    a client and consume the microservices. For the purpose of our example, the layer
    designed is used within µService.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
- en: 'The **API Gateway** provides the interface where different clients can access
    the individual services and solve the following problems:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
- en: What do you do when you want to send different responses to different clients
    for the same service? For example, a booking service could send different responses
    to a mobile client (minimal information) and a desktop client (detailed information)
    providing different details, and something different again to a third-party client.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
- en: 'A response may require fetching information from two or more services:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/2111f31f-e230-4141-bd2d-f52e304ca197.png)'
  id: totrans-45
  prefs: []
  type: TYPE_IMG
- en: After observing all the sample design diagrams, which are very high-level designs,
    you might find out that in monolithic design, the components are bundled together
    and tightly coupled.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 在观察了所有的高级设计样本图后，你可能会发现，在单体设计中，组件是捆绑在一起的，并且耦合度很高。
- en: All the services are part of the same bundle. Similarly, in the second design
    figure, you can see a variant of the first figure where all services could have
    their own layers and form different APIs, but, as shown in the figure, these are
    also all bundled together.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 所有服务都是同一个捆绑包的一部分。同样，在第二个设计图中，你可以看到第一个图的一个变体，其中所有服务可能都有自己的层并形成不同的API，但是，如图所示，这些也都是捆绑在一起的。
- en: Conversely, in microservices, design components are not bundled together and
    have loose coupling. Each service has its own layers and **DB**, and is bundled
    in a separate archive. All these deployed services provide their specific APIs
    such as Customers, Bookings, or Customer. These APIs are ready to consume. Even
    the UI is also deployed separately and designed using µService. For this reason,
    it provides various advantages over its monolithic counterpart. I would still
    remind you that there are some exceptional cases where monolithic application
    development is highly successful, such as Etsy, and peer-to-peer e-commerce web
    applications.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 相反，在微服务中，设计组件是不捆绑在一起的，并且耦合度很低。每个服务都有自己的层和**DB**，并且打包在单独的归档文件中。所有这些部署的服务提供它们特定的API，如客户（Customers）、预订（Bookings）或客户（Customer）。这些API是即取即用的。即便是UI也是单独部署的，并且使用微服务进行设计。因此，它比单体应用有众多优势。我还是要提醒你，在某些特殊情况下，单体应用开发是非常成功的，如Etsy和点对点电子商务网站。
- en: Now let us discuss the limitations you'd face while working with Monolithic
    applications.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们讨论在使用单体应用时您可能会遇到的限制。
- en: One dimension scalability
  id: totrans-50
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 单一维度的可扩展性
- en: Monolithic applications that are large when scaled, scale everything as all
    the components are bundled together. For example, in the case of a restaurant
    table reservation application, even if you would like to scale the table-booking
    service, it would scale the whole application; it cannot scale the table-booking
    service separately. It does not utilize the resources optimally.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 当单体应用规模变大时，它会捆绑在一起扩展所有组件。例如，在餐厅预订桌位的应用中，即使你想要扩展桌位预订服务，它也会扩展整个应用；它不能单独扩展桌位预订服务。它没有充分利用资源。
- en: In addition, this scaling is one-dimensional. Running more copies of the application
    provides the scale with increasing transaction volume. An operation team could
    adjust the number of application copies that were using a load-balancer based
    on the load in a server farm or a cloud. Each of these copies would access the
    same data source, therefore increasing the memory consumption, and the resulting
    I/O operations make caching less effective.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，这种扩展是单一维度的。随着交易量的增加，运行更多应用副本提供了扩展。运维团队可以根据服务器农场或云中的负载，通过负载均衡器调整应用副本的数量。这些副本都会访问相同的数据源，因此增加了内存消耗，而产生的I/O操作使缓存效果大打折扣。
- en: Microservices gives the flexibility to scale only those services where scale
    is required and it allows optimal utilization of the resources. As we mentioned
    previously, when it is needed, you can scale just the table-booking service without
    affecting any of the other components. It also allows two-dimensional scaling;
    here we can not only increase the transaction volume, but also the data volume
    using caching (Platform scale).
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 微服务赋予了灵活性，只扩展那些需要扩展的服务，并允许资源的最优利用。如我们之前提到的，当需要时，你可以只扩展桌位预订服务，而不影响其他任何组件。它还允许二维扩展；在这里，我们不仅可以增加交易量，还可以通过缓存增加数据量（平台扩展）。
- en: A development team can then focus on the delivery and shipping of new features,
    instead of worrying about the scaling issues (Product scale).
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 开发团队可以专注于新特性的交付和 shipping，而不是担心扩展问题（产品扩展）。
- en: Microservices could help you scale platform, people, and product dimensions
    as we have seen previously. People scaling here refers to an increase or decrease
    in team size depending on microservices' specific development and focus needs.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们之前所看到的，微服务可以帮助你扩展平台、人力和产品维度。这里的人力扩展指的是根据微服务的特定开发和关注需求，增加或减少团队规模。
- en: Microservice development using RESTful web-service development makes it scalable
    in the sense that the server-end of REST is stateless; this means that there is
    not much communication between servers, which makes it horizontally scalable.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 使用RESTful Web服务开发的微服务架构使系统在服务器端是无状态的；这意味着服务器之间的通信不多，这使得系统可以水平扩展。
- en: Release rollback in case of failure
  id: totrans-57
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在失败的情况下进行发布回滚
- en: Since monolithic applications are either bundled in the same archive or contained
    in a single directory, they prevent the deployment of code modularity. For example,
    many of you may have experienced the pain of delaying rolling out the whole release
    due to the failure of one feature.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 由于单体应用程序要么打包在同一个归档文件中，要么包含在单个目录中，因此它们阻止了代码模块化的部署。例如，许多人都可能有过因一个功能失败而推迟整个发布的痛苦经历。
- en: To resolve these situations, microservices gives us the flexibility to rollback
    only those features that have failed. It's a very flexible and productive approach.
    For example, let's assume you are the member of an online shopping portal development
    team and want to develop an application based on microservices. You can divide
    your application based on different domains such as products, payments, cart,
    and so on, and package all these components as separate packages. Once you have
    deployed all these packages separately, these would act as single components that
    can be developed, tested, and deployed independently, and called µService.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 为了解决这些问题，微服务为我们提供了灵活性，只回滚失败的功能。这是一种非常灵活且高效的方法。例如，假设你是在线购物门户开发团队的一员，并希望基于微服务开发应用程序。你可以根据不同的领域（如产品、支付、购物车等）将应用程序进行划分，并将所有这些组件作为单独的包进行打包。一旦你单独部署了所有这些包，它们将作为可以独立开发、测试和部署的单一组件，并被称为微服务。
- en: Now, let's see how that helps you. Let's say that after a production release
    launching new features, enhancements, and bug fixes, you find flaws in the payment
    service that need an immediate fix. Since the architecture you have used is based
    on microservices, you can rollback the payment service instead of rolling back
    the whole release, if your application architecture allows, or apply the fixes
    to the microservices payment service without affecting the other services. This
    not only allows you to handle failure properly, but it also helps to deliver the
    features/fixes swiftly to a customer.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们看看这如何帮助你。假设在生产环境中推出新功能、增强功能和修复程序后，你发现支付服务存在缺陷需要立即修复。由于你使用的架构是基于微服务的，因此如果你的应用程序架构允许，你可以只回滚支付服务，而不是整个发布，或者在不影响其他服务的情况下将修复程序应用于微服务支付服务。这不仅使你能够恰当地处理失败，而且还帮助您迅速将功能/修复传递给客户。
- en: Problems in adopting new technologies
  id: totrans-61
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 采用新技术的问题
- en: Monolithic applications are mostly developed and enhanced based on the technologies
    primarily used during the initial development of a project or a product. It makes
    it very difficult to introduce new technology at a later stage of the development
    or once the product is in a mature state (for example, after a few years). In
    addition, different modules in the same project, that depend on different versions
    of the same library, make this more challenging.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 单体应用程序主要是基于项目或产品最初开发阶段主要使用的技术进行开发和增强的。这使得在开发的后期阶段或产品成熟后（例如，几年后）引入新技术变得非常困难。此外，同一项目中依赖不同版本的同一库的不同模块使这更具挑战性。
- en: Technology is improving year on year. For example, your system might be designed
    in Java and then, a few years later, you want to develop a new service in Ruby
    on Rails or NodeJS because of a business need or to utilize the advantages of
    new technologies. It would be very difficult to utilize the new technology in
    an existing monolithic application.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 技术每年都在进步。例如，您的系统可能设计为用Java实现，然后几年后，由于业务需求或利用新技术的优势，您可能希望用Ruby on Rails或NodeJS开发一个新服务。在一个现有的单体应用程序中利用新技术将非常困难。
- en: It is not just about code-level integration, but also about testing and deployment.
    It is possible to adopt a new technology by re-writing the entire application,
    but it is time-consuming and a risky thing to do.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 这不仅仅是代码级别集成的問題，还包括测试和部署。可以通过重写整个应用程序来采用新技术，但这既耗时又冒险。
- en: On the other hand, because of its component-based development and design, microservices
    gives us the flexibility to use any technology, new or old, for its development.
    It does not restrict you to using specific technologies, it gives a new paradigm
    to your development and engineering activities. You can use Ruby on Rails, NodeJS,
    or any other technology at any time.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，由于其基于组件的开发和设计，微服务为我们提供了使用任何技术的灵活性，无论是新的还是旧的。它不会限制你使用特定的技术，为你的开发和工程活动提供了新的范式。你随时可以使用Ruby
    on Rails、NodeJS或其他任何技术。
- en: So, how is it achieved? Well, it's very simple. Microservices-based application
    code does not bundle into a single archive and is not stored in a single directory.
    Each µService has its own archive and is deployed separately. A new service could
    be developed in an isolated environment and could be tested and deployed without
    any technical issues. As you know, microservices also owns its own separate processes;
    it serves its purpose without any conflict such as shared resources with tight
    coupling, and processes remain independent.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，这是如何实现的呢？嗯，其实很简单。基于微服务的应用程序代码不会打包成一个单一的归档，也不会存储在单一的目录中。每个微服务都有自己的归档，并且是独立部署的。一个新的服务可以在一个隔离的环境中开发，并且可以没有任何技术问题地进行测试和部署。正如你所知，微服务也有自己的独立进程；它在不存在紧耦合的共享资源冲突的情况下完成其功能，并且进程保持独立。
- en: Since a microservice is by definition a small, self-contained function, it provides
    a low-risk opportunity to try a new technology. That is definitely not the case
    where monolithic systems are concerned.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 由于微服务定义上是一个小型的、自包含的功能，它提供了一个尝试新技术的低风险机会。而在单体系统中，情况绝对不是这样。
- en: You can also make your microservice available as open source software so it
    can be used by others, and if required it may interoperate with a closed source
    proprietary one, which is not possible with monolithic applications.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 你还可以让你的微服务作为开源软件提供给他人使用，如果需要，它还可以与闭源专有软件互操作，这是单体应用程序所不可能实现的。
- en: Alignment with Agile practices
  id: totrans-69
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 与敏捷实践的对齐
- en: 'There is no question that monolithic applications can be developed using Agile
    practices, and these are being developed. **Continuous Integration (CI)** and
    **Continuous Deployment (CD)** could be used, but the question is—does it use
    Agile practices effectively? Let''s examine the following points:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 毫无疑问，可以使用敏捷实践来开发单体应用程序，而且这样的应用程序正在被开发。可以采用**持续集成（CI）**和**持续部署（CD）**，但问题在于——它是否有效地使用了敏捷实践？让我们来分析以下几点：
- en: For example, when there is a high probability of having stories dependent on
    each other, and there could be various scenarios, a story could not be taken up
    until the dependent story is complete
  id: totrans-71
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 例如，当有高概率的故事相互依赖，并且有各种场景时，只有在依赖的故事完成后才能开始一个故事。
- en: The build takes more time as the code size increases
  id: totrans-72
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 随着代码规模的增加，构建所需的时间也会增加。
- en: The frequent deployment of a large monolithic application is a difficult task
    to achieve
  id: totrans-73
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 频繁部署大型单体应用程序是一项难以实现的任务。
- en: You would have to redeploy the whole application even if you updated a single
    component
  id: totrans-74
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 即使你只更新了一个组件，你也必须重新部署整个应用程序。
- en: Redeployment may cause problems to already running components, for example,
    a job scheduler may change whether components impact it or not
  id: totrans-75
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 重新部署可能会对正在运行的组件造成问题，例如，作业调度器可能会改变无论组件是否受其影响。
- en: The risk of redeployment may increase if a single changed component does not
    work properly or if it needs more fixes
  id: totrans-76
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果单个更改的组件不能正常工作或需要更多的修复，重新部署的风险可能会增加。
- en: UI developers always need more redeployment, which is quite risky and time-consuming
    for large monolithic applications
  id: totrans-77
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 界面开发者总是需要更多的重新部署，这对于大型单体应用程序来说是非常冒险和耗时的。
- en: The preceding issues can be tackled very easily by microservices, for example,
    UI developers may have their own UI component that can be developed, built, tested,
    and deployed separately. Similarly, other microservices might also be deployable
    independently and, because of their autonomous characteristics, the risk of system
    failure is reduced. Another advantage for development purposes is that UI developers
    can make use of the JSON object and mock Ajax calls to develop the UI, which can
    be taken up in an isolated manner. After development completes, developers can
    consume the actual APIs and test the functionality. To summarize, you could say
    that microservices development is swift and it aligns well with the incremental
    needs of businesses.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 微服务可以很轻松地解决前面提到的问题，例如，UI开发者可能有自己的UI组件，可以独立地开发、构建、测试和部署。同样，其他微服务也可能可以独立部署，由于它们具有自主特性，因此降低了系统失败的风险。对于开发来说，另一个优点是UI开发者可以利用JSON对象和模拟Ajax调用来开发UI，这种方式是隔离的。开发完成后，开发者可以消费实际的API并进行功能测试。总结来说，可以说微服务开发是迅速的，并且很好地适应了企业逐步增长的需求。
- en: Ease of development – could be done better
  id: totrans-79
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 开发容易度 - 可以做得更好
- en: Generally, large monolithic application code is the toughest to understand for
    developers, and it takes time before a new developer can become productive. Even
    loading the large monolithic application into IDE is troublesome, and it makes
    IDE slower and the developer less productive.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，大型单体应用程序的代码对于开发者来说是最难以理解的，新开发者需要时间才能变得高效。即使将大型单体应用程序加载到IDE中也是麻烦的，这会使得IDE变慢，并降低开发者的效率。
- en: A change in a large monolithic application is difficult to implement and takes
    more time due to a large code base, and there will be a high risk of bugs if impact
    analysis is not done properly and thoroughly. Therefore, it becomes a prerequisite
    for developers to do thorough impact analysis before implementing changes.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 在一个大型单体应用程序中进行更改是困难的，并且由于代码库庞大，需要更多的时间，如果没有进行彻底的影响分析，就会有很高的bug风险。因此，在实施更改之前，开发者进行彻底的影响分析是一个前提条件。
- en: In monolithic applications, dependencies build up over time as all components
    are bundled together. Therefore, the risk associated with code change rises exponentially
    as code changes (number of modified lines of code) grows.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 在单体应用程序中，随着时间的推移，依赖关系逐渐建立，因为所有组件都捆绑在一起。因此，与代码更改（修改的代码行数）增长相关的风险呈指数级上升。
- en: When a code base is huge and more than 100 developers are working on it, it
    becomes very difficult to build products and implement new features because of
    the previously mentioned reason. You need to make sure that everything is in place,
    and that everything is coordinated. A well-designed and documented API helps a
    lot in such cases.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 当代码库很大且有超过100个开发者正在工作时，由于之前提到的原因，构建产品和实施新功能变得非常困难。你需要确保一切就绪，并且一切协调一致。在这种情况下，设计良好且文档齐全的API会有很大帮助。
- en: Netflix, the on-demand internet streaming provider, had problems getting their
    application developed, with around 100 people working on it. Then, they used a
    cloud and broke up the application into separate pieces. These ended up being
    microservices. Microservices grew from the desire for speed and agility and to
    deploy teams independently.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: Netflix，这个按需互联网流媒体服务提供商，在他们有大约100人在开发应用程序时遇到了问题。然后，他们使用了云，并将应用程序拆分成不同的部分。这些最终成为了微服务。微服务源于对速度和敏捷性的渴望，以及独立部署团队的需求。
- en: Micro-components are made loosely coupled thanks to their exposed API, which
    can be continuously integration tested. With microservices' continuous release
    cycle, changes are small and developers can rapidly exploit them with a regression
    test, then go over them and fix the eventual defects found, reducing the risk
    of a deployment. This results in higher velocity with a lower associated risk.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 由于微组件通过暴露的API实现了松耦合，可以持续进行集成测试。在微服务的持续发布周期中，变化很小，开发人员可以快速地进行回归测试，然后进行审查并修复发现的缺陷，从而降低了部署的风险。这导致了更高的速度和较低的相关风险。
- en: Owing to the separation of functionality and single responsibility principle,
    microservices makes teams very productive. You can find a number of examples online
    where large projects have been developed with minimum team sizes such as eight
    to ten developers.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 由于功能分离和单一责任原则，微服务使团队非常高效。你可以在网上找到许多例子，大型项目是用最小的团队规模（如八到十名开发者）开发的。
- en: Developers can have better focus with smaller code and resultant better feature
    implementation that leads to a higher empathic relationship with the users of
    the product. This conduces better motivation and clarity in feature implementation.
    An empathic relationship with users allows a shorter feedback loop and better
    and speedy prioritization of the feature pipeline. A shorter feedback loop also
    makes defect detection faster.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
- en: Each microservices team works independently and new features or ideas can be
    implemented without being coordinated with larger audiences. The implementation
    of end-point failures handling is also easily achieved in the microservices design.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
- en: Recently, at one of the conferences, a team demonstrated how they had developed
    a microservices-based transport-tracking application including iOS and Android
    applications within 10 weeks, which had Uber-type tracking features. A big consulting
    firm gave a seven months estimation for the same application to its client. It
    shows how microservices is aligned with Agile methodologies and CI/CD.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
- en: Microservices build pipeline
  id: totrans-90
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Microservices could also be built and tested using the popular CI/CD tools such
    as Jenkins, TeamCity, and so on. It is very similar to how a build is done in
    a monolithic application. In microservices, each microservice is treated like
    a small application.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, once you commit the code in the repository (SCM), CI/CD tools
    trigger the build process:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
- en: Cleaning code
  id: totrans-93
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Code compilation
  id: totrans-94
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Unit test execution
  id: totrans-95
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Contract/Acceptance test execution
  id: totrans-96
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Building the application archives/container images
  id: totrans-97
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Publishing the archives/container images to repository management
  id: totrans-98
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Deployment on various Delivery environments such as Dev, QA, Stage, and so on
  id: totrans-99
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Integration and Functional test execution
  id: totrans-100
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Any other steps
  id: totrans-101
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Then, release-build triggers that change the SNAPSHOT or RELEASE version in
    `pom.xml` (in case of Maven) build the artifacts as described in the normal build
    trigger. Publish the artifacts to the artifacts repository. Tag this version in
    the repository. If you use the container image then build the container image
    as a part of the build.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
- en: Deployment using a container such as Docker
  id: totrans-103
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Owing to the design of microservices, you need to have an environment that provides
    flexibility, agility, and smoothness for continuous integration and deployment
    as well as for shipment. Microservices deployments need speed, isolation management,
    and an Agile life-cycle.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
- en: Products and software can also be shipped using the concept of an intermodal-container
    model. An intermodal-container is a large standardized container, designed for
    intermodal freight transport. It allows cargo to use different modes of transport—truck,
    rail, or ship without unloading and reloading. This is an efficient and secure
    way of storing and transporting stuff. It resolves the problem of shipping, which
    previously had been a time consuming, labor-intensive process, and repeated handling
    often broke fragile goods.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
- en: Shipping containers encapsulate their content. Similarly, software containers
    are starting to be used to encapsulate their contents (products, applications,
    dependencies, and so on).
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
- en: Previously, **Virtual Machines** (**VMs**) were used to create software images
    that could be deployed where needed. Later, containers such as Docker became more
    popular as they were compatible with both traditional virtual stations systems
    and cloud environments. For example, it is not practical to deploy more than a
    couple of VMs on a developer's laptop. Building and booting a VM is usually I/O
    intensive and consequently slow.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
- en: Containers
  id: totrans-108
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A container (for example, Linux containers) provides a lightweight runtime environment
    consisting of the core features of virtual machines and the isolated services
    of operating systems. This makes the packaging and execution of microservices
    easy and smooth.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
- en: As the following diagram shows, a container runs as an application (microservice)
    within the **Operating** **System**. The OS sits on top of the hardware and each
    OS could have multiple containers, with a container running the application.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
- en: 'A container makes use of an operating system''s kernel interfaces, such as
    **cnames** and **namespaces**, that allow multiple containers to share the same
    kernel while running in complete isolation to one another. This gives the advantage
    of not having to complete an OS installation for each usage; the result being
    that it removes the overhead. It also makes optimal use of the **Hardware**:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/a8adb807-2da8-4607-a466-8fe5b9cf4a0f.png)'
  id: totrans-112
  prefs: []
  type: TYPE_IMG
- en: Layer diagram for containers
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
- en: Docker
  id: totrans-114
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Container technology is one of the fastest growing technologies today, and Docker
    leads this segment. Docker is an open source project and it was launched in 2013\.
    10,000 developers tried it after its interactive tutorial launched in August 2013\.
    It was downloaded 2.75 million times by the time of the launch of its 1.0 release
    in June 2013\. Many large companies have signed the partnership agreement with
    Docker, such as Microsoft, Red Hat, HP, OpenStack, and service providers such
    as Amazon Web Services, IBM, and Google.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
- en: As we mentioned earlier, Docker also makes use of the Linux kernel features,
    such as cgroups and namespaces, to ensure resource isolation and packaging of
    the application with its dependencies. This packaging of dependencies enables
    an application to run as expected across different Linux operating systems/distributions,
    supporting a level of portability. Furthermore, this portability allows developers
    to develop an application in any language and then easily deploy it from a laptop
    to a test or production server.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
- en: Docker runs natively on Linux. However, you can also run Docker on Windows and
    MacOS using VirtualBox and boot2docker.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
- en: Containers are comprised of just the application and its dependencies including
    the basic operating system. This makes it lightweight and efficient in terms of
    resource utilization. Developers and system administrators get interested in container's
    portability and efficient resource utilization.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
- en: Everything in a Docker container executes natively on the host and uses the
    host kernel directly. Each container has its own user namespace.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
- en: Docker's architecture
  id: totrans-120
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'As specified on Docker documentation, Docker architecture uses client-server
    architecture. As shown in the following figure (sourced from Docker''s website:
    [https://docs.docker.com/engine/docker-overview/](https://docs.docker.com/engine/docker-overview/)),
    the Docker client is primarily a user interface that is used by an end user; clients
    communicate back and forth with a Docker daemon. The Docker daemon does the heavy
    lifting of the building, running, and distributing of your Docker containers.
    The Docker client and the daemon can run on the same system or different machines.'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
- en: The Docker client and daemon communicate via sockets or through a RESTful API.
    Docker registers are public or private Docker image repositories from which you
    upload or download images, for example, Docker Hub ([hub.docker.com](https://hub.docker.com/))
    is a public Docker registry.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/0ad926bf-861d-4c67-9004-46caa8f4fe7f.png)'
  id: totrans-123
  prefs: []
  type: TYPE_IMG
- en: Docker's architecture
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
- en: 'The primary components of Docker are:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
- en: '**Docker image**: A Docker image is a read-only template. For example, an image
    could contain an Ubuntu operating system with Apache web server and your web application
    installed. Docker images are a build component of Docker and images are used to
    create Docker containers. Docker provides a simple way to build new images or
    update existing images. You can also use images created by others and/or extend
    them.'
  id: totrans-126
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Docker container**: A Docker container is created from a Docker image. Docker
    works so that the container can only see its own processes, and have its own filesystem
    layered onto a host filesystem and a networking stack, which pipes to the host-networking
    stack. Docker **Containers** can be run, started, stopped, moved, or deleted.'
  id: totrans-127
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Deployment
  id: totrans-128
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Microservices deployment with Docker deals with three parts:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
- en: Application packaging, for example, JAR
  id: totrans-130
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Building Docker image with a JAR and dependencies using a Docker instruction
    file, the Dockerfile, and command `docker build`. It helps to repeatedly create
    the image
  id: totrans-131
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Docker container execution from this newly built image using command `docker
    run`
  id: totrans-132
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The preceding information will help you to understand the basics of Docker.
    You will learn more about Docker and its practical usage in [Chapter 5](b1f93b4e-3475-4d8a-8c9f-697b0fd4410c.xhtml),
    *Deployment and Testing*. Source and reference, refer to: [https://docs.docker.com](https://docs.docker.com).'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  id: totrans-134
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, you have learned or recapped the high-level design of large
    software projects, from traditional monolithic to microservices applications.
    You were also introduced to a brief history of microservices, the limitation of
    monolithic applications, and the benefits and flexibility that microservices offer.
    I hope this chapter helped you to understand the common problems faced in a production
    environment by monolithic applications and how microservices can resolve such
    problem. You were also introduced to lightweight and efficient Docker containers
    and saw how containerization is an excellent way to simplify microservices deployment.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你已经学习了大型软件项目的高级设计，从传统的单体应用到微服务应用。你还简要了解了微服务的历史、单体应用的局限性以及微服务所提供的优势和灵活性。我希望这一章能帮助你理解单体应用在生产环境中遇到的一些常见问题以及微服务如何解决这些问题。你还了解到了轻量级且高效的Docker容器，并看到了容器化是简化微服务部署的绝佳方式。
- en: In the next chapter, you will get to know about setting up the development environment
    from IDE, and other development tools, to different libraries. We will deal with
    creating basic projects and setting up Spring Boot configuration to build and
    develop our first microservice. We will be using Java 9 as the language and Spring
    Boot for our project.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，你将了解到如何从IDE设置开发环境，以及其他开发工具和不同的库。我们将处理创建基本项目并设置Spring Boot配置来构建和开发我们的第一个微服务。我们将使用Java
    9作为编程语言和Spring Boot来完成项目。
