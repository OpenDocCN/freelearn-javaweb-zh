- en: Single Sign-On with the Central Authentication Service
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we'll examine the use of the **Central Authentication Service**
    (**CAS**) as a single sign-on portal for Spring Security-based applications.
  prefs: []
  type: TYPE_NORMAL
- en: 'During the course of this chapter, we''ll cover the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Learning about CAS, its architecture, and how it benefits system administrators
    and organizations of any size
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Understanding how Spring Security can be reconfigured to handle the interception
    of authentication requests and redirecting it to CAS
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Configuring the JBCP calendar application to utilize CAS single sign-on
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Gaining an understanding of how a single logout can be performed, and configuring
    our application to support it
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Discussing how to use CAS proxy ticket authentication for services, and configuring
    our application to utilize proxy ticket authentication
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Discussing how to customize the out-of-the-box **JA-SIG CAS** server using the
    recommended war overlay approach
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Integrating the CAS server with LDAP, and passing data from LDAP to Spring Security
    via CAS
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Introducing the Central Authentication Service
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'CAS is an open source, single sign-on server, providing centralized access
    control, and authentication to web-based resources within an organization. The
    benefits of CAS are numerous to administrators, and it supports many applications
    and diverse user communities. The benefits are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Individual or group access to resources (applications) can be configured in
    one location
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Broad support for a wide variety of authentication stores (to centralize user
    management) provides a single point of authentication and control to a widespread,
    cross-machine environment
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Wide authentication support is provided for web-based and non-web-based Java
    applications through CAS client libraries
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A single point of reference for user credentials (via CAS) is provided so that
    CAS client applications are not required to have any knowledge of the user's credentials,
    or knowledge of how to verify them
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In this chapter, we'll not focus much on the management of CAS, but on authentication
    and how CAS can act as an authentication point for the users of our site. Although
    CAS is commonly seen in intranet environments for enterprises or educational institutions,
    it can also be found in use at high profile locations such as Sony Online Entertainment's
    public-facing site.
  prefs: []
  type: TYPE_NORMAL
- en: High-level CAS authentication flow
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'At a high level, CAS is composed of a CAS server, which is the central web
    application for determining authentication, and one or more CAS services, which
    are distinct web applications that use the CAS server to get authenticated. The
    basic authentication flow of CAS proceeds via the following actions:'
  prefs: []
  type: TYPE_NORMAL
- en: The user attempts to access a protected resource on the website.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The user is redirected through the browser from the CAS service to the CAS server
    to request a login.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The CAS server is responsible for user authentication. If the user is not already
    authenticated to the CAS server, it requests credentials from the user. In the
    following diagram, the user is presented with a login page.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The user submits the credentials (that is, the username and password).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If the user's credentials are valid, the CAS server responds with a redirect
    through the browser with a service ticket. A service ticket is a one-time use
    token used to identify a user.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The CAS service calls the CAS server back to verify that the ticket is valid,
    has not expired, and so on. Note that this step does not occur through the browser.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The CAS server responds with an assertion indicating that trust has been established.
    If the ticket is acceptable, trust has been established and the user may proceed
    via normal authorization checking.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Visually, this behaves as illustrated in the following diagram:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/93089ee8-4fe7-41ea-8a0c-1bbda83dbb11.png)'
  prefs: []
  type: TYPE_IMG
- en: We can see that there is a high level of interaction between the CAS server
    and the secured application, with several data exchange handshakes required before
    the trust of the user can be established. The result of this complexity is a single
    sign-on protocol that is quite hard to spoof through common techniques (assuming
    other network security precautions, such as the use of SSL and network monitoring,
    are in place).
  prefs: []
  type: TYPE_NORMAL
- en: Now that we understand how CAS authentication works in general, let's see how
    it applies to Spring Security.
  prefs: []
  type: TYPE_NORMAL
- en: Spring Security and CAS
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Spring Security has a strong integration capability with CAS, although it's
    not as tightly integrated into the security namespace style of configuration like
    the OAuth2 and LDAP integrations that we've explored thus far in the latter part
    of this book. Instead, much of the configuration relies on bean wiring and configuration
    by reference, from the security namespace elements to bean declarations.
  prefs: []
  type: TYPE_NORMAL
- en: 'The two basic pieces of CAS authentication when using Spring Security involve
    the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Replacement of the standard `AuthenticationEntryPoint` implementation, which
    typically handles redirection of unauthenticated users to the login page with
    an implementation that redirects the user to the CAS server instead
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Processing the service ticket when the user is redirected back from the CAS
    server to the protected resource, through the use of a custom servlet filter
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: An important thing to understand about CAS is that in typical deployments, CAS
    is intended to replace all of the alternative login mechanisms of your application.
    As such, once we configure CAS for Spring Security, our users must use CAS exclusively
    as an authentication mechanism to our application. In most cases, this is not
    a problem; as we discussed in the previous section, CAS is designed to proxy authentication
    requests to one or more authentication stores (similar to what Spring Security
    does when delegating to a database or LDAP for authentication). From the previous
    diagram, we can see that our application is no longer checking its own authentication
    store to validate users. Instead, it determines the user through the use of the
    service ticket. However, as we will discuss later, initially, Spring Security
    still needs a data store to determine the user's authorization. We will discuss
    how to remove this restriction later on in the chapter.
  prefs: []
  type: TYPE_NORMAL
- en: After completing the basic CAS integration with Spring Security, we can remove
    the login link from the home page and enjoy automatic redirection to CAS's login
    screen, where we attempt to access a protected resource. Of course, depending
    on the application, it can also be beneficial to still allow the user to explicitly
    log in (so that they can see customized content, and so on).
  prefs: []
  type: TYPE_NORMAL
- en: Required dependencies
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Before we got too far, we should ensure that our dependencies are updated.
    A list of the dependencies that we have added with comments about when they are
    needed can be seen, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: Installing and configuring CAS
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: CAS has the benefit of having an extremely dedicated team behind it that has
    done an excellent job of developing both quality software and accurate, straightforward
    documentation on how to use it. Should you choose to follow along with the examples
    in this chapter, you are encouraged to read the appropriate getting started manual
    for your CAS platform. You can find this manual at [https://apereo.github.io/cas/5.1.x/index.html](https://apereo.github.io/cas/5.1.x/index.html).
  prefs: []
  type: TYPE_NORMAL
- en: In order to make integration as simple as possible, we have included a CAS server
    application for this chapter, which can be deployed in the Spring Tool Suite or
    in IntelliJ, along with the calendar application. For the examples in this chapter,
    we will assume that CAS is deployed at `https://localhost:9443/cas/` and the calendar
    application is deployed at `https://localhost:8443/`. In order to work, CAS requires
    the use of HTTPS. For detailed instructions on setting up HTTPS, refer to the
    Appendix, *Additional Reference Material*.
  prefs: []
  type: TYPE_NORMAL
- en: The examples in this chapter were written using the most recent, available version
    of the CAS server, 5.1.2 at the time of writing. Be aware that some significant
    changes to some of the backend classes were made to CAS in the 5.x time frame.
    So, if you are on an earlier version of the server, these instructions may be
    slightly or significantly different for your environment.
  prefs: []
  type: TYPE_NORMAL
- en: Let's go ahead and configure the components required for CAS authentication.
  prefs: []
  type: TYPE_NORMAL
- en: You should start the chapter off with the source from `chapter10.00-calendar`
    and `chapter10.00-cas-server`.
  prefs: []
  type: TYPE_NORMAL
- en: Configuring basic CAS integration
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Since the Spring Security namespace does not support CAS configuration, there
    are quite a few more steps that we need to implement in order to get a basic setup
    working. In order to get a high-level understanding of what is happening, you
    can refer to the following diagram.
  prefs: []
  type: TYPE_NORMAL
- en: 'Don''t worry about understanding the entire diagram right now, as we will break
    it into small chunks in order to make it easy to digest:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/414892bb-05b4-4d94-9cf5-79ef506f42ac.png)'
  prefs: []
  type: TYPE_IMG
- en: Creating the CAS ServiceProperties object
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The Spring Security setup relies on an `o.s.s.cas.ServiceProperties` bean in
    order to store common information about the CAS service. The `ServiceProperties`
    object plays a role in coordinating the data exchange between the various CAS
    components-it is used as a data object to store CAS configuration settings that
    are shared (and are expected to match) by the varying participants in the Spring
    CAS stack. You can view the configuration included in the following code snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: You probably noticed that we leveraged system properties to use variables named
    `${cas.service}` and `${cas.server}`. Both of these values can be included in
    your application, and Spring will automatically replace them with the values provided
    in the `PropertySources` configuration. This is a common strategy when deploying
    a CAS service, since the CAS server will likely change as we progress from development
    to production. In this instance, we use `localhost:9443` by default for the CAS
    server and `localhost:8443` for the calendar application. This configuration can
    be overridden using a system argument when the application is taken to production.
    Alternatively, the configuration can be externalized into a Java properties files.
    Either mechanism allows us to externalize our configuration properly.
  prefs: []
  type: TYPE_NORMAL
- en: Adding the CasAuthenticationEntryPoint object
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'As we briefly mentioned earlier in this chapter, Spring Security uses an `o.s.s.web.AuthenticationEntryPoint`
    interface to request credentials from the user. Typically, this involves redirecting
    the user to the login page. With CAS, we will need to redirect the CAS server
    to request a login. When we redirect to the CAS server, Spring Security must include
    a `service` parameter that indicates where the CAS server should send the service
    ticket. Fortunately, Spring Security provides the `o.s.s.cas.web.CasAuthenticationEntryPoint`
    object, which is specifically designed for this purpose. The configuration that
    is included in the sample application is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'The `CasAuthenticationEntryPoint` object uses the `ServiceProperties` class
    to specify where to send the service ticket once the user is authenticated. CAS
    allows for the selective granting of access per user, per application, based on
    configuration. We''ll examine the particulars of this URL in a moment when we
    configure the servlet filter that is expected to process it. Next, we will need
    to update Spring Security to utilize the bean with the `casAuthenticationEntryPoint`
    ID. Make the following update to our `SecurityConfig.java` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'Lastly, we need to ensure that the `CasConfig.java` file is loaded by Spring.
    Update the `SecurityConfig.java` file, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'The last thing you need to do is to remove the existing `UserDetailsService`
    object as the `userDetailsService` implementation of the `AuthenticationManager`,
    as it is no longer required as the `CasAuthenticationEntryPoint` replaces it in
    the SecurityConfig.java file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: If you start the application at this point and attempt to access the My Events
    page, you will immediately be redirected to the CAS server for authentication.
    The default configuration of CAS allows authentication for any user whose username
    is equal to the password. So, you should be able to log in with the username `admin1@example.com`
    and the password `admin1@example.com` (or `user1@example.com`/`user1@example.com`).
  prefs: []
  type: TYPE_NORMAL
- en: You'll notice, however, that even after the login, you will immediately be redirected
    back to the CAS server. This is because although the destination application was
    able to receive the ticket, it wasn't able to be validated, and as such the `AccessDeniedException`
    object is handled by CAS as a rejection of the ticket.
  prefs: []
  type: TYPE_NORMAL
- en: Proving authenticity with the CasAuthenticationProvider object
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: If you have been following the logical flow of Spring Security throughout the
    rest of this book, hopefully, you already know what comes next-the `Authentication`
    token must be inspected by an appropriate `AuthenticationProvider` object. CAS
    is no different, and as such, the final piece of the puzzle is the configuration
    of an `o.s.s.cas.authentication.CasAuthenticationProvider` object within `AuthenticationManager`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s take a look at the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'First, we''ll declare the Spring bean in the `CasConfig.java` file, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, we''ll configure a reference to this new `AuthenticationProvider` object
    in `SecurityConfig.java`, where our `AuthenticationManager` declaration resides:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'If you have any other `AuthenticationProvider` references remaining from prior
    exercises, please remember to remove them from work with CAS. All of these changes
    are illustrated in the preceding code. Now, we''ll need to take care of the other
    attributes and bean references within the `CasAuthenticationProvider` class. The
    `ticketValidator` attribute refers to an implementation of the `org.jasig.cas.client.validation.TicketValidator`
    interface; as we are using the CAS 3.0 authentication, we''ll declare an `org.jasig.cas.client.validation.Cas30ServiceTicketValidator`
    instance, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: The constructor argument supplied to this class should refer (once again) to
    the URL used to access the CAS server. You'll note that at this point, we have
    moved out of the `org.springframework.security` package into `org.jasig`, which
    is part of the CAS client's JAR files. Later in this chapter, we'll see that the
    `TicketValidator` interface also has implementations (still within the CAS client's
    JAR files) that support other methods of authentication with CAS, such as the
    proxy ticket and SAML authentications.
  prefs: []
  type: TYPE_NORMAL
- en: Next, we can see the `key` attribute; this is simply used to validate the integrity
    of `UsernamePasswordAuthenticationToken` and can be arbitrarily defined.
  prefs: []
  type: TYPE_NORMAL
- en: 'Just as we saw in [Chapter 8](09.html), *Client Certificate Authentication
    with TLS*, the `authenticationUserDetailsService` attribute refers to an `o.s.s.core.userdetails.AuthenticationUserDetailsService`
    object that is used to translate the username information from the `Authentication`
    token to a fully-populated `UserDetails` object. The current implementation does
    this translation by looking up the username returned by the CAS server and looking
    up `UserDetails` using the `UserDetailsService` object. Obviously, this technique
    would only ever be used when we have confirmed that the integrity of the `Authentication`
    token has not been compromised. We configure this object with a reference to our
    `CalendarUserDetailsService` implementation of the `UserDetailsService` interface:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: You may wonder why a `UserDetailsService` interface isn't directly referenced;
    it's because, just as with OAuth2, there will be additional advanced configuration
    options later, which will allow details from the CAS server to be used to populate
    the `UserDetails` object.
  prefs: []
  type: TYPE_NORMAL
- en: Your code should look like `chapter10.01-calendar` and `chapter10.01-cas-server`.
  prefs: []
  type: TYPE_NORMAL
- en: At this point, we should be able to start both the CAS server and JBCP calendar
    application. You can then visit `https://localhost:8443/` and select All Events,
    which will redirect you to the CAS server. You can then log in using the username
    `admin1@example.com` and the password `admin1@example.com`. Upon successful authentication,
    you will be redirected back to the JBCP calendar application. Excellent job!
  prefs: []
  type: TYPE_NORMAL
- en: If you are experiencing issues, it is most likely due to an improper SSL configuration.
    Ensure that you have set up the trust store file as `tomcat.keystore`, as described
    in the Appendix, *Additional reference Material*.
  prefs: []
  type: TYPE_NORMAL
- en: Single logout
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: You may notice that if you log out of the application, you get the logout confirmation
    page. However, if you click on a protected page, such as the My Events page, you
    are still authenticated. The problem is that the logout is only occurring locally.
    So, when you request another protected resource in the JBCP calendar application,
    a login is requested from the CAS server. Since the user is still logged in to
    the CAS server, it immediately returns a service ticket and logs the user back
    into the JBCP calendar application.
  prefs: []
  type: TYPE_NORMAL
- en: 'This also means that if the user had signed in to other applications using
    the CAS server, they would still be authenticated to those applications, since
    our calendar application does not know anything about the other applications.
    Fortunately, CAS and Spring Security offer a solution to this problem. Just as
    we can request a login from the CAS server, we can also request a logout. You
    can see a high-level diagram of how a logout works within CAS, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/987b97c6-e600-405e-a800-648ca3f400c4.png)'
  prefs: []
  type: TYPE_IMG
- en: 'The following steps explain how a single logout takes place:'
  prefs: []
  type: TYPE_NORMAL
- en: The user requests to log out of the web application.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The web application then requests to log out of CAS by sending a redirect through
    the browser to the CAS server.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The CAS server recognizes the user and then sends a logout request to each CAS
    service that was authenticated. Note that these logout requests do not occur through
    the browser.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The CAS server indicates which user should log out by providing the original
    service ticket that was used to log the user in. The application is then responsible
    for ensuring that the user is logged out.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The CAS server displays the logout success page to the user.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Configuring single logout
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The configuration for a single logout is relatively simple:'
  prefs: []
  type: TYPE_NORMAL
- en: 'The first step is to specify a `logout-success-url` attribute to be the logout
    URL of the CAS server in our `SecurityConfig.java` file. This means that after
    we log out locally, we will automatically redirect the user to the CAS server''s
    logout page:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: Since we only have one application, this is all we need to make it appear as
    though a single logout is occurring. This is because we log out of our calendar
    application before redirecting to the CAS server logout page. This means that
    by the time the CAS server sends the logout request to the calendar application,
    the user has already been logged out.
  prefs: []
  type: TYPE_NORMAL
- en: 'If there were multiple applications and the user logged out of another application,
    the CAS server would send a logout request to our calendar application and not
    process the logout event. This is because our application is not listening to
    these logout events. The solution is simple; we must create the `SingleSignoutFilter`
    object, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, we need to make Spring Security aware of the `singleLogoutFilter` object
    in our `SecurityCOnfig.java` file by including it as a `<custom-filter>` element.
    Place the single logout filter before the regular logout to ensure that it receives
    the logout events, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'Under normal circumstances, we would need to make a few updates to the `web.xml`
    or `ApplicationInitializer` file. However, for our calendar application, we have
    already made the updates to our `CasConfig.java` file, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: First, we added the `SingleSignoutHttpSessionListener` object to ensure that
    the mapping of the service ticket to `HttpSession` was removed. We have also added
    `CharacterEncodingFilter`, as recommended by the JA-SIG documentation, to ensure
    that character encoding is correct when using `SingleSignOutFilter`.
  prefs: []
  type: TYPE_NORMAL
- en: Go ahead and start up the application and try logging out now. You will observe
    that you are actually logged out.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Now, try logging back in and visiting the CAS server's logout URL directly.
    For our setup, the URL is `https://localhost:9443/cas/logout`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Now, try to visit the JBCP calendar application. You will observe that you are
    unable to access the application without authenticating again. This demonstrates
    that a single logout works.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Your code should look like `chapter10.02-calendar` and `chapter10.02-cas-server`.
  prefs: []
  type: TYPE_NORMAL
- en: Clustered environments
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'One of the things that we failed to mention in our initial diagram of a single
    logout was how the logout is performed. Unfortunately, it is implemented by storing
    a mapping of the service ticket to `HttpSession` as an in-memory map. This means
    that a single logout will not work properly within a clustered environment:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/20770234-2dc4-410c-9237-c5481f56a004.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Consider the following situation:'
  prefs: []
  type: TYPE_NORMAL
- en: The user logs in to **Cluster Member A**
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Cluster Member A** validates the service ticket'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It then remembers, in memory, the mapping of the service ticket to the user's
    session
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The user requests to log out from the **CAS Server**
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The **CAS Server** sends a logout request to the CAS service, but the **Cluster
    Member B** receives the logout request. It looks in its memory but does not find
    a session for **Service Ticket A**, because it only exists in **Cluster Member
    A**. This means, the user has not been logged out successfully.
  prefs: []
  type: TYPE_NORMAL
- en: Users looking for this functionality might consider looking in the JA-SIG JIRA
    queue and forums for solutions to this problem. In fact, a working patch has been
    submitted on [https://issues.jasig.org/browse/CASC-114](https://issues.jasig.org/browse/CASC-114).
    Keep in mind that there are a number of ongoing discussions and proposals on the
    forums and in the JA-SIG JIRA queue, so you may want to look around before deciding
    which solution to use. For more information about clustering with CAS, refer to
    JA-SIG's clustering documentation at [https://wiki.jasig.org/display/CASUM/Clustering+CAS](https://wiki.jasig.org/display/CASUM/Clustering+CAS).
  prefs: []
  type: TYPE_NORMAL
- en: Proxy ticket authentication for stateless services
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Centralizing our authentication using CAS seems to work rather well for web
    applications, but what if we want to call a web service using CAS? In order to
    support this, CAS has a notion of **proxy tickets** (**PT**). The following is
    a diagram of how it works:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/21b96476-c1df-42b1-8cc2-01f250b3fe4a.png)'
  prefs: []
  type: TYPE_IMG
- en: 'The flow is the same as standard CAS authentication until the following things
    take place:'
  prefs: []
  type: TYPE_NORMAL
- en: The **Service Ticket** is validated when an additional parameter is included
    called the proxy ticket callback URL (**PGT URL**).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The **CAS Server** calls the **PGT URL** over **HTTPS** to validate that the
    **PGT URL** is what it claims to be. Like most of CAS, this is done by performing
    an SSL handshake to the appropriate URL.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The **CAS Server** submits the **Proxy Granting Ticket** (**PGT**) and the **Proxy
    Granting Ticket I Owe You** (**PGTIOU**) to the **PGT URL** over **HTTPS** to
    ensure that the tickets are submitted to the source they claim to be.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The **PGT URL** receives the two tickets and must store an association of the
    **PGTIOU** to the **PGT**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The **CAS Server** finally returns a response to the request in *step 1* that
    includes the username and the **PGTIOU**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The CAS service can look up the **PGT** using the **PGTIOU**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Configuring proxy ticket authentication
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Now that we know how PT authentication works, we will update our current configuration
    to obtain a PGT by performing the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'The first step is to add a reference to a `ProxyGrantingTicketStorage` implementation.
    Go ahead and add the following code to our `CasConfig.java` file:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'The `ProxyGrantingTicketStorageImpl` implementation is an in-memory mapping
    of the PGTIOU to a PGT. Just as with logging out, this means we would have problems
    in a clustered environment using this implementation. Refer to the JA-SIG documentation
    to determine how to set this up in a clustered environment: [https://wiki.jasig.org/display/CASUM/Clustering+CAS.](https://wiki.jasig.org/display/CASUM/Clustering+CAS)'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We also need to periodically clean `ProxyGrantingTicketStorage` by invoking
    its `cleanUp()` method. As you can see, Spring's task abstraction makes this very
    simple. You may consider tweaking the configuration to clear the `Ticket`'s, in
    a separate a thread pool that makes sense for your environment. For more information,
    refer to the *Task Execution* and *Scheduling* section of the Spring Framework
    Reference documentation at [http://static.springsource.org/spring/docs/current/spring-framework-reference/html/scheduling.html](http://static.springsource.org/spring/docs/current/spring-framework-reference/html/scheduling.html).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Now we need to use `ProxyGrantingTicketStorage`, which we have just created.
    We just need to update the `ticketValidator` method to refer to our storage and
    to know the PGT URL. Make the following updates to `CasConfig.java`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'The last update we need to make is to our `CasAuthenticationFilter` object,
    to store the PGTIOU to the PGT mapping in our `ProxyGrantingTicketStorage` implementation
    when the PGT URL is called. It is critical to ensure that the `proxyReceptorUrl`
    attribute matches the `proxyCallbackUrl` attribute of the `Cas20ProxyTicketValidator`
    object, to ensure that the CAS server sends the ticket to the URL that our application
    is listing to. Make the following changes to `security-cas.xml`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: Now that we have a PGT, what do we do with it? A service ticket is a one-time
    use token. However, a PGT can be used to produce PT. Let's see how we can create
    a PT using a PGT.
  prefs: []
  type: TYPE_NORMAL
- en: You will observe that the `proxyCallBackUrl` attribute matches the absolute
    path of our context-relative `proxyReceptorUrl` attribute path. Since we are deploying
    our base application to `https://${cas.service }/`, the full path of our `proxyReceptor`
    URL will be `https://${cas.service }/pgtUrl`.
  prefs: []
  type: TYPE_NORMAL
- en: Using proxy tickets
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We can now use our PGT to create a PT to authenticate it to a service. The
    code to do this is quite trivially demonstrated in the `EchoController` class
    that we have included with this chapter. You can see the relevant portions of
    it in the following code snippet. For additional details, refer to the sample''s
    source code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: This controller is a contrived example that will obtain a PT that will be used
    to authenticate a RESTful call to obtain all of the events for the currently logged-in
    user. It then writes the JSON response to the page. The thing that may confuse
    some users is that the `EchoController` object is actually making a RESTful call
    to the `MessagesController` object that is in the same application. This means
    that the calendar application makes a RESTful call to itself[.](https://localhost:8443/calendar/rest-client)
  prefs: []
  type: TYPE_NORMAL
- en: Go ahead and visit `https://localhost:8443/echo` to see it in action. The page
    looks a lot like the CAS login page (minus the CSS). This is because the controller
    attempts to echo our My Events page, and our application does not yet know how
    to authenticate a PT. This means it is redirected to the CAS login page. Let's
    see how we can authenticate proxy tickets.
  prefs: []
  type: TYPE_NORMAL
- en: Your code should look like `chapter10.03-calendar` and `chapter10.03-cas-server`.
  prefs: []
  type: TYPE_NORMAL
- en: Authenticating proxy tickets
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s take a look at the following steps to learn about authenticating proxy
    tickets:'
  prefs: []
  type: TYPE_NORMAL
- en: 'We first need to tell the `ServiceProperties` object that we want to authenticate
    all of the tickets and not just those submitted to the `filterProcessesUrl` attribute.
    Make the following updates to `CasConfig.java`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'We then need to update our `CasAuthenticationFilter` object for it to know
    that we want to authenticate all artifacts (that is, tickets) instead of only
    listening to a specific URL. We also need to use an `AuthenticationDetailsSource`
    interface that can dynamically provide the CAS service URL when validating proxy
    tickets on arbitrary URLs. This is important because when a CAS service asks whether
    a ticket is valid or not, it must also provide the CAS service URL that was used
    to create the ticket. Since proxy tickets can occur at any URL, we must be able
    to dynamically discover this URL. This is done by leveraging the `ServiceAuthenticationDetailsSource`
    object, which will provide the current URL from the HTTP request:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'We will also need to ensure that we are using the `Cas30ProxyTicketValidator`
    object and not the `Cas30ServiceTicketValidator` implementation, and indicate
    which proxy tickets we will want to accept. We will configure ours to accept a
    proxy ticket from any CAS service. In a production environment, you will want
    to consider restricting yourself to only those CAS services that are trusted:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'Lastly, we will want to provide a cache for our `CasAuthenticationProvider`
    object so that we do not need to hit the CAS service for every call to our service:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: As you might have suspected, the cache requires the `ehcache` dependency that
    we mentioned at the beginning of the chapter. Go ahead and start the application
    back up and visit `https://localhost:8443/echo` again. This time, you should see
    a JSON response to calling our My Events page.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Your code should look like `chapter10.04-calendar` and `chapter10.04-cas-server`.
  prefs: []
  type: TYPE_NORMAL
- en: Customizing the CAS server
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: All of the changes in this section will be to the CAS server and not the calendar
    application. This section is only meant to be an introduction to configuring the
    CAS server, as a detailed setup is certainly beyond the scope of this book. Just
    as with the changes for the calendar application, we encourage you to follow along
    with the changes in this chapter. For more information, you can refer to the JA-SIG
    CAS Wikipedia page at [https://wiki.jasig.org/display/CAS/Home](https://wiki.jasig.org/display/CAS/Home).
  prefs: []
  type: TYPE_NORMAL
- en: CAS WAR overlay
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The preferred way to customize CAS is to use a Maven or Gradle War overlay.
    With this mechanism, you can change everything from the UI to the method in which
    you authenticate to the CAS server. The concept of a WAR overlay is simple. You
    add a WAR overlay, `cas-server-webapp`, as a dependency, and then provide additional
    files that will be merged with the existing WAR overlay. For more information
    about the CAS WAR overlay, refer to the JA-SIG documentation at [https://wiki.jasig.org/display/CASUM/Best+Practice+-+Setting+Up+CAS+Locally+using+the+Maven2+WAR+Overlay+Method](https://wiki.jasig.org/display/CASUM/Best+Practice+-+Setting+Up+CAS+Locally+using+the+Maven2+WAR+Overlay+Method).
  prefs: []
  type: TYPE_NORMAL
- en: How does the CAS internal authentication work?
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Before we jump into CAS configuration, we''ll briefly illustrate the standard
    behavior of CAS authentication processing. The following diagram should help you
    follow the configuration steps required to allow CAS to talk to our embedded LDAP
    server:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/90ac09bd-55dd-43ed-bc1d-5d6ce644b782.png)'
  prefs: []
  type: TYPE_IMG
- en: While the previous diagram describes the internal flow of authentication within
    the CAS server itself, it is likely that if you are implementing integration between
    Spring Security and CAS, you will need to adjust the configuration of the CAS
    server as well. It's important, therefore, that you understand how CAS authentication
    works at a high level.
  prefs: []
  type: TYPE_NORMAL
- en: The CAS server's `org.jasig.cas.authentication.AuthenticationManager` interface
    (not to be confused with the Spring Security interface of the same name) is responsible
    for authenticating the user based on the provided credentials. Much as with Spring
    Security, the actual processing of the credentials is delegated to one (or more)
    processing class implementing the `org.jasig.cas.authentication.handler.AuthenticationHandler`
    interface (we recognize that the analogous interface in Spring Security would
    be `AuthenticationProvider`).
  prefs: []
  type: TYPE_NORMAL
- en: Finally, a `org.jasig.cas.authentication.principal.CredentialsToPrincipalResolver`
    interface is used to translate the credentials passed into a full `org.jasig.cas.authentication.principal.Principal`
    object (similar behavior in Spring Security occurs during the implementation of
    `UserDetailsService`).
  prefs: []
  type: TYPE_NORMAL
- en: While not a full review of the behind-the-scenes functionality of the CAS server,
    this should help you understand the configuration steps in the next several exercises.
    We encourage you to read the source code for CAS and consult the web-based documentation
    available at the JA-SIG CAS Wikipedia page at [http://www.ja-sig.org/wiki/display/CAS](http://www.ja-sig.org/wiki/display/CAS).
  prefs: []
  type: TYPE_NORMAL
- en: Configuring CAS to connect to our embedded LDAP server
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `org.jasig.cas.authentication.principal.UsernamePasswordCredentialsToPrincipalResolver`
    object that comes configured, by default, with CAS doesn't allow us to pass back
    attribute information and demonstrate this feature of Spring Security CAS integration,
    so we'd suggest using an implementation that does allow this.
  prefs: []
  type: TYPE_NORMAL
- en: An easy authentication handler to configure and use (especially if you have
    gone through the previous chapter's LDAP exercises) is `org.jasig.cas.adaptors.ldap.BindLdapAuthenticationHandler`,
    which communicates with the embedded LDAP server that we used in the previous
    chapter. We'll lead you through the configuration of CAS that returns user LDAP
    attributes in the following guide.
  prefs: []
  type: TYPE_NORMAL
- en: All of the CAS configuration will take place in the `WEB-INF/deployerConfigContext.xml`
    file of the CAS installation, and will typically involve inserting class declarations
    into configuration file segments that already exist. We have already extracted
    the default `WEB-INF/deployerConfigContext.xml` file from `cas-server-webapp`
    and placed it in `cas-server/src/main/webapp/WEB-INF`.
  prefs: []
  type: TYPE_NORMAL
- en: If the contents of this file look familiar to you, it's because CAS uses the
    Spring Framework for its configuration just like the JBCP calendar! We'd recommend
    using a good IDE with a handy reference to the CAS source code if you want to
    dig into what these configuration settings do. Remember that in this section,
    and all sections where we refer to `WEB-INF/deployerConfigContext.xml`, we are
    referring to the CAS installation and not JBCP calendar.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s take a look at the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: First, we'll add a new `BindLdapAuthenticationHandler` object in place of the
    `SimpleTestUsernamePasswordAuthenticationHandler` object, which will attempt to
    bind the user to LDAP (just as we did in [Chapter 6](07.html), *LDAP Directory
    Services*).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The `AuthenticationHandler` interface will be placed in the `authenticationHandlers`
    property of the `authenticationManager` bean:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: Don't forget to remove the reference to the `SimpleTestUsernamePasswordAuthenticationHandler`
    object, or at least move its definition to after that of the `BindLdapAuthenticationHandler`
    object, otherwise, your CAS authentication will not use LDAP and use the stub
    handler instead!
  prefs: []
  type: TYPE_NORMAL
- en: 'You''ll notice the bean reference to a `contextSource` bean; this defines the
    `org.springframework.ldap.core.ContextSource` implementation, which CAS will use
    to interact with LDAP (yes, CAS uses Spring LDAP as well). We''ll define this
    at the end of the file using the Spring Security namespace to simplify its definition,
    as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: This creates an embedded LDAP instance that uses the `calendar.ldif` file included
    with this chapter. Of course, in a production environment, you would want to point
    to a real LDAP server.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, we'll need to configure a new `org.jasig.cas.authentication.principal.CredentialsToPrincipalResolver`
    object. This is responsible for translating the credentials that the user has
    provided (that CAS has already authenticated using the `BindLdapAuthenticationHandler`
    object) into a full `org.jasig.cas.authentication.principal.Principal` authenticated
    principal. You'll notice many configuration options in this class, which we'll
    skim over. You are welcome to dive into them as you explore CAS further.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Remove `UsernamePasswordCredentialsToPrincipalResolver` and add the following
    bean definition inline to the `credentialsToPrincipalResolvers` property of the
    CAS `authenticationManager` bean:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: You'll notice that, as with the Spring Security LDAP configuration, much of
    the same behavior exists in CAS with principals being searched on property matches
    below a subtree of the directory, based on a DN.
  prefs: []
  type: TYPE_NORMAL
- en: Note that we haven't yet configured the bean with the ID `attributeRepository`
    ourselves, which should refer to an implementation of `org.jasig.services.persondir.IPersonAttributeDao`.
    CAS ships with a default configuration that includes a simple implementation of
    this interface, `org.jasig.services.persondir.support.StubPersonAttributeDao`,
    which will be sufficient until we configure LDAP-based attributes in a later exercise.
  prefs: []
  type: TYPE_NORMAL
- en: Your code should look like `chapter10.05-calendar` and `chapter10.05-cas-server`.
  prefs: []
  type: TYPE_NORMAL
- en: So, now we've configured basic LDAP authentication in CAS. At this point, you
    should be able to restart CAS, start JBCP calendar (if it's not already running),
    and authenticate it using `admin1@example.com`/`admin` or `user1@example.com/user1`.
    Go ahead and try it to see that it works. If it does not work, try checking the
    logs and comparing your configuration with the sample configuration.
  prefs: []
  type: TYPE_NORMAL
- en: As discussed in [Chapter 5](05.html), *Authentication with Spring Data*, you
    may encounter issues starting the application, whether or not the temporary directory
    named `apacheds-spring-security` still exists. If the application appears to not
    exist, check the logs and see if the `apacheds-spring-security` directory needs
    to be removed.
  prefs: []
  type: TYPE_NORMAL
- en: Getting the UserDetails object from a CAS assertion
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Up until this point, we have been authenticating with CAS by obtaining the roles
    from our `InMemoryUserDetailsManager` object. However, we can create the `UserDetails`
    object from the CAS assertion just as we did with OAuth2\. The first step is to
    configure the CAS server to return the additional attributes.
  prefs: []
  type: TYPE_NORMAL
- en: Returning LDAP attributes in the CAS response
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We know that CAS can return the username in the CAS response, but it can also
    return arbitrary attributes in the CAS response. Let's see how we can update the
    CAS server to return additional attributes. Again, all of the changes in this
    section are in the CAS server and not in the calendar application.
  prefs: []
  type: TYPE_NORMAL
- en: Mapping LDAP attributes to CAS attributes
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The first step requires us to map LDAP attributes to attributes in the CAS assertion
    (including the `role` attribute, which we're expecting to contain the user's `GrantedAuthority`).
  prefs: []
  type: TYPE_NORMAL
- en: 'We''ll add another bit of configuration to the CAS `deployerConfigContext.xml`
    file. This new bit of configuration is required to instruct CAS as to how to map
    attributes from the CAS `Principal` object to the CAS `IPersonAttributes` object,
    which will ultimately be serialized as part of ticket validation. This bean configuration
    should replace the bean of the same name-which is `attributeRepository`-as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: The functionality behind the scenes here is definitely confusing-essentially,
    the purpose of this class is to map `Principal` back to the LDAP directory. (This
    is the `queryAttributeMapping` property mapping the `username` field of `Principal`
    to the `uid` attribute in the LDAP query.) The provided `baseDN` Java Bean property
    is searched using the LDAP query (`uid=user1@example.com`), and attributes are
    read from the matching entry. The attributes are mapped back to `Principal` using
    the key/value pairs in the `resultAttributeMapping` property. We recognize that
    LDAP's `cn` and `sn` attributes are being mapped to meaningful names, and the
    `description` attribute is being mapped to the role that will be used for determining
    the authorization of our user.
  prefs: []
  type: TYPE_NORMAL
- en: Part of the complexity comes from the fact that a portion of this functionality
    is wrapped up in a separate project called `Person Directory` ([http://www.ja-sig.org/wiki/display/PD/Home](http://www.ja-sig.org/wiki/display/PD/Home)),
    which is intended to aggregate multiple sources of information about a person
    into a single view. The design of `Person Directory` is such that it is not directly
    tied to the CAS server and can be reused as part of other applications. The downside
    of this design choice is that it makes some aspects of CAS configuration more
    complex than it initially seems should be required.
  prefs: []
  type: TYPE_NORMAL
- en: Troubleshooting LDAP attribute mapping in CAS
  prefs: []
  type: TYPE_NORMAL
- en: We would love to set up the same type of query in LDAP as we used with Spring
    Security LDAP in [Chapter 6](07.html), *LDAP Directory Services*, to be able to
    map `Principal` to a full LDAP-distinguished name, and then to use that DN to
    look up group membership by matching on the basis of the `uniqueMember` attribute
    of a `groupOfUniqueNames` entry. Unfortunately, the CAS LDAP code doesn't have
    this flexibility yet, leading to the conclusion that more advanced LDAP mapping
    will require extensions to base classes in CAS.
  prefs: []
  type: TYPE_NORMAL
- en: Authorizing CAS services to access custom attributes
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Next, we will need to authorize any CAS service over HTTPS to access these
    attributes. To do this, we can update `RegisteredServiceImpl`, which has the description
    `Only Allows HTTPS URLs` in `InMemoryServiceRegistryDaoImpl`, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: Acquiring a UserDetails from CAS
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When we first set up CAS integration with Spring Security, we configured `UserDetailsByNameServiceWrapper`,
    which simply translated the username presented to CAS into a `UserDetails` object
    from `UserDetailsService`, which we had referenced (in our case, it was `InMemoryUserDetailsManager`).
    Now that CAS is referencing the LDAP server, we can set up `LdapUserDetailsService`,
    as we discussed at the tail end of [Chapter 6](07.html), *LDAP Directory Services*,
    and things will work just fine. Note that we have switched back to modifying the
    calendar application and not the CAS server.
  prefs: []
  type: TYPE_NORMAL
- en: The GrantedAuthorityFromAssertionAttributesUser object
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Now that we have modified the CAS server to return custom attributes, we''ll
    experiment with another capability of the Spring Security CAS integration-the
    ability to populate `UserDetails` from the CAS assertion itself! This is actually
    as simple as switching the `AuthenticationUserDetailsService` implementation to
    the `o.s.s.cas.userdetails.GrantedAuthorityFromAssertionAttributesUserDetailsService`
    object, whose job it is to read the CAS assertion, look for a certain attribute,
    and map the value of that attribute directly to the `GrantedAuthority` object
    for the user. Let''s assume that there is an attribute entitled role that will
    be returned with the assertion. We''ll simply configure a new `authenticationUserDetailsService`
    bean (be sure to replace the previously defined `authenticationUserDetailsService`
    bean) in the `CaseConfig.xml` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: You will also want to remove the `userDetailsService` bean from our `SecurityConfig.java`
    file, since it is no longer needed.
  prefs: []
  type: TYPE_NORMAL
- en: Alternative ticket authentication using SAML 1.1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**Security Assertion Markup Language** (**SAML**) is a standard, cross-platform
    protocol for identify verification using structured XML assertions. SAML is supported
    by a wide variety of products, including CAS (in fact, we will look at support
    for SAML within Spring Security itself in a later chapter).'
  prefs: []
  type: TYPE_NORMAL
- en: 'While the standard CAS protocol can be extended to return attributes, the SAML
    security assertion XML dialect solves some of the issues with attribute passing,
    using the CAS response protocol that we previously described. Happily, switching
    between CAS ticket validation and SAML ticket validation is as simple as changing
    the `TicketValidator` implementation configured in `CasSecurity.java`. Modify
    `ticketValidator`, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: You will notice that there is no longer a reference to the PGT URL. This is
    because the `Saml11TicketValidator` object does not support PGT. While both could
    exist, we opt to remove any references to the proxy ticket authentication, since
    we will no longer be using proxy ticket authentication. If you do not want to
    remove it from this exercise, don't worry; it won't prevent our application from
    running so long as your `ticketValidator` bean ID looks similar to the previous
    code snippet.
  prefs: []
  type: TYPE_NORMAL
- en: In general, it's recommended that SAML ticket validation be used over CAS 2.0
    ticket validation, as it adds more non-repudiation features, including `timestamp`
    validation, and solves the attribute problem in a standard way.
  prefs: []
  type: TYPE_NORMAL
- en: Restart the CAS server and JBCP calendar application. You can then visit `https://localhost:8443`
    and see that our calendar application can obtain `UserDetails` from the CAS response.
  prefs: []
  type: TYPE_NORMAL
- en: Your code should now look like `chapter10.06-calendar` and `chapter10.06-cas-server`.
  prefs: []
  type: TYPE_NORMAL
- en: How is attribute retrieval useful?
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Remember that CAS provides a layer of abstraction for our application, removing
    the ability for our application to directly access the user repository, and instead
    forcing all such access to be performed through CAS as a proxy.
  prefs: []
  type: TYPE_NORMAL
- en: This is extremely powerful! It means that our application no longer cares what
    kind of repository the users are stored in, nor does it have to worry about the
    details of how to access them-this simply confirms that authentication with CAS
    is sufficient to prove that a user should be able to access our application. For
    system administrators, this means that should an LDAP server be renamed, moved,
    or otherwise adjusted, they only need to reconfigure it in a single location-CAS.
    Centralizing access through CAS allows for a high level of flexibility and adaptability
    in the overall security architecture of the organization.
  prefs: []
  type: TYPE_NORMAL
- en: This story to the usefulness of attribute retrieval from CAS; now all applications
    authenticated through CAS have the same view of a user and can consistently display
    information across any CAS-enabled environment.
  prefs: []
  type: TYPE_NORMAL
- en: Be aware that, once authenticated, Spring Security CAS does not require the
    CAS server, unless the user is required to reauthenticate. This means that attributes
    and other user information stored locally in the application in the user's `Authentication`
    object may become stale over time, and possibly out of sync with the source CAS
    server. Take care to set session timeouts appropriately to avoid this potential
    issue!
  prefs: []
  type: TYPE_NORMAL
- en: Additional CAS capabilities
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'CAS offers additional advanced configuration capabilities outside of those
    that are exposed through the Spring Security CAS wrappers. Some of these include
    the following capabilities:'
  prefs: []
  type: TYPE_NORMAL
- en: Providing transparent single sign-on for users who are accessing multiple CAS-secured
    applications within a configurable time window on the CAS server. Applications
    can force users to authenticate to CAS by setting the `renew` property to `true`
    on `TicketValidator`; you may want to conditionally set this property in custom
    code in the event where the user is attempting to access a highly secured area
    of the application.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The RESTful API for obtaining service tickets.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: JA-SIG's CAS server can also act as an OAuth2 server. If you think about it,
    this makes sense, since CAS is very similar to OAuth2.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Providing OAuth support for the CAS server so that it can obtain access tokens
    to a delegate OAuth provider (that is, Google), or so that the CAS server can
    be the OAuth server itself.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We'd encourage you to explore the full capabilities of the CAS client and server
    as well as ask questions to the helpful folks in the JA-SIG community forums!
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we learned about the CAS single sign-on portal and how it can
    be integrated with Spring Security, and we also covered the CAS architecture and
    communication paths between actors in a CAS-enabled environment. We also saw the
    benefits of CAS-enabled applications for application developers and system administrators.
    We also learned about configuring JBCP calendar to interact with a basic CAS installation.
    We also covered the use of CAS's single logout support.
  prefs: []
  type: TYPE_NORMAL
- en: We also saw how proxy ticket authentication works and how to leverage it to
    authenticate stateless services.
  prefs: []
  type: TYPE_NORMAL
- en: We also covered tasks of updating CAS to interact with LDAP, and sharing LDAP
    data with our CAS-enabled application. We even learned about implementing attribute
    exchange with the industry standard SAML protocol.
  prefs: []
  type: TYPE_NORMAL
- en: We hope this chapter was an interesting introduction to the world of single
    sign-on. There are many other single sign-on systems in the marketplace, mostly
    commercial, but CAS is definitely one of the leaders of the open source SSO world,
    and an excellent platform to build out SSO capability in any organization.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we'll learn more about Spring Security authorization.
  prefs: []
  type: TYPE_NORMAL
