- en: Fine-Grained Access Control
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we will first examine two ways to implement fine-grained authorization-authorization
    that may affect portions of a page of the application. Next, we will look at Spring
    Security's approach to securing the business tier through method annotation and
    the use of interface-based proxies to accomplish AOP. Then, we will review an
    interesting capability of annotation-based security that allows for role-based
    filtering on collections of data. Last, we will look at how class-based proxies
    differ from interface-based proxies.
  prefs: []
  type: TYPE_NORMAL
- en: 'During the course of this chapter, we''ll cover the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Configuring and experimenting with different methods of performing in-page authorization
    checks on content, given the security context of a user request
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Performing configuration and code annotation to make caller preauthorization
    a key part of our application's business-tier security
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Several alternative approaches to implement method-level security, and reviewing
    the pros and cons of each type
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Implementing data-based filters on collections and arrays using method-level
    annotations
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Implementing method-level security on our Spring MVC controllers to avoid configuring
    `antMatcher()` methods and `<intercept-url>` elements
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Gradle dependencies
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'There are a number of optional dependencies that may be required, depending
    on what features you decide to use. Many of these dependencies are commented as
    Spring Boot includes them already in the starter parent. You will find that our
    `build.gradle` file already includes all of the following dependencies:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: Integrating Spring Expression Language (SpEL)
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Spring Security leverages **Spring Expression Language** (**SpEL**) integration
    in order to easily articulate various authorization requirements. If you recall,
    we have already looked at the use of SpEL in [Chapter 2](02.html), *Getting Started
    with Spring Security*, when we defined our `antMatcher()` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'Spring Security provides an `o.s.s.access.expression.SecurityExpressionRoot`
    object that provides the methods and objects available for use, in order to make
    an access control decision. For example, one of the methods available to use is
    `hasRole` method, which accepts a string. This corresponds to the value of the
    access attribute (in the preceding code snippet). In fact, there are a number
    of other expressions available, as shown in the following table:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Expression** | **Description** |'
  prefs: []
  type: TYPE_TB
- en: '| `hasRole(String role)``hasAuthority(String role)` | Returns `true` if the
    current user has the specified authority. |'
  prefs: []
  type: TYPE_TB
- en: '| `hasAnyRole(String... role)``hasAnyAuthority(String... authority)` | Returns
    `true` if the current user has any of the specified authorities. |'
  prefs: []
  type: TYPE_TB
- en: '| `principal` | Allows access to the current `Authentication` object''s principal
    attribute. As discussed in [Chapter 3](03.html), *Custom Authentication*, this
    will often be an instance of `UserDetails`. |'
  prefs: []
  type: TYPE_TB
- en: '| `authentication` | Obtains the current `Authentication` object from the `SecurityContext`
    interface returned by the `getContext()` method of the `SecurityContextHolder`
    class. |'
  prefs: []
  type: TYPE_TB
- en: '| `permitAll` | Always returns `true`. |'
  prefs: []
  type: TYPE_TB
- en: '| `denyAll` | Always returns `false`. |'
  prefs: []
  type: TYPE_TB
- en: '| `isAnonymous()` | Returns true if the current principal is anonymous (is
    not authenticated). |'
  prefs: []
  type: TYPE_TB
- en: '| `isRememberMe()` | Returns `true` if the current principal was authenticated
    using the remember-me feature. |'
  prefs: []
  type: TYPE_TB
- en: '| `isAuthenticated()` | Returns `true` if the user is not an anonymous user
    (that is, they are authenticated). |'
  prefs: []
  type: TYPE_TB
- en: '| `isFullyAuthenticated()` | Returns `true` if the user is authenticated through
    a means other than remember me. |'
  prefs: []
  type: TYPE_TB
- en: '| `hasPermission(Object target, Object permission)` | Returns `true` if the
    user has permission to access the specified object for the given permission. |'
  prefs: []
  type: TYPE_TB
- en: '| `hasPermission( String targetId, String targetType, Object permission)` |
    Returns `true` if the user has permission to access the specified identifier for
    a given type and permission. |'
  prefs: []
  type: TYPE_TB
- en: 'We have provided some examples of using these SpEL expressions in the following
    code snippet. Keep in mind that we will go into more detail throughout this and
    the next chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: The WebSecurityExpressionRoot class
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The `o.s.s.web.access.expression.WebSecurityExpressionRoot` class makes a few
    additional properties available to us. These properties, along with the standard
    properties already mentioned, are made available in the access attribute of the
    `antMatchers()` method and in the JSP/Thymeleaf `access` attribute of the `<sec:authorize>`
    tag, as we will discuss shortly:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Expression** | **Description** |'
  prefs: []
  type: TYPE_TB
- en: '| `request` | The current `HttpServletRequest` method. |'
  prefs: []
  type: TYPE_TB
- en: '| `hasIpAddress(String... ipAddress)` | Returns `true` if the current IP address
    matches the `ipAddress` value. This can be an exact IP address or the IP address/network
    mask. |'
  prefs: []
  type: TYPE_TB
- en: Using the request attribute
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The `request` attribute is fairly self-explanatory, but we have provided a
    few examples in the following code. Remember, any of these examples could be placed
    in the `antMatchers()` method''s access attribute or the `<sec:authorize>` element''s
    access attribute:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: Using the hasIpAddress method
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The `hasIpAddress` method is not quite as clear-cut as the `request` attribute.
    The `hasIpAddress` will easily match an exact IP address; for example, the following
    code would allow access if the current user''s IP address was `192.168.1.93`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'However, this is not all that useful. Instead, we can define the following
    code, which would also match our IP address and any other IP address in our subnet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'The question is: how is this calculated? The key is to understand how to calculate
    the network address and its mask. To learn how to do this, we can take a look
    at a concrete example. We launch `ifconfig` from our Linux Terminal to view our
    network information (Windows users can use enter `ipconfig /all` into the Command
    Prompt):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'Take a look at the following diagram:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/e2c7a7d2-5944-4bce-a054-d54ad9df8a0b.png)'
  prefs: []
  type: TYPE_IMG
- en: 'We can see that the first three octets of our mask are **255**. This means
    that the first three octets of our **IP Address** belong to the network address.
    In our calculation, this means that the remaining octets are **0**:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/13bb5b29-556c-4a5c-8662-8f5857a14289.png)'
  prefs: []
  type: TYPE_IMG
- en: We can then calculate the mask by first transforming each octet into a binary
    number, and then count how many ones there are. In our instance, we get `24`.
  prefs: []
  type: TYPE_NORMAL
- en: This means our IP address will match `192.168.1.0/24`. A good site for additional
    information on netmasks is Cisco's documentation, available at [http://www.cisco.com/c/en/us/support/docs/ip/routing-information-protocol-rip/13788-3.html](http://www.cisco.com/c/en/us/support/docs/ip/routing-information-protocol-rip/13788-3.html).
  prefs: []
  type: TYPE_NORMAL
- en: The MethodSecurityExpressionRoot class
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Method SpEL expressions also provide a few additional properties that can be
    used through the `o.s.s.access.expression.method.MethodSecurityExpressionRoot`
    class:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Expression** | **Description** |'
  prefs: []
  type: TYPE_TB
- en: '| `target` | Refers to `this` or the current object being secured. |'
  prefs: []
  type: TYPE_TB
- en: '| `returnObject` | Refers to the object returned by the annotated method. |'
  prefs: []
  type: TYPE_TB
- en: '| `filterObject` | Can be used on a collection or array in conjunction with
    `@PreFilter` or `@PostFilter`, to only include the elements that match the expression.
    The `filterObject` object represents the loop variable of the collection or array.
    |'
  prefs: []
  type: TYPE_TB
- en: '| `#<methodArg>` | Any argument to a method can be referenced by prefixing
    the argument name with `#`. For example, a method argument named `id` can be referred
    to using `#id`. |'
  prefs: []
  type: TYPE_TB
- en: If the description of these expressions appears a bit brief, don't worry; we'll
    work through a number of examples later in this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: We hope that you have a decent grasp of the power of Spring Security's SpEL
    support. To learn more about SpEL, refer to the Spring reference documentation
    at [https://docs.spring.io/spring/docs/current/spring-framework-reference/html/expressions.html](https://docs.spring.io/spring/docs/current/spring-framework-reference/html/expressions.html).
  prefs: []
  type: TYPE_NORMAL
- en: Page-level authorization
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Page-level authorization refers to the availability of application features
    based on the context of a particular user's request. Unlike coarse-grained authorization
    that we explored in [Chapter 2](02.html), *Getting Started with Spring Security*,
    fine-grained authorization typically refers to the selective availability of the
    portions of a page, rather than restricting access to a page entirely. Most real-world
    applications will spend a considerable amount of time on the details of fine-grained
    authorization planning.
  prefs: []
  type: TYPE_NORMAL
- en: 'Spring Security provides us with the following three methods of selective display
    functionality:'
  prefs: []
  type: TYPE_NORMAL
- en: Spring Security JSP tag libraries allow conditional access declarations to be
    placed within a page declaration itself, using the standard JSP tag library syntax.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Thymeleaf Spring Security tag libraries allow conditional access declarations
    to be placed within a page declaration itself, using the standard Thymeleaf tag
    library syntax.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Checking user authorization in an MVC application's controller layer allows
    the controller to make an access decision and bind the results of the decision
    to the model data provided to the view. This approach relies on standard JSTL
    conditional page rendering and data binding, and is slightly more complicated
    than Spring Security tag libraries; however, it is more in line with the standard
    web application MVC logical design.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Any of these approaches are perfectly valid when developing fine-grained authorization
    models for a web application. Let's explore how each approach is implemented through
    a JBCP calendar use case.
  prefs: []
  type: TYPE_NORMAL
- en: Conditional rendering with the Thymeleaf Spring Security tag library
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The most common functionality used in the Thymeleaf Spring Security tag library
    is to conditionally render portions of the page based on authorization rules.
    This is done with the `< sec:authorize*>` tag that functions similarly to the
    `<if>` tag in the core JSTL library, in that the tag's body will render depending
    on the conditions provided in the tag attributes. We have already seen a very
    brief demonstration of how the Spring Security tag library can be used to restrict
    the viewing of content if the user is not logged in.
  prefs: []
  type: TYPE_NORMAL
- en: Conditional rendering based on URL access rules
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The Spring Security tag library provides functionality to render content based
    on the existing URL authorization rules that are already defined in the security
    configuration file. This is done via the use of the `authorizeRequests()` method
    and the `antMatchers()` method.
  prefs: []
  type: TYPE_NORMAL
- en: If there are multiple HTTP elements, the `authorizeRequests()` method uses the
    currently matched HTTP element's rules.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, we could ensure that the All Events link is displayed only when
    appropriate, that is, for users who are administrators-recall that the access
    rules we''ve previously defined are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'Update the `header.html` file to utilize this information and conditionally
    render the link to the All Events page:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'This will ensure that the content of the tag is not displayed unless the user
    has sufficient privileges to access the stated URL. It is possible to further
    qualify the authorization check using the HTTP method, by including the method
    attribute before the URL, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: Using the `authorize-url` attribute to define authorization checks on blocks
    of code is convenient because it abstracts the knowledge of the actual authorization
    checks from your pages and keeps it in your security configuration file.
  prefs: []
  type: TYPE_NORMAL
- en: Be aware that the HTTP method should match the case specified in your security
    `antMatchers()` method, otherwise they may not match as you expect. Also, note
    that the URL should always be relative to the web application context root (as
    your URL access rules are).
  prefs: []
  type: TYPE_NORMAL
- en: For many purposes, the use of the `<sec>` tag's `authorize-url` attribute will
    suffice to correctly display link- or action-related content only when the user
    is allowed to see it. Remember that the tag need not only surround a link; it
    could even surround a whole form if the user doesn't have permission to submit
    it.
  prefs: []
  type: TYPE_NORMAL
- en: Conditional rendering using SpEL
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'An additional, more flexible method of controlling the display of JSP content
    is available when the `<sec>` tag is used in conjunction with a SpEL expression.
    Let''s review what we learned in [Chapter 2](02.html), *Getting Started with Spring
    Security*. We could hide the My Events link from any unauthenticated users by
    changing our `header.html` file, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: The SpEL evaluation is performed by the same code behind the scenes as the expressions
    utilized in the `antMatchers()` method access declaration rules (assuming the
    expressions have been configured). Hence, the same set of built-in functions and
    properties are accessible from the expressions built using the `<sec>` tag.
  prefs: []
  type: TYPE_NORMAL
- en: Both of these methods of utilizing the `<sec>` tag provide powerful, fine-grained
    control over the display of page content based on security authorization rules.
  prefs: []
  type: TYPE_NORMAL
- en: Go ahead and start up the JBCP calendar application. Visit `https://localhost:8443`
    and log in with the user `user1@example.com` and the password `user1`. You will
    observe that the My Events link is displayed, but the All Events link is hidden.
    Log out and log in as the user `admin1@example.com` with the password
  prefs: []
  type: TYPE_NORMAL
- en: '`admin1`. Now both links are visible.'
  prefs: []
  type: TYPE_NORMAL
- en: You should start with the code from `chapter11.01-calendar`.
  prefs: []
  type: TYPE_NORMAL
- en: Using controller logic to conditionally render content
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section, we will demonstrate how we can use Java-based code to determine
    if we should render some content. We can choose to only show the Create Event
    link on the Welcome page to users who have a username that contains `user`. This
    will hide the Create Event link on the Welcome page from users who are not logged
    in as administrators.
  prefs: []
  type: TYPE_NORMAL
- en: 'The welcome controller from the sample code for this chapter has been updated
    to populate the model with an attribute named `showCreateLink`, derived from the
    method name, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: You may notice that Spring MVC can automatically obtain the `Authentication`
    object for us. This is because Spring Security maps our current `Authentication`
    object to the `HttpServletRequest.getPrincipal()` method. Since Spring MVC will
    automatically resolve any object of the `java.security.Principal` type to the
    value of `HttpServletRequest.getPrincipal()`, specifying `Authentication` as an
    argument to our controller is an easy way to access the current `Authentication`
    object. We could also decouple the code from Spring Security by specifying an
    argument of the `Principal` type instead. However, we chose `Authentication` in
    this scenario to help demonstrate how everything connects.
  prefs: []
  type: TYPE_NORMAL
- en: If we were working in another framework that did not know how to do this, we
    could obtain the `Authentication` object using the `SecurityContextHolder` class,
    as we did in [Chapter 3](03.html), *Custom Authentication*. Also note that if
    we were not using Spring MVC, we could just set the `HttpServletRequest` attribute
    directly rather than populating it on the model. The attribute that we populated
    on the request would then be available to our JSP, just as it is when using a
    `ModelAndView` object with Spring MVC.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, we will need to use the `HttpServletRequest` attribute in our `index.html`
    file to determine if we should display the Create Event link. Update `index.html`,
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: Now, start the application, log in using `admin1@example.com` as the username
    and `admin1` as the password, and visit the All Events page. You should no longer
    see the Create Events link in the main navigation (although it will still be present
    on the page).
  prefs: []
  type: TYPE_NORMAL
- en: 'Your code should look like this: `chapter11.02-calendar`.'
  prefs: []
  type: TYPE_NORMAL
- en: The WebInvocationPrivilegeEvaluator class
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'There may be times when an application will not be written using JSPs and will
    need to be able to determine access based upon a URL, as we did with `<... sec:authorize-url="/events/">`.
    This can be done by using the `o.s.s.web.access.WebInvocationPrivilegeEvaluator`
    interface, which is the same interface that backs the JSP tag library. In the
    following code snippet, we demonstrate its use by populating our model with an
    attribute named `showAdminLink`. We are able to obtain `WebInvocationPrivilegeEvaluator`
    using the `@Autowired` annotation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'If the framework you are using is not being managed by Spring, `@Autowire`
    will not be able to provide you with `WebInvocationPrivilegeEvaluator`. Instead,
    you can use Spring''s `org.springframework.web.context.WebApplicationContextUtils`
    interface to obtain an instance of `WebInvocationPrivilegeEvaluator`, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'To try it out, go ahead and update `index.html` to use the `showAdminLink`
    request attribute, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: Restart the application and view the Welcome page before you have logged in.
    The H2 link should not be visible. Log in as `admin1@example.com`/`admin1`, and
    you should see it.
  prefs: []
  type: TYPE_NORMAL
- en: Your code should look like `chapter11.03-calendar`.
  prefs: []
  type: TYPE_NORMAL
- en: What is the best way to configure in-page authorization?
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Major advances in the Thymeleaf Spring Security `<sec>` tag in Spring Security
    4 removed many of the concerns about the use of this tag in previous versions
    of the library. In many cases, the use of the `authorize-url` attribute of the
    tag can appropriately isolate the code from changes in authorization rules. You
    should use the `authorize-url` attribute of the tag in the following scenarios:'
  prefs: []
  type: TYPE_NORMAL
- en: The tag is preventing display functionality that can be clearly identified by
    a single URL
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The contents of the tag can be unambiguously isolated to a single URL
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Unfortunately, in a typical application, the likelihood that you will be able
    to use the `authorize-url` attribute of the tag frequently is somewhat low. The
    reality is that applications are usually much more complex than this, and require
    more involved logic when deciding to render portions of a page.
  prefs: []
  type: TYPE_NORMAL
- en: 'It''s tempting to use the Thymeleaf Spring Security tag library to declare
    bits of rendered pages as off-limits based on security criteria in other methods.
    However, there are a number of reasons why (in many cases) this isn''t a great
    idea, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Complex conditions beyond role membership are not supported by the tag library.
    For example, if our application incorporated customized attributes on the `UserDetails`
    implementation, IP filters, geolocation, and so on, none of these would be supported
    by the standard `<sec>` tag.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: These could, however, conceivably be supported by the custom tags or using SpEL
    expressions. Even in this case, the page is more likely to be directly tied to
    business logic rather than what is typically encouraged.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `<sec>` tag must be referenced on every page that it's used in. This leads
    to potential inconsistencies between the rulesets that are intended to be common,
    but may be spread across different physical pages. A good object-oriented system
    design would suggest that conditional rule evaluations be located in only one
    place, and logically referred to from where they should be applied.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It is possible (and we illustrate this using our common header page include)
    to encapsulate and reuse portions of pages to reduce the occurrence of this type
    of problem, but it is virtually impossible to eliminate in a complex application.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: There is no way to validate the correctness of rules stated at compile time.
    Whereas compile-time constants can be used in typical Java-based, object-oriented
    systems, the tag library requires (in typical use) hardcoded role names where
    a simple typo might go undetected for some time.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: To be fair, such typos could be caught easily by comprehensive functional tests
    on the running application, but they are far easier to test using a standard Java
    component unit testing techniques.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We can see that, although the **template-based** approach for conditional content
    rendering is convenient, there are some significant downsides.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: All of these issues can be solved by the use of code in controllers that can
    be used to push data into the application view model. Additionally, performing
    advanced authorization determinations in code allows for the benefits of reuse,
    compile-time checks, and proper logical separation of the model, view, and controller.
  prefs: []
  type: TYPE_NORMAL
- en: Method-level security
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Our primary focus up to this point in the book has been on securing the web-facing
    portion of the JBCP calendar application; however, in real-world planning of secured
    systems, equal attention should be paid to securing the service methods that allow
    users access to the most critical part of any system-its data.
  prefs: []
  type: TYPE_NORMAL
- en: Why we secure in layers?
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Let's take a minute to see why it is important to secure our methods, even though
    we have already secured our URLs. Start the JBCP calendar application up. Log
    in using `user1@example.com` as the username and `user1` as the password, and
    visit the All Events page. You will see the custom Access Denied page. Now, add
    `.json` to the end of the URL in the browser so that the URL is now `https://localhost:8443/events/.json`.
    You will now see a JSON response with the same data as the HTML All Events page.
    This data should only be visible to an administrator, but we have bypassed it
    by finding a URL that was not configured properly.
  prefs: []
  type: TYPE_NORMAL
- en: We can also view the details of an event that we do not own and are not invited
    to. Change `.json` with `102` so that the URL is now `https://localhost:8443/events/102`.
    You will now see a Lunch event that is not listed on your My Events page. This
    should not be visible to us because we are not an administrator and this is not
    our event.
  prefs: []
  type: TYPE_NORMAL
- en: As you can see, our URL rules are not quite strong enough to entirely secure
    our application. These exploits do not even need to take advantage of more complex
    problems, such as differences in how containers handle URL normalization. In short,
    there are often ways to bypass URL-based security. Let's see how adding a security
    layer to our business tier can help with our new security vulnerability.
  prefs: []
  type: TYPE_NORMAL
- en: Securing the business tier
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Spring Security has the ability to add a layer of authorization (or authorization-based
    data pruning) to the invocation of any Spring-managed bean in your application.
    While many developers focus on web-tier security, business-tier security is arguably
    just as important, as a malicious user may be able to penetrate the security of
    your web tier or access services exposed through a non-UI frontend, such as a
    web service.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s examine the following logical diagram to see why we''re interested in
    applying a secondary layer of security:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/357835b8-4d31-4cce-8b41-c5d7c70c0909.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Spring Security has the following two main techniques for securing methods:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Preauthorization**: This technique ensures that certain constraints are satisfied
    prior to the execution of a method that is being allowed, for example, if a user
    has a particular `GrantedAuthority`, such as `ROLE_ADMIN`. Failure to satisfy
    the declared constraints means that the method call will fail.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Postauthorization**: This technique ensures that the calling principal still
    satisfies declared constraints after the method returns. This is rarely used but
    can provide an extra layer of security around some complex, interconnected business
    tier methods.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The preauthorization and postauthorization techniques provide formalized support
    for what are generally called preconditions and postconditions in a classic, object-oriented
    design. Preconditions and postconditions allow a developer to declare through
    runtime checks that certain constraints around a method's execution must always
    hold true. In the case of security preauthorization and postauthorization, the
    business tier developer makes a conscious decision about the security profile
    of particular methods by encoding expected runtime conditions as part of an interface
    or class API declaration. As you may imagine, this requires a great deal of forethought
    to avoid unintended consequences!
  prefs: []
  type: TYPE_NORMAL
- en: Adding the @PreAuthorize method annotation
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Our first design decision will be to augment method security at the business
    tier by ensuring that a user must be logged in as an `ADMIN` user before he/she
    is allowed to access the `getEvents()` method. This is done with a simple annotation
    added to the method in the service interface definition, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: This is all that is required to ensure that anyone invoking our `getEvents()`
    method is an administrator. Spring Security will use a runtime **Aspect Oriented
    Programming** (**AOP**) pointcut to execute `BeforeAdvice` on the method, and
    throw `o.s.s.access.AccessDeniedException` if the security constraints aren't
    met.
  prefs: []
  type: TYPE_NORMAL
- en: Instructing Spring Security to use method annotations
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We''ll also need to make a one-time change to `SecurityConfig.java`, where
    we''ve got the rest of our Spring Security configuration. Simply add the following
    annotation to the class declaration:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: Validating method security
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Don't believe it was that easy? Log in with `user1@example.com` as the username
    and `user1` as the password, and try accessing `https://localhost:8443/events/.json`.
    You should see the Access Denied page now.
  prefs: []
  type: TYPE_NORMAL
- en: Your code should look like `chapter11.04-calendar`.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you look at the Tomcat console, you''ll see a very long stack trace, starting
    with the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: Based on the Access Denied page, and the stack trace clearly pointing to the
    `getEvents` method invocation, we can see that the user was appropriately denied
    access to the business method because it lacked the `GrantedAuthority` of `ROLE_ADMIN`.
    If you run the same with the username `admin1@example.com` and the password `admin1`,
    you will discover that access will be granted.
  prefs: []
  type: TYPE_NORMAL
- en: Isn't it amazing that with a simple declaration in our interface, we're able
    to ensure that the method in question is secure? But how does AOP work?
  prefs: []
  type: TYPE_NORMAL
- en: Interface-based proxies
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In the given example from the previous section, Spring Security used an interface-based
    proxy to secure our `getEvents` method. Let''s take a look at the simplified pseudocode
    of what happened to understand how this works:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: You can see that Spring creates the original `CalendarService` just as it normally
    does. However, it instructs our code to use another implementation of `CalendarService`
    that performs a security check before returning the result of the original method.
    The secure implementation can be created with no prior knowledge of our interface
    because Spring uses Java's `java.lang.reflect.Proxy` APIs to dynamically create
    new implementations of the interface. Note that the object returned is no longer
    an instance of `DefaultCalendarService`, since it is a new implementation of `CalendarService`,
    that is, it is an anonymous implementation of `CalendarService`. This means that
    we must program against an interface in order to use the secure implementation,
    otherwise, a `ClassCastException` exception will occur. To learn more about Spring
    AOP, refer to the Spring reference documentation at [http://static.springsource.org/spring/docs/current/spring-framework-reference/html/aop.html#aop-introduction-proxies](http://static.springsource.org/spring/docs/current/spring-framework-reference/html/aop.html#aop-introduction-proxies).
  prefs: []
  type: TYPE_NORMAL
- en: In addition to the `@PreAuthorize` annotation, there are several other ways
    of declaring security preauthorization requirements on methods. We can examine
    these different ways of securing methods and then evaluate their pros and cons
    in different circumstances.
  prefs: []
  type: TYPE_NORMAL
- en: JSR-250 compliant standardized rules
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**JSR-250 Common Annotations** for the Java platform defines a series of annotations,
    some that are security-related, which are intended to be portable across JSR-250
    compliant runtime environments. The Spring Framework became compliant with JSR-250
    as part of the Spring 2.x release, including the Spring Security framework.'
  prefs: []
  type: TYPE_NORMAL
- en: While JSR-250 annotations are not as expressive as Spring native annotations,
    they have the benefit that the declarations they provide are compatible across
    implementing Java EE application servers such as Glassfish or service-oriented
    runtime frameworks such as **Apache Tuscany**. Depending on your application's
    needs and requirements for portability, you may decide that the trade-off of reduced
    specificity is worth the portability of the code.
  prefs: []
  type: TYPE_NORMAL
- en: 'To implement the rule we specified in the first example, we make a few changes
    by performing the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'First, we need to update our `SecurityConfig` file to use the JSR-250 annotations:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'Lastly, the `@PreAuthorize` annotation needs to change to the `@RolesAllowed`
    annotation. As we might anticipate, the `@RolesAllowed` annotation does not support
    SpEL expressions, so we edit `CalendarService` as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: Restart the application, log in as `user1@example.com`/`user1`, and try to access
    `http://localhost:8080/events/.json`. You should see the Access Denied page again.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Your code should look like this: `chapter11.05-calendar`.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Note that it''s also possible to provide a list of allowed `GrantedAuthority`
    names using the standard Java 5 String array annotation syntax:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: There are also two additional annotations specified by JSR-250, namely `@PermitAll`
    and `@DenyAll`, which function as you might expect, permitting and denying all
    requests to the method in question.
  prefs: []
  type: TYPE_NORMAL
- en: '**Annotations at the class level**'
  prefs: []
  type: TYPE_NORMAL
- en: Be aware that method-level security annotations can be applied at the class
    level as well! Method-level annotations, if supplied, will always override annotations
    specified at the class level. This can be helpful if your business needs to dictate
    the specification of security policies for an entire class. Take care to use this
    functionality in conjunction with good comments and coding standards, so that
    developers are very clear about the security characteristics of the class and
    its methods.
  prefs: []
  type: TYPE_NORMAL
- en: Method security using Spring's @Secured annotation
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Spring itself provides a simpler annotation style that is similar to the JSR-250
    `@RolesAllowed` annotation. The `@Secured` annotation is functionally and syntactically
    the same as `@RolesAllowed`. The only notable differences are that it does not
    require the external dependency, cannot be processed by other frameworks, and
    the processing of these annotations must be explicitly enabled with another attribute
    on the `@EnableGlobalMethodSecurity` annotation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: As `@Secured` functions in the same way as the JSR standard `@RolesAllowed`
    annotation, there's no real compelling reason to use it in new code, but you may
    run across it in older Spring code.
  prefs: []
  type: TYPE_NORMAL
- en: Method security rules incorporating method parameters
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Logically, writing rules that refer to method parameters in their constraints
    seem sensible for certain types of operations. For example, it might make sense
    for us to restrict the `findForUser(int userId)` method to meet the following
    constraints:'
  prefs: []
  type: TYPE_NORMAL
- en: The `userId` argument must be equal to the current user's ID
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The user must be an administrator (in this case, it is valid for the user to
    see any event)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: While it's easy to see how we could alter the rule to restrict the method invocation
    only to administrators, it's not clear how we would determine if the user is attempting
    to change their own password.
  prefs: []
  type: TYPE_NORMAL
- en: 'Fortunately, SpEL binding, used by the Spring Security method annotations,
    supports more sophisticated expressions, including expressions that incorporate
    method parameters. You will also want to ensure that you have enabled pre- and
    post-annotations in the `SecurityConfig` file, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: You can see here that we've augmented the SpEL directive we used in the first
    exercise with a check against the ID of the principal and against the `userId`
    method parameter (`#userId`, the method parameter name, is prefixed with a `#`
    symbol). The fact that this powerful feature of method parameter binding is available
    should get your creative juices flowing and allow you to secure method invocations
    with a very precise set of logical rules.
  prefs: []
  type: TYPE_NORMAL
- en: Our principal is currently an instance of `CalendarUser` due to the custom authentication
    setup from [Chapter 3](03.html), *Custom Authentication*. This means that the
    principal has all of the properties that our `CalendarUser` application has on
    it. If we had not done this customization, only the properties of the `UserDetails`
    object would be available.
  prefs: []
  type: TYPE_NORMAL
- en: 'SpEL variables are referenced with the hash (`#`) prefix. One important note
    is that in order for method argument names to be available at runtime, debugging
    symbol table information must be retained after compilation. Common methods to
    retain the debugging symbol table information are listed as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: If you are using the `javac` compiler, you will need to include the `-g` flag
    when building your classes
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: When using the `<javac>` task in Ant, add the attribute `debug="true"`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In Gradle, ensure to add `--debug` when running the main method, or the `bootRun`
    task
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In Maven, ensure the `maven.compiler.debug=true` property (the default is `true`)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Consult your compiler, build tool, or IDE documentation for assistance on configuring
    this same setting in your environment.
  prefs: []
  type: TYPE_NORMAL
- en: Start up your application and try logging in with `user1@example.com` as the
    username and `user1` as the password. On the Welcome page, request the My Events
    (`email=admin1@example.com`) link to see an Access Denied page. Try again with
    My Events (`email=user1@example.com`) to see it work. Note that the displayed
    user on the My Events page matches the currently logged-in user. Now, try the
    same steps and log in as `admin1@example.com`/`admin1`. You will be able to see
    both pages since you are logged in as a user with the `ROLE_ADMIN` permission.
  prefs: []
  type: TYPE_NORMAL
- en: Your code should look like `chapter11.06-calendar`.
  prefs: []
  type: TYPE_NORMAL
- en: Method security rules incorporating returned values
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Just as we were able to leverage the parameters to the method, we can also
    leverage the returned value of the method call. Let''s update the `getEvent` method
    to meet the following constraints on the returned value:'
  prefs: []
  type: TYPE_NORMAL
- en: The attendee's ID must be the current user's ID
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The owner'sID must be the current user's ID
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The user must be an administrator (in this case, it is valid for the user to
    see any event)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Add the following code to the `CalendarService` interface:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: Now, try logging in with the username `user1@example.com` and the password `user1`.
    Next, try accessing the Lunch event using the link on the Welcome page. You should
    now see the Access Denied page. If you log in using the username `user2@example.com`
    and the password `user2`, the event will display as expected since `user2@example.com`
    is the attendee at the Lunch event.
  prefs: []
  type: TYPE_NORMAL
- en: Your code should look like `chapter11.07-calendar`.
  prefs: []
  type: TYPE_NORMAL
- en: Securing method data using role-based filtering
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The two final Spring Security-dependent annotations are `@PreFilter` and `@PostFilter`,
    which are used to apply security-based filtering rules to collections or arrays
    (with `@PostFilter` only). This type of functionality is referred to as security
    trimming or security pruning and involves using the security credentials of `principal`
    at runtime to selectively remove members from a set of objects. As you might expect,
    this filtering is performed using SpEL expression notation within the annotation
    declaration.
  prefs: []
  type: TYPE_NORMAL
- en: 'We''ll work through an example with JBCP calendar, as we want to filter the
    `getEvents` method to only return the events that this user is allowed to see.
    In order to do this, we remove any existing security annotations and add the `@PostFilter`
    annotation to our `CalendarService` interface, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'Your code should look like this: `chapter11.08-calendar`.'
  prefs: []
  type: TYPE_NORMAL
- en: Remove the `antMatchers()` method, restricting access to `/events/URL` so that
    we can test our annotation. Start up the application and view the All Events page
    when logged in with the username `user1@example.com` and password `user1`. You
    will observe that only the events that are associated with our user are displayed.
  prefs: []
  type: TYPE_NORMAL
- en: With `filterObject` acting as the loop variable that refers to the current event,
    Spring Security will iterate over the `List<Event>` returned by our service and
    modify it to only contain the `Event` objects that match our SpEL expression.
  prefs: []
  type: TYPE_NORMAL
- en: In general, the `@PostFilter` method behaves in the following way. For brevity,
    we refer to the collection as the method return value, but be aware that `@PostFilter`
    works with either collection or array method return types.
  prefs: []
  type: TYPE_NORMAL
- en: The `filterObject` object is rebound to the SpEL context for each element in
    the collection. This means that if your method is returning a collection with
    100 elements, the SpEL expression will be evaluated for each.
  prefs: []
  type: TYPE_NORMAL
- en: The SpEL expression must return a Boolean value. If the expression evaluates
    to true, the object will remain in the collection, while if the expression evaluates
    to false, the object will be removed.
  prefs: []
  type: TYPE_NORMAL
- en: In most cases, you'll find that collection post filtering saves you from the
    complexity of writing boilerplate code that you would likely be writing anyway.
    Take care that you understand how `@PostFilter` works conceptually; unlike `@PreAuthorize`,
    `@PostFilter` specifies method behavior and not a precondition. Some object-oriented
    purists may argue that `@PostFilter` isn't appropriate for inclusion as a method
    annotation, and such filtering should instead be handled through code in a method
    implementation.
  prefs: []
  type: TYPE_NORMAL
- en: Safety of collection filtering
  prefs: []
  type: TYPE_NORMAL
- en: Be aware that the actual collection returned from your method will be modified!
    In some cases, this isn't desirable behavior, so you should ensure that your method
    returns a collection that can be safely modified. This is especially important
    if the returned collection is an ORM-bound one, as post-filter modifications could
    inadvertently be persisted to the ORM data store!
  prefs: []
  type: TYPE_NORMAL
- en: Spring Security also offers functionality to prefilter method parameters that
    are collections; let's try implementing that now.
  prefs: []
  type: TYPE_NORMAL
- en: Prefiltering collections with @PreFilter
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The `@PreFilter` annotation can be applied to a method to filter collection
    elements that are passed into a method based on the current security context.
    Functionally, once it has a reference to a collection, this annotation behaves
    exactly the same as the `@PostFilter` annotation, with a couple of exceptions,
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: The `@PreFilter` annotation supports only collection arguments and does not
    support array arguments.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `@PreFilter` annotation takes an additional, optional `filterTarget` attribute
    which is used to specifically identify the method parameter and filter it when
    the annotated method has more than one argument.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: As with `@PostFilter`, keep in mind that the original collection passed to the
    method is permanently modified. This may not be desirable behavior, so ensure
    that callers know that the collection's security may be trimmed after the method
    is invoked!
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Imagine if we had a `save` method that accepted a collection of event objects,
    and we wanted to only allow the saving of events that were owned by the currently
    logged in user. We could do this as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: Much like our `@PostFilter` method, this annotation causes Spring Security to
    iterate over each event with the loop variable `filterObject`. It then compares
    the current user's ID against the event owner's ID. If they match, the event is
    retained. If they do not match, the result is discarded.
  prefs: []
  type: TYPE_NORMAL
- en: Comparing method authorization types
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The following quick reference chart may assist you in selecting a type of method
    authorization check to use:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Method authorization type** | **Specified as** | **JSR standard** | **Allows
    SpEL expressions** |'
  prefs: []
  type: TYPE_TB
- en: '| `@PreAuthorize``@PostAuthorize` | Annotation | No | Yes |'
  prefs: []
  type: TYPE_TB
- en: '| `@RolesAllowed`, `@PermitAll`, `@DenyAll` | Annotation | Yes | No |'
  prefs: []
  type: TYPE_TB
- en: '| `@Secure` | Annotation | No | No |'
  prefs: []
  type: TYPE_TB
- en: '| `protect-pointcut` | XML | No | No |'
  prefs: []
  type: TYPE_TB
- en: Most Java 5 consumers of Spring Security will probably opt to use the JSR-250
    annotations for maximum compatibility and reuse their business classes (and relevant
    constraints) across an IT organization. Where needed, these basic declarations
    can be replaced with the annotations that tie the code to the Spring Security
    implementation itself.
  prefs: []
  type: TYPE_NORMAL
- en: If you are using Spring Security in an environment that doesn't support annotations
    (Java 1.4 or previous), unfortunately, your choices are somewhat limited to method
    security enforcement. Even in this situation, the use of AOP provides a reasonably
    rich environment in which we can develop basic security declarations.
  prefs: []
  type: TYPE_NORMAL
- en: Practical considerations for annotation-based security
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: One thing to consider is that when returning a collection of real-world applications,
    there is likely to be some sort of paging. This means that our `@PreFilter` and
    `@PostFilter` annotations cannot be used as the sole means of selecting which
    objects to return. Instead, we need to ensure that our queries only select the
    data that the user is allowed to access. This means that the security annotations
    become redundant checks. However, it is important to remember our lesson at the
    beginning of this chapter; we want to secure layers in case one layer is able
    to be bypassed.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we have covered most of the remaining areas in standard Spring
    Security implementations that deal with authorization. We've learned enough to
    take a thorough pass through the JBCP calendar application and verify that proper
    authorization checks are in place in all tiers of the application, to ensure that
    malicious users cannot manipulate or access data to which they do not have access.
  prefs: []
  type: TYPE_NORMAL
- en: We developed two techniques for micro-authorization, namely filtering out in-page
    content based on authorization or other security criteria using the Thymeleaf
    Spring Security tag library and Spring MVC controller data binding. We also explored
    several methods of securing business functions and data in the business tier of
    our application and supporting a rich, declarative security model that was tightly
    integrated with the code. We also learned how to secure our Spring MVC controllers
    and the differences between interface and class proxy objects
  prefs: []
  type: TYPE_NORMAL
- en: At this point, we've wrapped up coverage of much of the important Spring Security
    functionality that you're likely to encounter in most standard, secure web application
    development scenarios.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will discuss the ACL (domain object model) module of
    Spring Security. This will allow us to explicitly declare authorization, rather
    than relying on existing data.
  prefs: []
  type: TYPE_NORMAL
- en: Access Control Lists
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we will address the complex topic of **access control lists**
    (**ACL**), which can provide a rich model of domain object instance-level authorization.
    Spring Security ships with a robust, but complicated, access control list module
    that can serve the needs of small to medium-sized implementations reasonably well.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we''ll cover the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Understanding the conceptual model of ACL
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Reviewing the terminology and application of ACL concepts in the Spring Security
    ACL module
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Building and reviewing the database schema required to support Spring ACL
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Configuring JBCP calendar to use ACL secured business methods via annotations
    and Spring beans
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Performing advanced configuration, including customized ACL permissions, ACL-enabled
    JSP tag checks and method security, mutable ACLs, and smart caching
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Examining architectural considerations and planning scenarios for ACL deployment
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The conceptual module of ACL
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The final piece of the non-web tier security puzzle is security at the business
    object level, applied at or below the business tier. Security at this level is
    implemented using a technique known as ACL, or ACLs. Summing up the objective
    of ACLs in a single sentence-ACLs allow specification of a set of group permissions
    based on the unique combination of a group, business object, and logical operation.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, an ACL declaration for JBCP calendar might declare that a given
    user has to write access to his or her own event. This can be shown as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Username** | **Group** | **Object** | **Permissions** |'
  prefs: []
  type: TYPE_TB
- en: '| `mick` |  | `event_01` | `read`, `write` |'
  prefs: []
  type: TYPE_TB
- en: '|  | `ROLE_USER` | `event_123` | `read` |'
  prefs: []
  type: TYPE_TB
- en: '|  | `ANONYMOUS` | Any event | `none` |'
  prefs: []
  type: TYPE_TB
- en: You can see that this ACL is eminently readable by a human-`mick` has `read`
    and `write` access to his own event (`event_01`); other registered users can read
    the events of `mick`, but anonymous users cannot. This type of rule matrix is,
    in a nutshell, what ACL attempts to synthesize about a secured system and its
    business data into a combination of code, access checking, and metadata. Most
    true ACL-enabled systems have extremely complex ACL lists, and may conceivably
    have millions of entries across the entire system. Although this sounds frighteningly
    complex, proper up-front reasoning and implementation with a capable security
    library can make ACL management quite feasible.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you use a Microsoft Windows or Unix/Linux-based computer, you experience
    the magic of ACLs every single day. Most modern computer operating systems use
    ACL directives as part of their file storage systems, allowing permission granting
    based on a combination of a user or group, file or directory, and permission.
    In Microsoft Windows, you can view some of the ACL capabilities of a file by right-clicking
    on a file and examining its security properties (Properties | Security), as shown
    in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/83387a1a-85dd-4ca8-be30-b6a071debe15.png)'
  prefs: []
  type: TYPE_IMG
- en: You will be able to see that the combinations of inputs to the ACL are visible
    and intuitive as you navigate through the various groups or users and permissions.
  prefs: []
  type: TYPE_NORMAL
- en: Access control lists in Spring Security
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Spring Security supports ACL-driven authorization checks against access to individual
    domain objects by individual users of the secured system. Much as in the OS filesystem
    example, it is possible to use the Spring Security ACL components to build logical
    tree structures of both business objects and groups or principals. The intersection
    of permissions (inherited or explicit) on both the requestor and the requestee
    is used to determine allowed access.
  prefs: []
  type: TYPE_NORMAL
- en: It's quite common for users approaching the ACL capability of Spring Security
    to be overwhelmed by its complexity, combined with a relative dearth of documentation
    and examples. This is compounded by the fact that setting up the ACL infrastructure
    can be quite complicated, with many interdependencies and reliance on bean-based
    configuration mechanisms, which are quite unlike much of the rest of Spring Security
    (as you'll see in a moment when we set up the initial configuration).
  prefs: []
  type: TYPE_NORMAL
- en: The Spring Security ACL module was written to be a reasonable baseline, but
    users intending to build extensively on the functionality will likely run into
    a series of frustrating limitations and design choices, which have gone (for the
    most part) uncorrected as they were first introduced in the early days of Spring
    Security. Don't let these limitations discourage you! The ACL module is a powerful
    way to embed rich access controls in your application, and further scrutinize
    and secure user actions and data.
  prefs: []
  type: TYPE_NORMAL
- en: Before we dig into configuring Spring Security ACL support, we need to review
    some key terminology and concepts.
  prefs: []
  type: TYPE_NORMAL
- en: The main unit of secured actor identity in the Spring ACL system is the **Security
    Identity** (**SID**). The SID is a logical construct that can be used to abstract
    the identity of either an individual principal or a group (`GrantedAuthority`).
    The `SIDs` object defined by the ACL data model you construct are used as the
    basis for explicit and derived access control rules, when determining the allowed
    level of access for a particular principal.
  prefs: []
  type: TYPE_NORMAL
- en: If `SIDs` are used to define actors in the ACL system, the opposite half of
    the security equation is the definition of the secured objects themselves. The
    identification of individual secured objects is called (unsurprisingly) an object
    identity. The default Spring ACL implementation of an object identity requires
    ACL rules to be defined at the individual object instance level, which means,
    if desired, every object in the system can have an individual access rule.
  prefs: []
  type: TYPE_NORMAL
- en: 'Individual access rules are known as **Access Control Entries** (**ACEs**).
    An ACE is the combination of the following factors:'
  prefs: []
  type: TYPE_NORMAL
- en: The SID for the actor to which the rule applies
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The object identity to which the rule applies
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The permission that should be applied to the given `SID` and the stated object
    identity
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Whether or not the stated permission should be allowed or denied for the given
    `SID` and object identity
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The purpose of the Spring ACL system as a whole is to evaluate each secured
    method invocation and determine whether the object or objects being acted on in
    the method should be allowed as per the applicable ACEs. Applicable ACEs are evaluated
    at runtime, based on the caller and the objects in play.
  prefs: []
  type: TYPE_NORMAL
- en: Spring Security ACL is flexible in its implementation. Although the majority
    of this chapter details the out-of-the-box functionality of the Spring Security
    ACL module, keep in mind, however, that many of the rules indicated represent
    default implementations, which in many cases can be overridden based on more complex
    requirements.
  prefs: []
  type: TYPE_NORMAL
- en: 'Spring Security uses helpful value objects to represent the data associated
    with each of these conceptual entities. These are listed in the following table:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **ACL conceptual object** | **Java object** |'
  prefs: []
  type: TYPE_TB
- en: '| SID | `o.s.s.acls.model.Sid` |'
  prefs: []
  type: TYPE_TB
- en: '| Object identity | `o.s.s.acls.model.ObjectIdentity` |'
  prefs: []
  type: TYPE_TB
- en: '| ACL | `o.s.s.acls.model.Acl` |'
  prefs: []
  type: TYPE_TB
- en: '| ACE | `o.s.s.acls.model.AccessControlEntry` |'
  prefs: []
  type: TYPE_TB
- en: Let's work through the process of enabling Spring Security ACL components for
    a simple demonstration in the JBCP calendar application.
  prefs: []
  type: TYPE_NORMAL
- en: Basic configuration of Spring Security ACL support
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Although we hinted previously that configuring ACL support in Spring Security
    requires bean-based configuration (which it does), you can use ACL support while
    retaining the simpler security XML namespace configuration if you choose. In the
    remaining examples in this chapter, we will be focusing on Java-based configuration.
  prefs: []
  type: TYPE_NORMAL
- en: Gradle dependencies
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'As with most of the chapters, we will need to add some dependencies in order
    to use the functionality in this chapter. A list of the dependencies we have added
    with comments about when they are needed can be checked as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: Defining a simple target scenario
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Our simple target scenario is to grant `user2@example.com` read access to only
    the birthday party event. All other users will not have any access to any events.
    You will observe that this differs from our other examples, since `user2@example.com`
    is not otherwise associated with the birthday party event.
  prefs: []
  type: TYPE_NORMAL
- en: Although there are several ways to set up ACL checking, our preference is to
    follow the annotation-based approach that we used in this chapter's method-level
    annotations. This nicely abstracts the use of ACLs away from the actual interface
    declarations and allows for replacement (if you want) of the role declarations
    with something other than ACLs at a later date (should you so choose).
  prefs: []
  type: TYPE_NORMAL
- en: 'We''ll add an annotation to the `CalendarService.getEvents` method, which filters
    each event based upon the current user''s permission to the event:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: You should be starting with `chapter12.00-calendar`.
  prefs: []
  type: TYPE_NORMAL
- en: Adding ACL tables to the H2 database
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The first thing we'll need to do is add the required tables and data to support
    persistent ACL entries in our in-memory H2 database. To do this, we'll add a new
    SQL DDL file and the corresponding data to our embedded-database declaration in
    `schema.sql`. We will break down each of these files later in the chapter.
  prefs: []
  type: TYPE_NORMAL
- en: 'We have included the following `schema.sql` file with this chapter''s source
    code, which is based upon the schema files included in the Spring Security reference''s
    Appendix, *Additional Reference Material*:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding code will result in the following database schema:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/8267833a-9f6b-47fe-ab50-c901d55ac3fe.png)'
  prefs: []
  type: TYPE_IMG
- en: You can see how the concepts of `SIDs`, `OBJECT_IDENTITY`, and ACEs map directly
    to the database schema. Conceptually, this is convenient, as we can map our mental
    model of the ACL system and how it is enforced directly to the database.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you''ve cross-referenced this with the H2 database schema supplied with
    the Spring Security documentation, you''ll note that we''ve made a few tweaks
    that commonly bite users. These are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Change the `ACL_CLASS.CLASS` column to `500` characters, from the default value
    of `100`. Some long, fully qualified class names don't fit in `100` characters.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Name the foreign keys with something meaningful so that failures are more easily
    diagnosed.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If you are using another database, such as Oracle, you'll have to translate
    the DDL into DDL and data types specific to your database.
  prefs: []
  type: TYPE_NORMAL
- en: Once we configure the remainder of the ACL system, we'll return to the database
    to set up some basic ACEs to prove the ACL functionality in its most primitive
    form.
  prefs: []
  type: TYPE_NORMAL
- en: Configuring SecurityExpressionHandler
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We'll need to configure `<global-method-security>` to enable annotations (where
    we'll annotate based on the expected ACL privilege), and reference a custom access
    decision manager.
  prefs: []
  type: TYPE_NORMAL
- en: 'We will also need to provide an `o.s.s.access.expression.SecurityExpressionHandler`
    implementation that is aware of how to evaluate permissions. Update your `SecurityConfig.java`
    configuration, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'This is a bean reference to the `DefaultMethodSecurityExpressionHandler` object
    that we have defined in `AclConfig.java` file for you, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'With even a relatively straightforward ACL configuration, as we have in our
    scenario, there are a number of required dependencies to set up. As we mentioned
    previously, the Spring Security ACL module comes out of the box with a number
    of components that you can assemble to provide a decent set of ACL capabilities.
    Note that all of the components that we''ll reference in the following diagram
    are part of the framework:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/3d48ab85-ba85-4e90-bfe8-127df7e137a4.png)'
  prefs: []
  type: TYPE_IMG
- en: The AclPermissionCacheOptimizer object
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The `DefaultMethodSecurityExpressionHandler` object has two dependencies. The
    `AclPermissionCacheOptimizer` object is used to prime the cache with all of the
    ACLs for a collection of objects in a single JDBC select statement. The relatively
    simple configuration included with this chapter can be checked, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: Optimizing AclPermission Cache
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The `DefaultMethodSecurityExpressionHandler` object then delegates to a `PermissionEvalulator`
    instance. For the purposes of this chapter, we are using ACLs so that the bean
    we will use `AclPermissionEvaluator`, which will read the ACLs that we define
    in our database. You can view the provided configuration for `permissionEvaluator`,
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: The JdbcMutableAclService object
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'At this point, we have seen a reference to `th` with the `aclService` ID twice.
    The `aclService` ID resolves to an implementation of `o.s.s.acls.model.AclService`
    that is responsible (through delegation) for translating information about the
    object being secured by ACLs into expected ACEs:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: We'll use `o.s.s.acls.jdbc.JdbcMutableAclService`, which is the default implementation
    of `o.s.s.acls.model.AclService`. This implementation comes out of the box and
    is ready to use the schema that we defined in the last step of this exercise.
    The `JdbcMutableAclService` object will additionally use recursive SQL and post-processing
    to understand object and `SID` hierarchies and ensure that representations of
    these hierarchies are passed back to `AclPermissionEvaluator`.
  prefs: []
  type: TYPE_NORMAL
- en: The BasicLookupStrategy class
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The `JdbcMutableAclService` class uses the same JDBC `dataSource` instance
    that we''ve defined with the embedded database declaration, and it also delegates
    to an implementation of `o.s.s.acls.jdbc.LookupStrategy`, which is solely responsible
    for actually making database queries and resolving requests for ACLs. The only
    `LookupStrategy` implementation supplied with Spring Security is `o.s.s.acls.jdbc.BasicLookupStrategy`,
    and is defined as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: Now, `BasicLookupStrategy` is a relatively complex beast. Remember that its
    purpose is to translate a list of the `ObjectIdentity` declarations to be protected
    into the actual, applicable ACE list from the database. As `ObjectIdentity` declarations
    can be recursive, this proves to be quite a challenging problem, and a system
    which is likely to experience heavy use should consider the SQL that's generated
    for performance impact on the database.
  prefs: []
  type: TYPE_NORMAL
- en: Querying with the lowest common denominator
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Be aware that `BasicLookupStrategy` is intended to be compatible with all databases
    by strictly sticking with standard ANSI SQL syntax, notably `left [outer] joins`.
    Some older databases (notably, **Oracle8i**) did not support this join syntax,
    so ensure that you verify that the syntax and structure of SQL is compatible with
    your particular database!
  prefs: []
  type: TYPE_NORMAL
- en: There are also most certainly more efficient database-dependent methods of performing
    hierarchical queries using non-standard SQL, for example, Oracle's `CONNECT BY`
    statement and the **Common Table Expression** (**CTE**) capability of many other
    databases, including PostgreSQL and Microsoft SQL Server.
  prefs: []
  type: TYPE_NORMAL
- en: Much as you learned in the example in [Chapter 4](04.html), *JDBC-Based Authentication*,
    using a custom schema for the `JdbcDaoImpl` implementation of the `UserDetailsService`
    properties are exposed to allow for configuration of the SQL utilized by `BasicLookupStrategy`.
    Consult the Javadoc and the source code itself to see how they are used so that
    they can be correctly applied to your custom schema.
  prefs: []
  type: TYPE_NORMAL
- en: We can see that `LookupStrategy` requires a reference to the same JDBC `dataSource`
    instance that AclService utilizes. The other three references bring us almost
    to the end of the dependency chain.
  prefs: []
  type: TYPE_NORMAL
- en: EhCacheBasedAclCache
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `o.s.s.acls.model.AclCache` interface declares an interface for a caching
    `ObjectIdentity` to ACL mappings, to prevent redundant (and expensive) database
    lookups. Spring Security ships with only one implementation of `AclCache`, using
    the third-party library `Ehcache`.
  prefs: []
  type: TYPE_NORMAL
- en: '`Ehcache` is an open source, memory and disk-based caching library that is
    widely used in many open source and commercial Java products. As mentioned earlier
    in the chapter, Spring Security ships with a default implementation of ACL caching,
    which relies on the availability of a configured `Ehcache` instance, which it
    uses to store ACL information in preference to reading ACLs from the database.'
  prefs: []
  type: TYPE_NORMAL
- en: While deep configuration of `Ehcache` is not something we want to cover in this
    section, we'll cover how Spring ACL uses the cache and walk you through a basic
    default configuration.
  prefs: []
  type: TYPE_NORMAL
- en: 'Setting up `Ehcache` is simple-we''ll simply declare `o.s.s.acls.domain.EhCacheBasedAclCache`
    along with its two dependent beans from Spring Core that manage `Ehcache` instantiation
    and expose several helpful configuration properties. Like our other beans, we
    have already provided the following configuration in `AclConfig.java`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: The ConsoleAuditLogger class
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The next simple dependency hanging off of `o.s.s.acls.jdbc.BasicLookupStrategy`
    is an implementation of the `o.s.s.acls.domain.AuditLogger` interface, which is
    used by the `BasicLookupStrategy` class to audit ACL and ACE lookups. Similar
    to the `AclCache` interface, only one implementation is supplied with Spring Security
    that simply logs to the console. We''ll configure it with another one-line bean
    declaration:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: The AclAuthorizationStrategyImpl interface
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The final dependency to resolve is to an implementation of the `o.s.s.acls.domain.AclAuthorizationStrategy`
    interface, which actually has no immediate responsibility at all during the load
    of the ACL from the database. Instead, the implementation of this interface is
    responsible for determining whether a runtime change to an ACL or ACE is allowed,
    based on the type of change. We''ll explain more on this later when we cover mutable
    ACLs, as the logical flow is both somewhat complicated and not pertinent to getting
    our initial configuration complete. The final configuration requirements are as
    follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: You might wonder what the reference to the bean with ID `adminAuthority` is
    for-`AclAuthorizationStrategyImpl` provides the ability to specify `GrantedAuthority`
    that is required to allow specific operations at runtime on mutable ACLs. We'll
    cover these later in this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: 'Lastly, we need to update our `SecurityConfig.java` file to load our `AclConfig.java`
    file, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: We're finally done with the basic configuration of an out-of-the-box Spring
    Security ACL implementation. The next and final step requires that we insert a
    simple ACL and ACE into the H2 database and test it out!
  prefs: []
  type: TYPE_NORMAL
- en: Creating a simple ACL entry
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Recall that our very simple scenario is to only allow `user2@example.com` access
    to the birthday party event and ensure that no other events are accessible. You
    may find it helpful to refer back several pages to the database schema diagram
    to follow which data we are inserting and why.
  prefs: []
  type: TYPE_NORMAL
- en: We have already included a file named `data.sql` in the sample application.
    All of the SQL explained in this section will be from the file-you may feel free
    to experiment and add more test cases based on the sample SQL we've provided-in
    fact, we'd encourage that you experiment with sample data!
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s take a look at the following steps for creating a simple ACL entry:'
  prefs: []
  type: TYPE_NORMAL
- en: 'First, we''ll need to populate the `ACL_CLASS` table with any or all of the
    domain object classes, which may have ACL rules-in the case of our example, this
    is simply our `Event` class:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: We chose to use primary keys that are between `10` to `19` for the `ACL_CLASS`
    table, `20` to `29` for the `ACL_SID` table, and so on. This will help to make
    it easier to understand which data associates to which table. Note that our `Event`
    table starts with a primary key of `100`. These conveniences are done for example
    purposes and are not suggested for production purposes.
  prefs: []
  type: TYPE_NORMAL
- en: Next, the `ACL_SID` table is seeded with `SIDs` that will be associated with
    the ACEs. Remember that `SIDs` can either be roles or users-we'll populate the
    roles and `user2@example.com` here.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'While the `SID` object for roles is straightforward, the `SID` object for a
    user is not quite as clear-cut. For our purposes, the username is used for the
    `SID`. To learn more about how the `SIDs` are resolved for roles and users, refer
    to `o.s.s.acls.domain.SidRetrievalStrategyImpl`. If the defaults do not meet your
    needs, a custom `o.s.s.acls.model.SidRetrievalStrategy` default can be injected
    into `AclPermissionCacheOptimizer` and `AclPermissionEvaluator`. We will not need
    this sort of customization for our example, but it is good to know that it is
    available if necessary:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: 'The table where things start getting complicated is the `ACL_OBJECT_IDENTITY`
    table that is used to declare individual domain object instances, their parent
    (if any), and owning `SID`. For example, this table represents the `Event` objects
    that we are securing. We''ll insert a row with the following properties:'
  prefs: []
  type: TYPE_NORMAL
- en: Domain object of type `Event` that is a foreign key, `10`, to our `ACL_CLASS`
    table via the `OBJECT_ID_CLASS` column.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Domain object primary key of `100` (the `OBJECT_ID_IDENTITY` column). This is
    a foreign key (although not enforced with a database constraint) to our `Event`
    object.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Owner `SID` of `user2@example.com`, which is a foreign key, `20`, to `ACL_SID`
    via the `OWNER_SID` column.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The SQL to represent our events with IDs of `100` (birthday event), `101`,
    and `102` is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: Keep in mind that the owning `SID` could also represent a role-both types of
    rules function equally well as far as the ACL system is concerned.
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, we''ll add an ACE-related to this object instance, which declares
    that `user2@example.com` is allowed read access to the birthday event:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: The `MASK` column here represents a bitmask, which is used to grant permission
    assigned to the stated `SID` on the object in question. We'll explain the details
    of this later in this chapter-unfortunately, it doesn't tend to be as useful as
    it may sound.
  prefs: []
  type: TYPE_NORMAL
- en: Now, we can start the application and run through our sample scenario. Try logging
    in with `user2@example.com`/`user2` and accessing the All Events page. You will
    see that only the birthday event is listed. When logged in with `admin1@example.com`/`admin1`
    and viewing the All Events page, no events will be displayed. However, if we navigated
    directly to an event, it would not be protected. Can you figure out how to secure
    direct access to an event based on what you learned in this chapter?
  prefs: []
  type: TYPE_NORMAL
- en: 'If you have not figured it out yet, you can secure direct access to an event
    by making the following update to `CalendarService`, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: We now have a basic working setup of ACL-based security (albeit, a very simple
    scenario). Let's move on to some more explanation about concepts we saw during
    this walkthrough, and then review a couple of considerations in a typical Spring
    ACL implementation that you should consider before using it.
  prefs: []
  type: TYPE_NORMAL
- en: Your code should look like `chapter12.01-calendar`.
  prefs: []
  type: TYPE_NORMAL
- en: 'It is worth noting that we have not created new ACL entries when we create
    events. Thus, in the current state, if you create an event, you will receive an
    error similar to the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '`Exception during execution of Spring Security application! Unable to find
    ACL information for object identity org.springframework.security.acls.domain.ObjectIdentityImpl[Type:
    com.packtpub.springsecurity.domain.Event; Identifier: 103]`.'
  prefs: []
  type: TYPE_NORMAL
- en: Advanced ACL topics
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Some high-level topics that we skimmed over during the configuration of our
    ACL environment had to do with ACE permissions and the use of the `GrantedAuthority`
    indicators to assist the ACL environment in determining whether certain types
    of runtime changes to ACLs were allowed. Now that we have a working environment,
    we'll review these more advanced topics.
  prefs: []
  type: TYPE_NORMAL
- en: How permissions work
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Permissions are no more than single logical identifiers represented by bits
    in an integer. An access control entry grants permissions to `SIDs` based on the
    bitmask, which comprises the logical AND of all permissions applicable to that
    access control entry.
  prefs: []
  type: TYPE_NORMAL
- en: The default permission implementation, `o.s.s.acls.domain.BasePermission`, defines
    a series of integer values representing common ACL authorization verbs. These
    integer values correspond to single bits set in an integer, so a value of `BasePermission`,
    `WRITE`, with integer value `1` has a bitwise value of `21` or `2`.
  prefs: []
  type: TYPE_NORMAL
- en: 'These are illustrated in the following diagram:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/cde17926-2e18-4572-86a0-c523cd36964f.png)'
  prefs: []
  type: TYPE_IMG
- en: We can see that the **Sample** permission bitmask would have an integer value
    of **3**, due to the application of both the **Read** and **Write** permissions
    to the permission value. All of the standard integer single permission values
    shown in the preceding diagram are defined in the `BasePermission` object as static
    constants.
  prefs: []
  type: TYPE_NORMAL
- en: The logical constants that are included in `BasePermission` are just a sensible
    baseline of commonly used permissions in ACE, and have no semantic meaning within
    the Spring Security framework. It's quite common for very complex ACL implementations
    to invent their own custom permissions, augmenting best practice examples with
    domain- or business-dependent ones.
  prefs: []
  type: TYPE_NORMAL
- en: One issue that often confuses users is how the bitmasks are used in practice,
    given that many databases either do not support bitwise logic or do not support
    it in a scalable way. Spring ACL intends to solve this problem by putting more
    of the load of calculating appropriate permissions related to bitmasks on the
    application rather than on the database.
  prefs: []
  type: TYPE_NORMAL
- en: It's important to review the resolution process, where we see how `AclPermissionEvaluator`
    resolves permissions declared on the method itself (in our example, with the `@PostFilter`
    annotation) to real ACL permissions.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following diagram illustrates the process that Spring ACL performs to evaluate
    the declared permission against the relevant ACEs for the requesting principal:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/3aace789-7e8e-437e-b33d-56dff2233b27.png)'
  prefs: []
  type: TYPE_IMG
- en: We see that `AclPermissionEvaluator` relies on classes implementing two interfaces,
    `o.s.s.acls.model.ObjectIdentityRetrievalStrategy` and `o.s.s.acls.model.SidRetrievalStrategy`,
    to retrieve `ObjectIdentity` and `SIDs` appropriate for the authorization check.
    The important thing to note about these strategies is how the default implementation
    classes actually determine the `ObjectIdentity` and `SIDs` objects to return,
    based on the context of the authorization check.
  prefs: []
  type: TYPE_NORMAL
- en: The `ObjectIdentity` object has two properties, `type` and `identifier`, that
    are derived from the object being checked at runtime, and used to declare ACE
    entries. The default `ObjectIdentityRetrievalStrategy` interface uses the fully-qualified
    class name to populate the `type` property. The `identifier` property is populated
    with the result of a method with the signature `Serializable getId()`, invoked
    on the actual object instance.
  prefs: []
  type: TYPE_NORMAL
- en: As your object isn't required to implement an interface to be compatible with
    ACL checks, the requirement to implement a method with a specific signature can
    be surprising for developers implementing Spring Security ACL. Plan ahead and
    ensure that your domain objects contain this method! You may also implement your
    own `ObjectIdentityRetrievalStrategy` class (or subclass the out-of-the-box implementation)
    to call a method of your choice. The name and type signature of the method is,
    unfortunately, not configurable.
  prefs: []
  type: TYPE_NORMAL
- en: Unfortunately, the actual implementation of `AclImpl` directly compares the
    permission specified in our SpEL expression specified in our `@PostFilter` annotation,
    and the permission stored on the ACE in the database, without using bitwise logic.
    The Spring Security community is in debate about whether this is unintentional
    or working as intended, but regardless, you will need to take care when declaring
    a user with a combination of permissions, as either `AclEntryVoter` must be configured
    with all combinations of permission, or the ACEs need to ignore the fact that
    the permission field is intended to store multiple values and instead store a
    single permission per ACE.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you want to verify this with our simple scenario, change the `READ` permission
    we granted to the `user2@example.com` SID to the bitmask combination of `Read`
    and `Write`, which translates to a value of `3`. This would be updated in the
    `data.sql` file, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: Your code should look like `chapter12.02-calendar`.
  prefs: []
  type: TYPE_NORMAL
- en: The custom ACL permission declaration
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As stated in the earlier discussion on permission declarations, permissions
    are nothing but logical names for integer bit values. As such, it's possible to
    extend the `o.s.s.acls.domain.BasePermission` class and declare your own permissions.
    We'll cover a very straightforward scenario here, where we create a new ACL permission
    called `ADMIN_READ`. This is a permission that will be granted only to administrative
    users and will be assigned to protect resources that only administrators could
    read. Although a contrived example for the JBCP calendar application, this type
    of use of custom permissions occurs quite often in situations dealing with personally
    identifiable information (for example, social security number, and so on-recall
    that we covered PII in [Chapter 1](01.html), *Anatomy of an Unsafe Application*).
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s get started making the changes required to support this by performing
    the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'The first step is to extend the `BasePermission` class with our own `com.packtpub.springsecurity.acls.domain.CustomPermission`
    class, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, we will need to configure the `o.s.s.acls.domain.PermissionFactory` default
    implementation, `o.s.s.acls.domain.DefaultPermissionFactory`, to register our
    custom permission logical value. The role of `PermissionFactory` is to resolve
    permission bitmasks into logical permission values (which can be referenced by
    the constant value, or by name, such as `ADMIN_READ`, in other areas of the application).
    The `PermissionFactory` instance requires that any custom permission is registered
    with it for proper lookup. We have included the following configuration that registers
    our `CustomPermission` class, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, we will need to override the default `PermissionFactory` instance for
    our `BasicLookupStrategy` and `AclPermissionEvaluator` interfaces with the customized
    `DefaultPermissionFactory` interface. Make the following updates to your `security-acl.xml`
    file:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: 'We also need to add the SQL query to utilize the new permission to grant access
    to the conference call (`acl_object_identity ID of 31`) event to `admin1@example.com`.
    Make the following updates to `data.sql`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: We can see that the new integer bitmask value of `32` has been referenced in
    the ACE data. This intentionally corresponds to our new `ADMIN_READ ACL` permission,
    as defined in Java code. The conference call event is referenced by its primary
    key (stored in the `object_id_identity` column) value of `31`, in the `ACL_OBJECT_IDENTITY`
    table.
  prefs: []
  type: TYPE_NORMAL
- en: 'The last step is to update our `CalendarService''s getEvents()` method to utilize
    our new permission, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: 'With all of these configurations in place, we can start up the site again and
    test out the custom ACL permission. Based on the sample data we have configured,
    here is what should happen when the various available users click on categories:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Username/password** | **Birthday party event** | **Conference call event**
    | **Other events** |'
  prefs: []
  type: TYPE_TB
- en: '| `user2@example.com`/`user2` | Allowed via `READ` | Denied | Denied |'
  prefs: []
  type: TYPE_TB
- en: '| `admin1@example.com`/`admin1` | Denied | Allowed via `ADMIN_READ` | Denied
    |'
  prefs: []
  type: TYPE_TB
- en: '| `user1@example.com`/`user1` | Denied | Denied | Denied |'
  prefs: []
  type: TYPE_TB
- en: We can see that even with the use of our simple cases, we've now been able to
    extend the Spring ACL functionality in a very limited way to illustrate the power
    of this fine-grained access control system.
  prefs: []
  type: TYPE_NORMAL
- en: Your code should look like `chapter12.03-calendar`.
  prefs: []
  type: TYPE_NORMAL
- en: Enabling ACL permission evaluation
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We saw in [Chapter 2](02.html), *Getting Started with Spring Security*, that
    the Spring Security JSP tag library offers functionality to expose authentication-related
    data to the user and to restrict what the user can see based on a variety of rules.
    So far in this book, we have used the Thymeleaf Security tag libraries that are
    built on top of Spring Security.
  prefs: []
  type: TYPE_NORMAL
- en: 'The very same tag library can also interact with an ACL-enabled system right
    out of the box! From our simple experiments, we have configured a simple ACL authorization
    scenario around the first two categories in the list on the home page. Let''s
    take a look at the following steps and learn how to enable ACL permission evaluation
    in our Thymeleaf pages:'
  prefs: []
  type: TYPE_NORMAL
- en: 'First, we will need to remove our `@PostFilter` annotation from the `getEvents()`
    method in our `CalendarService` interface in order to give our JSP tag library
    a chance to filter out the events that are not allowed for display. Go ahead and
    remove `@PostFilter` now, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: Now that we have removed `@PostFilter`, we can utilize the `<sec:authorize-acl>`
    tag to hide the events that the user doesn't actually have access to. Refer to
    the table in the preceding section as a refresher of the access rules we've configured
    up to this point!
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'We''ll wrap the display of each event with the **`<sec:authorize-acl>`** tag,
    declaring the list of permissions to check on the object to be displayed:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: 'Think for a moment about what we want to occur here-we want the user to see
    only the items to which they actually have the `READ` or `ADMIN_READ` (our custom
    permission) access. However, to use the tag library, we need to use the permission
    mask, which can be referenced from the following table:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '| **Name** | **Mask** |'
  prefs: []
  type: TYPE_TB
- en: '| `READ` | `1` |'
  prefs: []
  type: TYPE_TB
- en: '| `WRITE` | `2` |'
  prefs: []
  type: TYPE_TB
- en: '| `ADMIN_READ` | `32` |'
  prefs: []
  type: TYPE_TB
- en: Behind the scenes, the tag implementation utilizes the same `SidRetrievalStrategy`
    and `ObjectIdentityRetrievalStrategy` interfaces discussed earlier in this chapter.
    So, the computation of access checking follows the same workflow as it does with
    ACL-enabled voting on method security. As we will see in a moment, the tag implementation
    will also use the same `PermissionEvaluator`.
  prefs: []
  type: TYPE_NORMAL
- en: We have already configured our `GlobalMethodSecurityConfiguration` configuration
    with an `expressionHandler` element that references `DefaultMethodSecurityExpressionHandler`.
    The `DefaultMethodSecurityExpressionHandler` implementation is aware of our `AclPermissionEvaluator`
    interface, but we must also make Spring Security's web tier aware of `AclPermissionEvalulator`.
    If you think about it, this symmetry makes sense, since securing methods and HTTP
    requests are protecting two very different resources. Fortunately, Spring Security's
    abstractions make this rather simple.
  prefs: []
  type: TYPE_NORMAL
- en: 'Add a `DefaultWebSecurityExpressionHandler` handler that references the bean
    with the ID as `permissionEvaluator` that we have already defined:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, update `SecurityConfig.java` to refer to our `webExpressionHandler` implementation,
    as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: You can see how these steps are very similar to how we added support for permission
    handling to our method security. This time, it was a bit simpler, since we were
    able to reuse the same bean with ID as `PermissionEvaluator` that we already configured.
  prefs: []
  type: TYPE_NORMAL
- en: Start up our application and try accessing the All Events page as different
    users. You will find that the events that are not allowed for a user are now hidden
    using our tag library instead of the `@PostFilter` annotation. We are still aware
    that accessing an event directly would allow a user to see it. However, this could
    easily be added by combining what you learned in this chapter with what you learned
    about the `@PostAuthorize` annotation in this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Your code should look like `chapter12.04-calendar`.
  prefs: []
  type: TYPE_NORMAL
- en: Mutable ACLs and authorization
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Although the JBCP calendar application doesn't implement full user administration
    functionality, it's likely that your application will have common features, such
    as new user registration and administrative user maintenance. To this point, lack
    of these features-which we have worked around using SQL inserts at application
    startup-hasn't stopped us from demonstrating many of the features of Spring Security
    and Spring ACL.
  prefs: []
  type: TYPE_NORMAL
- en: However, the proper handling of runtime changes to declared ACLs, or the addition
    or removal of users in the system, is critical to maintaining the consistency
    and security of the ACL-based authorization environment. Spring ACL solves this
    issue through the concept of the mutable ACL (`o.s.s.acls.model.MutableAcl`).
  prefs: []
  type: TYPE_NORMAL
- en: Extending the standard ACL interface, the `MutableAcl` interface allows for
    runtime manipulation of ACL fields in order to change the in-memory representation
    of a particular ACL. This additional functionality includes the ability to create,
    update, or delete ACEs, change ACL ownership, and other useful functions.
  prefs: []
  type: TYPE_NORMAL
- en: We might expect, then, that the Spring ACL module would come out of the box
    with a way to persist runtime ACL changes to the JDBC datastore, and indeed it
    does. The `o.s.s.acls.jdbc.JdbcMutableAclService` class may be used to create,
    update, and delete the `MutableAcl` instances in the database, as well as to do
    general maintenance on the other supporting tables for ACLs (handling `SIDs`,
    `ObjectIdentity`, and domain object class names).
  prefs: []
  type: TYPE_NORMAL
- en: 'Recall from earlier in the chapter that the `AclAuthorizationStrategyImpl`
    class allows us to specify the administrative role for actions on mutable ACLs.
    These are supplied to the constructor as part of the bean configuration. The constructor
    arguments and their meaning are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Arg #** | **What it does?** |'
  prefs: []
  type: TYPE_TB
- en: '| 1 | Indicates the authority that a principal is required to have in order
    to take ownership of an ACL-protected object at runtime |'
  prefs: []
  type: TYPE_TB
- en: '| 2 | Indicates the authority that a principal is required to have in order
    to change the auditing of an ACL-protected object at runtime |'
  prefs: []
  type: TYPE_TB
- en: '| 3 | Indicates the authority that a principal is required to have in order
    to make any other kind of change (create, update, and delete) to an ACL-protected
    object at runtime |'
  prefs: []
  type: TYPE_TB
- en: It may be confusing that we only specified a single constructor argument when
    there are three arguments listed. The AclAuthorizationStrategyImpl class can also
    accept a single `GrantedAuthority`, which will then be used for all three arguments.
    This is convenient if we want the same `GrantedAuthority` to be used for all of
    the operations.
  prefs: []
  type: TYPE_NORMAL
- en: The JdbcMutableAclService interface contains a number of methods used to manipulate
    ACL and ACE data at runtime. While the methods themselves are fairly understandable
    (`createAcl`, `updateAcl`, and `deleteAcl`), the correct way to configure and
    use `JdbcMutableAclService` is often difficult for even advanced Spring Security
    users.
  prefs: []
  type: TYPE_NORMAL
- en: Let's modify `CalendarService` to create a new ACL for newly created events.
  prefs: []
  type: TYPE_NORMAL
- en: Adding ACLs to newly created events
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Currently, if a user creates a new event, it will not be visible to the user
    in the All Events view, since we are using the `<sec:authorize-acl>` tag to only
    display event objects that the user has access to. Let's update our `DefaultCalendarService`
    interface so that when a user creates a new event, they are granted read access
    to that event and it will be displayed for them on the All Events page.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s take a look at the following steps to add ACLs to newly created events:'
  prefs: []
  type: TYPE_NORMAL
- en: 'The first step is to update our constructor to accept `MutableAclService and
    UserContext`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, we need to update our `createEvent` method to also create an ACL for
    the current user. Make the following changes:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: The `JdbcMutableAclService` interface uses the current user as the default owner
    for the created `MutableAcl` interface. We chose to explicitly set the owner again
    to demonstrate how this can be overridden.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We then add a new ACE and save our ACL. That's all there is to it.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Start the application and log in with `user1@example.com`/`user1`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Visit the All Events page and see that there are no events currently listed.
    Then, create a new event and it will be displayed the next time you visit the
    All Events page. If you log in as any other user, the event will not be visible
    on the All Events page. However, it will potentially be visible to the user, since
    we have not applied security to other pages. Again, we encourage you to attempt
    to secure these pages on your own.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Your code should look like `chapter12.05-calendar`.
  prefs: []
  type: TYPE_NORMAL
- en: Considerations for a typical ACL deployment
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Actually deploying Spring ACL in a true business application tends to be quite
    involved. We wrap up coverage of Spring ACL with some considerations that arise
    in most Spring ACL implementation scenarios.
  prefs: []
  type: TYPE_NORMAL
- en: ACL scalability and performance modeling
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: For small and medium-sized applications, the addition of ACLs is quite manageable,
    and while it adds overhead to database storage and runtime performance, the impact
    is not likely to be significant. However, depending on the granularity with which
    ACLs and ACEs are modeled, the numbers of database rows in a medium- to the large-sized
    application can be truly staggering and can task even the most seasoned database
    administrator.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s assume we were to extend ACLs to cover an extended version of the JBCP
    calendar application. Let''s assume that users can manage accounts, post pictures
    to events, and administer (add/remove users) from an event. We''ll model the data
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: All users have accounts.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 10% of users are able to administer an event. The average number of events that
    a user can administer will be two.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Events will be secured (read-only) per customer, but also need to be accessible
    (read/write) by administrators.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 10 percent of all customers will be allowed to post pictures. The average number
    of posts per user will be 20.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Posted pictures will be secured (read-write) per user, as well as administrators.
    Posted pictures will be read-only for all other users.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Given what we know about the ACL system, we know that the database tables have
    the following scalability attributes:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Table** | **Scales with data** | **Scalability notes** |'
  prefs: []
  type: TYPE_TB
- en: '| `ACL_CLASS` | No | One row is required per domain class. |'
  prefs: []
  type: TYPE_TB
- en: '| `ACL_SID` | Yes (users) | One row is required per role (`GrantedAuthority`).
    One row is required for each user account (if individual domain objects are secured
    per user). |'
  prefs: []
  type: TYPE_TB
- en: '| `ACL_OBJECT_IDENTITY` | Yes (domain class instances per class) | One row
    is required per instance of a secured domain object. |'
  prefs: []
  type: TYPE_TB
- en: '| `ACL_ENTRY` | Yes (domain object instances individual ACE entries) | One
    row is required per ACE; may require multiple rows for a single domain object.
    |'
  prefs: []
  type: TYPE_TB
- en: We can see that `ACL_CLASS` doesn't really have scalability concerns (most systems
    will have fewer than 1,000 domain classes). The `ACL_SID` table will scale linearly
    based on the number of users in the system. This is probably not a matter of concern
    because other user-related tables will scale in this fashion as well (user account,
    and so on).
  prefs: []
  type: TYPE_NORMAL
- en: 'The two tables of concern are `ACL_OBJECT_IDENTITY` and `ACL_ENTRY`. If we
    model the estimated rows required to model an order for an individual customer,
    we come up with the following estimates:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Table** | **ACL data per event** | **ACL data per picture post** |'
  prefs: []
  type: TYPE_TB
- en: '| `ACL_OBJECT_IDENTITY` | One row is required for a single event. | One row
    is required for a single post. |'
  prefs: []
  type: TYPE_TB
- en: '| `ACL_ENTRY` | Three rows-one row is required for read access by the owner
    (the user `SID`), two rows are required (one for read access, one for write access)
    for the administrative group `SID`. | Four rows-one row is required for read access
    by the user group `SID`, one row is required for write access by the owner, two
    rows are required for the administrative group `SID` (as with events) |'
  prefs: []
  type: TYPE_TB
- en: 'We can then take the usage assumptions from the previous page and calculate
    the following ACL scalability matrix as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Table/Object** | **Scale factor** | **Estimates (Low)** | **Estimates (High)**
    |'
  prefs: []
  type: TYPE_TB
- en: '| `Users` |  | `10,000` | `1,000,000` |'
  prefs: []
  type: TYPE_TB
- en: '| `Events` | `# Users * 0.1 * 2` | `2,000` | `200,000` |'
  prefs: []
  type: TYPE_TB
- en: '| `Picture Posts` | `# Users * 0.1 * 20` | `20,000` | `2,000,000` |'
  prefs: []
  type: TYPE_TB
- en: '| `ACL_SID` | `# Users` | `10,000` | `1,000,000` |'
  prefs: []
  type: TYPE_TB
- en: '| `ACL_OBJECT_IDENTITY` | `# Events + # Picture Posts` | `220,000` | `2,200,000`
    |'
  prefs: []
  type: TYPE_TB
- en: '| `ACL_ENTRY` | `(# Events * 3) + (# Picture Posts * 4)` | `86,000` | `8,600,000`
    |'
  prefs: []
  type: TYPE_TB
- en: From these projections based on only a subset of the business objects likely
    to be involved and secured in a typical ACL implementation, you can see that the
    number of database rows devoted to storing ACL information is likely to grow linearly
    (or faster) in relation to your actual business data. Especially in large system
    planning, forecasting the amount of ACL data that you are likely to use is extremely
    important. It is not uncommon for very complex systems to have hundreds of millions
    of rows related to ACL storage.
  prefs: []
  type: TYPE_NORMAL
- en: Do not discount custom development costs
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Utilizing a Spring ACL-secured environment often requires significant development
    work above and beyond the configuration steps we''ve described to this point.
    Our sample configuration scenario has the following limitations:'
  prefs: []
  type: TYPE_NORMAL
- en: No facility is provided for responding to the manipulation modification of events
    or modification of permissions
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Not all of the application is using permissions. For example, the My Events
    page and directly navigating to an event are both not secured
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The application does not effectively use ACL hierarchies. These limitations
    would significantly impact the functionality were we to roll out ACL security
    to the whole site. This is why it is critical that when planning Spring ACL rollout
    across an application, you must carefully review all of the places where the domain
    data is manipulated and ensure that these locations correctly update ACL and ACE
    rules, and invalidate caches. Typically, the securing of methods and data takes
    place at the service or business application layer, and the hooks required to
    maintain ACLs and ACEs occur at the data access layer.
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/85ea63ba-90df-4dea-bf21-fcb02a8a96e2.png)'
  prefs: []
  type: TYPE_IMG
- en: If you are dealing with a reasonably standard application architecture, with
    proper isolation and encapsulation of functionality, it's likely that there's
    an easily identified central location for these changes. On the other hand, if
    you're dealing with an architecture that has devolved (or was never designed well
    in the first place), then adding ACL functionality and supporting hooks in data
    manipulation code can prove to be very difficult.
  prefs: []
  type: TYPE_NORMAL
- en: As previously hinted, it's important to keep in mind that the Spring ACL architecture
    hasn't changed significantly since the days of Acegi 1.x. During that time, many
    users have attempted to implement it, and have logged and documented several important
    restrictions, many of which are captured in the Spring Security JIRA repository
    ([http://jira.springframework.org/](http://jira.springframework.org/)). Issue
    `SEC-479` functions as a useful entry point for some of the key limitations, many
    of which remain unaddressed with Spring Security 3, and (if they are applicable
    to your situation) can require significant custom coding to work around.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following are some of the most important and commonly encountered issues:'
  prefs: []
  type: TYPE_NORMAL
- en: The ACL infrastructure requires a numeric primary key. For applications that
    use a GUID or UUID primary key (which occurs more frequently due to more efficient
    support in modern databases), this can be a significant limitation.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: At the time of writing this, the JIRA issue, SEC-1140, documents the issue that
    the default ACL implementation does not correctly compare permission bitmasks
    using bitwise operators. We covered this earlier in the section on permissions.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Several inconsistencies exist between the method of configuring Spring ACL and
    the rest of Spring Security. In general, it is likely that you will run into areas
    where class delegates or properties are not exposed through DI, necessitating
    an override and rewrite strategy that can be time consuming and expensive to maintain.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The permission bitmask is implemented as an integer, and thus has 32 possible
    bits. It's somewhat common to expand the default bit assignments to indicate permissions
    on individual object properties (for example, assigning a bit to read the social
    security number of an employee). Complex deployments may have well over 32 properties
    per domain object, in which case the only alternative would be to remodel your
    domain objects around this limitation.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Depending on your specific application's requirements, it is likely that you
    will encounter additional issues, especially with regards to the number of classes
    requiring change when implementing certain types of customizations.
  prefs: []
  type: TYPE_NORMAL
- en: Should I use Spring Security ACL?
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Just like the details of applying Spring Security as a whole are highly business
    dependent, so is the application of Spring ACL support. In fact, this tends to
    be even more true of ACL support due to its tight coupling to business methods
    and domain objects. We hope that this guide to Spring ACL explained the important
    high-level and low-level configurations and concepts required to analyze Spring
    ACL for use in your application and can assist you in determining and matching
    its capabilities to real-world use.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we focused on security based on ACL and the specific details
    of how this type of security is implemented by the Spring ACL module.
  prefs: []
  type: TYPE_NORMAL
- en: We reviewed the basic concept of ACL, and many reasons why they can be very
    effective solutions to authorization. Also, you learned the key concepts related
    to the Spring ACL implementation, including ACEs, SIDs, and object identity. We
    examined the database schema and logical design required to support a hierarchical
    ACL system. We configured all the required Spring beans to enable the Spring ACL
    module and enhanced one of the service interfaces to use annotated method authorization.
    We then tied the existing users in our database, and business objects used by
    the site itself, into a sample set of ACE declarations and supporting data. We
    reviewed the concepts around Spring ACL permission handling. We expanded our knowledge
    of the Spring Security Thymeleaf tag library and SpEL expression language (for
    method security) to utilize ACL checks. We discussed the mutable ACL concept and
    reviewed the basic configuration and custom coding required in a mutable ACL environment.
    We developed a custom ACL permission and configured the application to demonstrate
    its effectiveness. We configured and analyzed the use of the `Ehcache` cache manager
    to reduce the database impact of Spring ACL. We analyzed the impact and design
    considerations of using the Spring ACL system in a complex business application.
  prefs: []
  type: TYPE_NORMAL
- en: This wraps up our discussion about Spring Security ACLs. In the next chapter,
    we'll dig a bit further into how Spring Security works.
  prefs: []
  type: TYPE_NORMAL
