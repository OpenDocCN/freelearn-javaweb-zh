- en: Spring Microservices on Cloud Platforms
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Pivotal defines Spring Cloud as a framework that accelerates cloud-native application
    development. Today, when we talk about cloud-native applications, the first thing that
    comes to mind is the ability to deliver software quickly. To meet these demands,
    we should be able to quickly build new applications and design architectures that
    are scalable, portable, and prepared to be frequently updated. The tools that
    provide the mechanisms for containerization and orchestration help us in setting
    up and maintaining such an architecture. In fact, tools such as Docker or Kubernetes,
    which we have looked at in previous chapters, allow us to create our own private
    cloud and run Spring Cloud microservices on it. Although an application does not
    have to be deployed on a public cloud, it contains all of the most important characteristics
    of cloud software.
  prefs: []
  type: TYPE_NORMAL
- en: Deploying your Spring application on a public cloud is just a possibility, not
    a necessity. However, there are some really interesting cloud platforms that allow
    you to easily run microservices and expose them on the web in just a few minutes.
    One of those platforms is **Pivotal Cloud Foundry** (**PCF**); its advantage over
    other platforms is its native support for Spring Cloud services, including discovery
    with Eureka, Config Server, and circuit breaker with Hystrix. You can also easily
    set up a full microservices environment just by enabling brokered services provided
    by Pivotal.
  prefs: []
  type: TYPE_NORMAL
- en: Another cloud platform that we should mention is Heroku. In contrast to PCF,
    it does not favor any programming framework. Heroku is a fully-managed, multi-language
    platform that allows you to quickly deliver software. It can build and run applications
    automatically once you have pushed changes in the source code stored on the GitHub
    repository. It also offers many add-on services that can be provisioned and scaled
    with a single command.
  prefs: []
  type: TYPE_NORMAL
- en: 'The topics covered in this chapter are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Introduction to Pivotal Web Services platform
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Deploying and managing applications on Pivotal Cloud Foundry using CLI, the
    Maven plugin, and the UI dashboard
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using Spring Cloud Foundry libraries to prepare an application to work properly
    on the platform
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Deploying Spring Cloud microservices on the Heroku platform
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Managing brokered services
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Pivotal Cloud Foundry
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Although the Pivotal platform can run applications written in many languages,
    including Java, .NET, Ruby, JavaScript, Python, PHP, and Go, it has the best support
    for Spring Cloud Services and Netflix OSS tools. It makes perfect sense because
    they are the ones who developed Spring Cloud. Take a look at the following diagram,
    which is also available on Pivotal''s official website. The following diagram
    illustrates the microservices-based architecture provided by the Pivotal Cloud
    platform. You can use Spring Cloud on Cloud Foundry to quickly leverage common
    microservice patterns, including distributed configuration management, service
    discovery, dynamic routing, load balancing, and fault tolerance:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/5b400ae4-44d3-4476-9425-dfe2194be84e.png)'
  prefs: []
  type: TYPE_IMG
- en: Usage models
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'You can use the Pivotal platform in three different models. Models are distinguished
    based on the host, which is where the applications are deployed. The following
    is a list of the available solutions:'
  prefs: []
  type: TYPE_NORMAL
- en: '**PCF Dev**: This instance of the Pivotal platform can be run locally on a
    single virtual machine. It is designed for experimental and developmental needs.
    It does not offer all possible features and services. For example, there are only
    some built-in services, such as Redis, MySQL, and RabbitMQ. However, PCF Dev also
    supports **Spring Cloud Services** (**SCS**), as well as all the languages supported
    in the full version of PCF. It is worth noting that if you want to run PCF Dev
    locally with SCS, you need more than 6 GB of RAM available.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Pivotal Web Services**: This is a cloud-native platform available online
    at  [https://run.pivotal.io/](https://run.pivotal.io/).  It''s like Pivotal Cloud
    Foundry with hosted, pay-by-the-hour pricing. It does not offer all the features
    and services available in Pivotal Cloud Foundry. For example, we may only enable
    services offered by SaaS partners of Pivotal. Pivotal Web Services is best suited
    for startups or individual teams. We will use this model of Pivotal platform hosting
    for presentation purposes in upcoming sections of this chapter.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Pivotal Cloud Foundry**: This is a full-featured cloud-native platform that
    runs on any major public IaaS, including AWS, Azure, and Google Cloud Platform,
    or on a private cloud based on OpenStack or VMware vSphere. It''s a commercial
    solution for large enterprise environments.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Preparing the application
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Since Pivotal Web Services has native support for Spring Cloud applications,
    the deployment process is very straightforward. However, it does require specific
    dependencies and configuration on the application side—especially if your microservices
    have to integrate with built-in services provided by Pivotal platforms such as
    Service Registry, Config Server, or Circuit Breaker. Besides standard dependency
    management for Spring Cloud, we should also include `spring-cloud-services-dependencies`
    in `pom.xml` with the newest version working with the `Edgware.SR2` release train,
    shown as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'Depending on the chosen services for integration you may want to include the
    following artifacts in your project. We decided to use all of the Spring Cloud
    features provided by the Pivotal platform, so our microservices fetch properties
    for a configuration server, register themselves in Eureka, and wrap inter-service
    communication with Hystrix commands. Here are the dependencies required for enabling
    discovery client, config client, and circuit breaker for an application deployed
    on the Pivotal platform:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'We will provide one more integration for our sample microservices. All of them
    will store data in MongoDB, which is also available as a service on the Pivotal
    platform. To achieve it, we should first include starter `spring-boot-starter-data-mongodb`
    in the project dependencies:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'A MongoDB address should be provided in configuration settings using the `spring.data.mongodb.uri`
    property. In order to allow an application to connect with MongoDB, we have to
    create a Pivotal''s service mLab and then bind it to the application. By default,
    metadata related to the bound services are exposed to the application as the environment
    variable `$VCAP_SERVICES`. The main motivation for such an approach is that Cloud
    Foundry has been designed to be a polyglot, meaning that any language and platform
    can be supported as a buildpack. All Cloud Foundry properties may be injected
    using the `vcap` prefix. If you would like to access Pivotal''s service, you should
    use the `vcap.services` prefix and then pass the service''s name shown as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'In fact, this is all that needs to be done on the application side to make
    them work properly with the components created on the Pivotal platform. Now we
    just have to enable Spring Cloud features in the same way as we did for a standard
    microservice written in Spring, as shown in the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: Deploying the application
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Applications can be managed on the **Pivotal Web Service** (**PWS**) platform
    in three different ways. The first is through a web console available at [https://console.run.pivotal.io](https://console.run.pivotal.io).
    We may monitor, scale, restart deployed applications, enable and disable services,
    define new quotas, and change account settings in this way. However, it is not
    possible to do this using a web console—in other words, an initial application
    deployment. It may be performed using a **CLI** (**command-line interface**).
    You can download the required installer from the [pivotal.io](https://pivotal.io) website.
    After installation, you should be able to invoke the Cloud Foundry CLI on your
    machine by typing `cf`, for example, `cf help`.
  prefs: []
  type: TYPE_NORMAL
- en: Using CLI
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'CLI provides a set of commands that allows you to manage your applications,
    brokered services, spaces, domains, and other components on Cloud Foundry. Let
    me show you the most important commands you should know to be able to run your
    application on PWS:'
  prefs: []
  type: TYPE_NORMAL
- en: 'In order to deploy the application, you must first navigate to its directory.
    You should then sign in to PWS using the `cf login` command as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'The next step is to push the application to PWS with the `cf push` command,
    passing the service''s name:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'Alternatively, you can provide `manifest.yml` in the application''s root directory
    with all the required deployment settings. In that case, all you need is to run
    the `cf push` command without any additional parameters, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'Deployment with the configuration settings provided in `manifest.yml` as shown
    in the preceding example will fail. To see why, run the command `cf logs`. The
    reason is an insufficient memory limit for heap:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'By default, the platform allocates 240 MB for the code cache, 140 MB for metaspace,
    and 1 MB for every thread, with an assumption that there is a maximum of 200 threads
    for the Tomcat connector. It is easy to calculate that, with these settings, every
    application needs around 650 MB of allocated memory. We may change these settings
    by calling the `cf set-env` command and passing the `JAVA_OPTS` parameter, as
    you can see in the following sample. Such a memory limit would not be enough in
    production mode but would be okay for testing purposes. To ensure that these changes
    take affect, use the `cf restage` command as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: Allocated memory is important, especially if there is only 2 GB RAM available
    for a free account. With the default memory settings applied, we can only deploy
    two applications on the Pivotal platform, as each of them takes up 1 GB of RAM.
    Although we have fixed the problems described previously, our application still
    does not work properly.
  prefs: []
  type: TYPE_NORMAL
- en: Binding to services
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'During boot, the applications were not able to connect with the required services.
    The problem occurs because services are not bound by default to the applications.
    You can display all of the services created in your space by running the command
    `cf services`, and bind each of them to a given microservice by invoking the command
    `cf bind-service`. In the following example command''s executions, we have bound
    Eureka, configuration server, and MongoDB to `account-service`. Finally, we can
    run `cf restage` once more and everything should work fine, shown as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: Using the Maven plugin
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As we have mentioned before, CLI and the web console are not the only ways to
    manage your application on the Pivotal platform. The Cloud Foundry team has implemented
    the Maven plugin in order to facilitate and speed up application deployment. What's
    interesting is that the same plugin can be used to manage pushes and updates to
    any Cloud Foundry instance, not only those provided by Pivotal.
  prefs: []
  type: TYPE_NORMAL
- en: 'When using Cloud Foundry''s Maven plugin you can easily integrate cloud deployments
    into their Maven projects'' life cycles. This allows you to push, remove, and
    update projects in Cloud Foundry. If you would like to push your project together
    with Maven, just run the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'Generally, the commands provided by the Maven plugin are pretty similar to
    the commands offered by CLI. For example, you can display a list of applications
    by executing the command `mvn cf:apps`. In order to delete an application, run
    the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'If you would like to upload some changes to the existing application, use the `cf:update`
    command as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'Before running any commands, we have to configure the plugin properly. First,
    it is required to pass Cloud Foundry login credentials. It is recommended to store
    them separately in Maven''s `settings.xml`. A typical entry inside a server tag
    might look like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'Using the Maven plugin instead of CLI commands has one important advantage:
    you can configure all the necessary configuration settings in one place and can
    apply them using a single command during application build. The full configuration
    of the plugin is shown in the following snippet. Besides some basic settings including
    space, memory, and a number of instances, it''s also possible to change memory
    limits with the `JAVA_OPTS` environment variable and by binding the required services
    to the application. After running the `cf:push` command, `product-service` is
    ready to use at the address `https://product-service-piomin.cfapps.io/`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: Maintenance
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Assuming all of the applications forming our example microservices-based system
    have been successfully deployed, we can easily manage and monitor them using the
    Pivotal Web Services dashboard, or even just CLI commands. The free trial provided
    by the Pivotal platform gives us a lot of possibilities and tools for maintaining
    applications, so let's discover some of its most interesting features.
  prefs: []
  type: TYPE_NORMAL
- en: Accessing deployment details
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We can list all of the deployed applications by running the command `cf apps`
    or by navigating to the main site of our space in the web console. You can see
    that list in the following screenshot. Each row of the table represents a single
    application. Besides its name, there is also information about its status, the
    number of instances, allocated memory, deployment time, and a URL at which a service
    is available outside the platform. If you didn''t specify a URL address during
    application deployment, it is automatically generated:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/d7008b6a-1a4a-48f7-ae30-e023ba2cdea5.png)'
  prefs: []
  type: TYPE_IMG
- en: 'You can click each row in order to discover details about the application.
    Similar information can be accessed using the CLI commands `cf app <app-name> `or  `cf
    app order-service`. The following screenshot shows the main panel of an application''s
    detailed view that contains the history of events, summary, as well as memory,
    disk, and CPU usage of every instance. In this panel, you may scale an application
    by clicking the Scale button. There are also several other tabs available. By
    switching to one of them, you can check out all bounded services (Services), external
    URLs assigned (Rules), display logs (Logs), and incoming requests history (Trace):'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/c7138419-e97b-4074-ba2a-8d63462ee396.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Of course, you can always use the CLI to collect the same details as shown
    in the previous example. If you execute the command `cf logs <app-name>`, you
    would be attached to `stdout` , which is generated by the application. You can
    also display the list of activated Pivotal managed services with the list of bound
    applications, as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/49fb545e-aaf7-4097-ac10-3b696d072ac7.png)'
  prefs: []
  type: TYPE_IMG
- en: Managing application life cycles
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Another really helpful feature provided by Pivotal Web Services is the ability
    to manage an application''s life cycle. In other words, we can easily stop, start,
    and restart an application with just one click. Before executing the requested
    command, you will be prompted for confirmation, as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/39623686-56f6-4fc7-896d-fdea0b62651c.png)'
  prefs: []
  type: TYPE_IMG
- en: 'The same result can be achieved by running one of the following CLI commands:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: Scaling
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'One of the most important reasons for using cloud solutions is the ability
    to scale your applications easily. The Pivotal platform deals with these issues
    in a very intuitive way. Firstly, you may decide how many instances of an application
    are started at each stage of deployment. For example, if you decided to use `manifest.yml`
    and deploy it with the `cf push` command, the number of created instances will
    be determined by field instances, as shown in the following code snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'The number of running instances, as well as memory and CPU limits, can be modified
    on the started application. In fact, there are two available approaches to scaling.
    You can either manually set how many instances should be launched or enable autoscaling,
    where you only need to define a criteria based on a selected metric''s thresholds.
    Autoscaling on the Pivotal platform is realized by a tool called **PCF App Autoscaler**.
    We can choose from the following five available rules, and they are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: CPU utilization
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Memory utilization
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: HTTP latency
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: HTTP throughput
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: RabbitMQ depth
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'You can define more than one active rule. Each of these rules has a minimum
    value per every single metric for scaling down and a maximum value for scaling
    up. Autoscale settings for `customer-service` are shown in the following screenshot.
    Here, we decided to apply HTTP throughput and HTTP latency rules. If latency for
    99% of traffic is lower than `20` ms, one instance of an application should be
    disabled in case there is more than one instance. Analogously, if a latency is
    greater than `200` ms, the platform should attach one more instance:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/f2434974-9f83-409d-a93e-9c1aec8cc445.png)'
  prefs: []
  type: TYPE_IMG
- en: 'We can also control the number of running instances manually. Autoscaling has
    many advantages but a manual approach gives you more control over that process.
    Thanks to limited memory for each application, there is still space for other
    instances. The most overloaded application in our example system is `account-service`,
    because it is called during an order''s creation as well as order''s confirmation.
    So, let''s add one more instance of that microservice. To do so, go to the `account-service`
    details panel and click on Scale under Processes and Instances. You should then
    increase the number of instances and apply the necessary changes; you should then
    see two instances of `account-service` available, as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/869909e6-33a2-4151-84d1-ecfae35dad37.png)'
  prefs: []
  type: TYPE_IMG
- en: Provisioning brokered services
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We have already looked at how to bind an application to a service using the `cf
    bind-service` command and the Maven plugin. However, we should now look at how
    to enable and configure our service. You can easily display a list of all the
    available services and then enable them using Pivotal's dashboard; this can be
    found under Marketplace.
  prefs: []
  type: TYPE_NORMAL
- en: 'The provisioning of a brokered service with Pivotal Web Services is very easy.
    After installation, some services are already available to use without any additional
    configuration. All we have to do is to bind them to selected applications and
    properly pass their network addresses in the application''s settings. Every application
    can be easily bound to a service using the UI dashboard. First, navigate to the
    main page of the service. There, you will see a list of the currently bound applications.
    You can bind a new application to the service by clicking BIND APP and then choosing
    one from the list displayed, as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/035ead31-9dd9-40a4-9da5-ba408e11c627.png)'
  prefs: []
  type: TYPE_IMG
- en: 'You don''t have to do anything more than enable the registry service in the
    marketplace and bind it to the application in order to enable the discovery feature
    on Pivotal Web Services. Of course, you can override some configuration settings
    on the client-side if needed. A full list of registered applications can be displayed
    in the Eureka dashboard under Manage in the main configuration panel of the service.
    There are two running instances of `account-service` because we scaled it up in
    the previous section; the other microservices however have only one running instance,
    shown as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/ef76969f-c91d-408d-806f-f8a65b90e841.png)'
  prefs: []
  type: TYPE_IMG
- en: 'In contrast to a discovery service, a configuration server needs to include
    additional settings. As before, you should navigate to its main panel and then
    select Manage. Here, you will be redirected to the configuration form. The configuration
    parameters have to be provided there as a JSON object. The `count` parameter specifies
    the number of nodes needed for provision, upgrade options if an instance can be
    upgraded, and `force` forces that upgrade even if the instance is already the
    latest available version. Other configuration parameters are dependent on a type
    of backend used to store property sources. As you may remember from [Chapter 5](37142825-02d0-48a0-99df-1a1a88a1bbd4.xhtml), *Distributed
    Configuration with Spring Cloud Config*, the most popular solution for Spring
    Cloud Config Server is based on the Git repository. We have created an example
    repository on GitHub, where all the required sources have been committed. The
    following are the parameters in a JSON format that should be provided for a Config
    Server on Pivotal Web Services:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: The last brokered service used by the example application provided hosted an
    instance of MongoDB. After navigating to Manage on the main panel of that service,
    you should be redirected to [https://mlab.com/home](https://mlab.com/home) , where
    you will be able to use the database's node.
  prefs: []
  type: TYPE_NORMAL
- en: The Heroku platform
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Heroku is one of the oldest cloud platforms created using the **PaaS** (**Platform
    as a Service**) model. In comparison to Pivotal Cloud Foundry, Heroku doesn't
    have built-in support for Spring Cloud applications. It complicates our model
    a little because we can't use a platform's services to enable typical microservices
    components, including service discovery, a configuration server, or a circuit
    breaker. In spite of this, Heroku contains some really interesting features that
    are not provided by Pivotal Web Services.
  prefs: []
  type: TYPE_NORMAL
- en: Deployment methods
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We can manage our application using the CLI, web console or a dedicated Maven
    plugin. Deploying Heroku is pretty similar to deploying the Pivotal platform,
    however, the methods are slightly different. The main approach assumes that you
    deploy the application by building it from the source code stored in your local
    Git repository or on GitHub. The build is executed by the Heroku platform automatically
    after you have pushed some changes in a branch to a repository, or on demand from
    the newest version of the code in the selected branch. Another interesting way
    to deploy an application is by pushing your Docker image to Heroku's container
    registry.
  prefs: []
  type: TYPE_NORMAL
- en: Using the CLI
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'You can begin by installing **Heroku Command Line Interface** (**CLI**) available
    at [https://cli-assets.heroku.com/heroku-cli/channels/stable/heroku-cli-x64.exe](https://cli-assets.heroku.com/heroku-cli/channels/stable/heroku-cli-x64.exe) (for
    Windows). In order to deploy and run your application on Heroku using CLI you
    have to perform the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'After installation, you can use the command `Heroku` from your shell. First,
    log in to Heroku using your credentials, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, navigate to the application''s `root` directory and create an application
    on Heroku. After running the following command, not only will the application
    be created, but a Git remote called `heroku` will as well. This is associated
    with your local Git repository, shown as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'Now you can deploy your application by pushing the code to Heroku''s Git remote.
    Heroku will then do all the work for you, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'If the application is started successfully, you will be able to manage it using
    some basic commands. In accordance with the order presented as follows, you can
    display logs, change the number of running dynos (in other words, scale the application),
    assign new add-ons, and list all of the enabled add-ons:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: Connecting to the GitHub repository
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Personally, I prefer to deploy my applications to Heroku by connecting to the
    projects using the GitHub repository. There are two possible approaches related
    to this deployment method: manual and automatic. You can choose either by navigating
    to the **Deploy** tab on the application''s details panel and then connect it
    to the specified GitHub repository, as you can see in the following screenshot.
    If you click the Deploy Branch button, the building of and the deployment to Heroku
    would immediately start on the given Git branch. Alternatively, you can also enable
    automatic deploys on the chosen branch by clicking **Enable Automatic Deploys**.
    Additionally, you can configure Heroku to wait for a Continuous Integration build
    result if it is enabled for your GitHub repository; this is a really helpful feature
    because it allows you to run automated tests on your project and ensure they have
    passed before it is pushed:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/af757b79-ef60-441e-8b89-735019c51cf2.png)'
  prefs: []
  type: TYPE_IMG
- en: Docker Container Registry
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Following the newest trends, Heroku allows you to deploy a containerized application
    using Docker. In order to be able to do that, you should have Docker and the Heroku
    CLI installed on your local machine:'
  prefs: []
  type: TYPE_NORMAL
- en: 'First, log in to Heroku Cloud by running the command `heroku login`. The next
    step is to log in to the Container Registry:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, make sure that your current directory contains `Dockerfile`. If present,
    you can proceed to building and pushing the image to Heroku''s Container Registry
    by executing the following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'If you have an existing built image, you may only be interested in tagging
    and pushing it to Heroku. In order to do that, you need to use Docker''s command
    line by executing the following commands (assuming your application''s name is `piomin-order-service`):'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: After the image has been successfully pushed, the new application should be
    visible in the Heroku dashboard.
  prefs: []
  type: TYPE_NORMAL
- en: Preparing an application
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'When deploying an application based on Spring Cloud components to Heroku, we
    no longer have to perform any extra changes in its source code or add any additional
    libraries, which we do when running it locally. The only difference here is in
    the configuration settings, where we should set an address in order to integrate
    the application with service discovery, databases, or any other add-on that can
    be enabled for your microservice. The current example, which is the same as the
    examples provided for Pivotal''s deployment, is to store data in MongoDB that
    is assigned to the application as an mLab service. Additionally, here, each client
    registers itself on the Eureka server, which is deployed as `piomin-discovery-service`.
    The following screenshot displays a list of the applications deployed on Heroku
    for our examples:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/1493f39a-d047-4aea-82b9-a8f65138f866.png)'
  prefs: []
  type: TYPE_IMG
- en: I deployed the previous applications on Heroku by connecting them with the GitHub
    repository. This, in turn, requires you to create a separate repository per microservice.
    For example, the repository of `order-service` is available at [https://github.com/piomin/sample-heroku-order-service.git;](https://clicktime.symantec.com/a/1/T35T4GHVxyO3_yEnmgYJzEOMwTYVoyfmLx2ONL0JOmM=?d=Em-4WZBG8KjUF8i64GiOj94xj1zxN6a1uB0eVZ0nPiAMBASzKXYmiNLpRNEcgxEQ7bHQ6AzvMbnrWHqhusJvYyZqTNMHlShDuReFC57yByy3O9bujQaWuS_jFkuW-GXlbAc9l9L2CmOU0k0c7iCbz4TP6gxYzTpi3F2ZhiR4yOGU_aIfM0-ImE4VjE3Zwu5hcRLW6fRjQIpA00TbvIfq03qKyXpN4rOeSy-uW8xOD3AifhkEun4HB33yo6UpNlLAVK45YxrUxZn2iT_VdnO336VCgrUe4QGzCEoQEtzN_eTC5eSH0FHDXyXwW0Aj4Px9YTY5asaj9oWluYR6xuKHwLEyHqyAWSKmRhRVXDNsi3pF13hLo94F&u=https%3A%2F%2Fgithub.com%2Fpiomin%2Fsample-heroku-order-service.git)
    other microservices may be at under similar addresses. You can easily fork these
    microservices and deploy them on your Heroku account in order to perform tests.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now let''s take a look at the configuration settings provided for one of our
    example applications: `account-service`. First, we have to override the auto-configured
    address of MongoDB using the `MONGODB_URI` environment variable provided by the
    Heroku platform. There is also a necessity to provide the correct address of a
    Eureka server, as well as override the hostname and port sent by a discovery client
    during registration. This is required because, by default, each application will
    try to register using an internal address that is not available for other applications.
    Without overriding these values, inter-service communication with the Feign client
    would be unsuccessful:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'Notice that the environment variable `HEROKU_APP_NAME` is the name of the current
    application deployed on Heroku, as seen in the preceding snippet. This is not
    available by default. To enable a variable for your application, for example,
    `customer-service`, run the following command with the experimental add-on `runtime-dyno-metadata`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: Testing deployments
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'After deployment, every application is available at an address made up of its
    name and a platform''s domain name, for example, [http://piomin-order-service.herokuapp.com](http://piomin-order-service.herokuapp.com).
    You are able to call the Eureka dashboard exposes using the URL, [http://piomin-discovery-service.herokuapp.com/](http://piomin-discovery-service.herokuapp.com/),
    which will allow you to check whether our example microservices have been registered.
    If everything worked correctly, you should see something similar to the following
    screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/bb34151b-5ecb-4d64-a7da-81f5952e4964.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Each microservice exposes API documentation automatically generated by Swagger2,
    so you can easily test every endpoint by calling it from the Swagger UI dashboard,
    available on `/swagger-ui.html`; for example, [http://piomin-order-service.herokuapp.com/swagger-ui.html](http://piomin-order-service.herokuapp.com/swagger-ui.html).
    The HTTP API visualization for `order-service` is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/60d46f83-d38c-463b-ba49-0b43c99810e9.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Each microservice stores data in MongoDB. This database can be enabled for
    your project by adding add-ons provided by Heroku, for example, mLab. As you may
    remember, we have already used an example of the same service for storing data
    in applications deployed on the Pivotal platform. Add-ons can be enabled for an
    application by provisioning it with the selected plan in the Resources tab of
    every application''s details panel. Once done, you can manage every plugin by
    simply clicking on it. For mLab, you will be redirected to the mLab ([mlab.com](https://mlab.com/))
    site, where you are able to see a list of all the collections, users, and generated
    statistics. The following screenshot illustrates the mLab dashboard for our examples:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/d791eac0-4a61-4ca2-a7a2-016a446821af.png)'
  prefs: []
  type: TYPE_IMG
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We have reached the end of our Spring Cloud microservices journey! Our exercises
    began with simple deployments on the local machine, but in the last chapter we
    deployed our microservices in an environment fully-managed by the cloud vendor,
    which also automatically built, started, and exposed HTTP APIs on specified domains.
    I personally think that it is amazing how easily we can run, scale, and expose
    data outside an application using any of the most popular programming languages
    or third-party tools, such as a database or a message broker. In fact, each one
    of us can now implement and launch a production-ready application to the web within
    a few hours without worrying about the software that has to be installed.
  prefs: []
  type: TYPE_NORMAL
- en: This chapter has shown you how easily you can run Spring Cloud microservices
    on different platforms. The given examples illustrate the real power of cloud-native
    applications. No matter whether you launch an application locally on your laptop,
    inside a Docker Container, using Kubernetes, or on an online cloud platform such
    as Heroku or Pivotal Web Services, you don't have to change anything in the application's
    source code; the modifications have to be performed only in its properties. (Assuming
    you use Config Server in your architecture, these changes are not invasive.)
  prefs: []
  type: TYPE_NORMAL
- en: In the last two chapters, we looked at some of the most recent trends seen in
    the IT world. Such topics as CI and CD, containerization with Docker, orchestration
    using Kubernetes, and cloud platforms are increasingly used by many organizations.
    In fact, these solutions are partly responsible for the increasing popularity
    of microservices. Currently, there is one leader in this area of programming—Spring
    Cloud. There is no other Java framework with as many features, or that can implement
    so many patterns related to microservices, as Spring Cloud. I hope this book will
    help you to use this framework effectively when building and honing your microservice-based
    enterprise system.
  prefs: []
  type: TYPE_NORMAL
