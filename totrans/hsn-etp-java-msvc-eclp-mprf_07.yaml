- en: MicroProfile Metrics and OpenTracing
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Once developers have written code and it is put into production, there is a
    need to observe what the code is doing, how well it is performing, and what resources
    it is using. MicroProfile has created two specifications to deal with these concerns:
    Metrics and (integration with) OpenTracing.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Starting off with the Metrics section, we will discuss the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: The rationale behind specifications
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Exposition formats of metrics on an enabled server
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Providing metrics from within your application
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using Prometheus, a cloud-native time series database, to retrieve and analyze
    metric data
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'In the OpenTracing section, we will discuss the following:'
  prefs: []
  type: TYPE_NORMAL
- en: An introduction to the tracing domain
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Configuration properties ...
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: MicroProfile Metrics
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: MicroProfile Metrics exposes the metric data (often called **telemetry**) of
    the running server, for example, CPU and memory usage, and the thread count. This
    data is then often fed into charting systems to visualize metrics over time or
    to serve capacity-planning purposes; of course, they also serve to notify DevOps
    people when the values go outside a predefined threshold range.
  prefs: []
  type: TYPE_NORMAL
- en: The Java Virtual Machine had a way to expose data for a long time via MBeans
    and the MBeanServer. Java SE 6 saw the introduction of an (RMI-based) remote protocol
    for all VMs defining how to access the MBean Server from remote processes. Dealing
    with this protocol is difficult and does not fit in with today's HTTP-based interactions.
  prefs: []
  type: TYPE_NORMAL
- en: The other pain point is that many globally existing servers have different properties
    exposed under different names. It is thus not easy to set up monitoring of different
    kinds of server.
  prefs: []
  type: TYPE_NORMAL
- en: MicroProfile has created a monitoring specification that addresses these two
    points via an HTTP-based API permitting access by monitoring agents and a Java
    API that allows application-specific metrics to be exported on top of a set of
    servers and JVM metrics.
  prefs: []
  type: TYPE_NORMAL
- en: MicroProfile Metrics is developing the 2.x version of the specification that
    has some breaking changes to 1.x. The following sections talk about 1.x – the
    changes in 2.0 are discussed in the *New in MP-Metrics 2.0* section.
  prefs: []
  type: TYPE_NORMAL
- en: 'The specification defines three scopes for metrics:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Base: These are metrics, mostly JVM statistics, that every compliant vendor
    has to support.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Vendor: Optional vendor-specific metrics that are not portable.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Application: Optional metrics from deployed applications. The Java API will
    be shown in the *Supplying application-specific metrics* section.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Another issue with the classic JMX approach, which MicroProfile Metrics addresses,
    is the lack of metadata information about the semantics of a metric.
  prefs: []
  type: TYPE_NORMAL
- en: Metadata
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Metadata is a very important part of MicroProfile Metrics. While it is possible
    to expose a metric `foo` with a value of `142`, it is not self-describing. An
    operator seeing that metric can't tell what this is about, what the unit is, and
    whether `142` is a good value or not.
  prefs: []
  type: TYPE_NORMAL
- en: 'Metadata is used to provide units and also a description of the metric so that
    the preceding could now be `foo: runtime; 142` seconds. This now allows for correct
    scaling on the display to *two minutes and 22 seconds*. And the user receiving
    an alert relating to this metric can understand that it refers to some runtime
    timing.'
  prefs: []
  type: TYPE_NORMAL
- en: Retrieving metrics from the server
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: MicroProfile Metrics exposes metrics via a REST interface, by default, under
    the `/metrics` context root. You can find the code at [https://github.com/PacktPublishing/Hands-On-Enterprise-Java-Microservices-with-Eclipse-MicroProfile/tree/master/Chapter05-metrics](https://github.com/PacktPublishing/Hands-On-Enterprise-Java-Microservices-with-Eclipse-MicroProfile/tree/master/Chapter05-metrics).
    Follow the `README.md` file to build the code, run it, and hit the [http://localhost:8080/book-metrics/hello](http://localhost:8080/book-metrics/hello)
    and [http://localhost:8080/book-metrics](http://localhost:8080/book-metrics) endpoints
    a few times with your browser to generate some data.
  prefs: []
  type: TYPE_NORMAL
- en: As of MicroProfile 1.3/2.0, there is nothing in the specifications about securing
    that endpoint. This is thus left to the individual implementation.
  prefs: []
  type: TYPE_NORMAL
- en: 'Using this REST interface, it is easy to retrieve the data, for example, via
    the following `curl` command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'This command shows the Metrics 1.x output in Prometheus text format (abbreviated):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: If you do not provide a media type, the default output format is the Prometheus
    text format (which can also be rendered nicely in the browser). The Prometheus
    format exposes additional metadata to the values in the `# TYPE` and `# HELP`
    lines. You can also see in the previous example how the scopes (base, vendor,
    and application) are prepended to the actual metrics name.
  prefs: []
  type: TYPE_NORMAL
- en: 'Alternatively, it is possible to retrieve data in the JSON format by providing
    an `HAccept` header (again abbreviated):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'This command results in the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'In this case, the pure data is exposed; the scopes form a top level, and respective
    metrics are nested inside. Matching metadata can be retrieved via an HTTP `XOPTIONS`
    call:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'The output now contains the metadata as a map:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: Now that we have seen how we can retrieve different types of data and metadata,
    we will have a quick look at how we can limit retrieval to specific scopes.
  prefs: []
  type: TYPE_NORMAL
- en: Accessing specific scopes
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'It is also possible to retrieve data for only a single scope by appending the
    scope name to the path. In the following example, we only retrieve metrics for
    the base scope:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'This now only shows metrics for the base scope:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: In this section, we have seen how to retrieve metrics from a MicroProfile Metrics-enabled
    server. Metrics in base and vendor scopes are predefined by the server. Metrics
    in the application scope can be defined by the user, which we are going to explore
    in the next section. ...
  prefs: []
  type: TYPE_NORMAL
- en: Supplying application-specific metrics
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Applications can choose to expose metric data via a CDI programming model. This
    model was inspired by DropWizard Metrics, so that it is easier to transition applications
    to MP-Metrics. It also uses the annotations from DropWizard Metrics, which have
    been augmented to support metadata.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s start with an example by defining a counter that is then incremented
    in code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'In this example, we are registering a counter by getting it injected into the
    `hCount` variable:'
  prefs: []
  type: TYPE_NORMAL
- en: The `@Metric` annotation provides additional information, such as the description,
    and also indicates that the name is the variable name without an additional package
    (`absolute=true`).
  prefs: []
  type: TYPE_NORMAL
- en: 'In the following example, we let the implementation do the counting for us.
    This implements the common use case of counting the number of invocations of a
    method or REST endpoint:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: The `monotonic` attribute of `@Counted` says to keep increasing the counter,
    otherwise it will be decreased when leaving the method.
  prefs: []
  type: TYPE_NORMAL
- en: More types of metric
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Counters are only one type of metric that can be exposed and, very often, more
    complex types are needed, for example, to record the distribution of the duration
    of method calls.
  prefs: []
  type: TYPE_NORMAL
- en: Let's have a quick look at these. Most follow the pattern of `@Counted`.
  prefs: []
  type: TYPE_NORMAL
- en: Gauges
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'A gauge is a metric whose value arbitrarily goes up and down. Gauges are always
    backed by a method that supplies the value of the gauge:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: The gauge's value is computed, like all other values, when a client requests
    the values. This requires the implementation of the gauge method to be very quick,
    so that a caller is not blocked.
  prefs: []
  type: TYPE_NORMAL
- en: Meter
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'A meter measures the rate at which the decorated method is called over time.
    For a JAX-RS endpoint, this would be the number of requests per second. Meters
    can be declared via an annotation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: When a client requests the data from the meter, the server supplies the mean
    rate, as well as one-, five-, and fifteen-minute moving averages. The latter may
    be familiar to some readers from the Unix/Linux `uptime` command.
  prefs: []
  type: TYPE_NORMAL
- en: Histograms
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'A histogram is a type of metric that samples the distribution of data. It is
    mostly used to record the distribution of the time it takes to execute the decorated
    method. Histograms cannot be declared via dedicated annotation, unlike other types,
    but a timer, for example, includes histogram data. To use a histogram on its own,
    you need to register and update it in code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: This way of using metrics in code is feasible for the other types as well.
  prefs: []
  type: TYPE_NORMAL
- en: Timers
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'A timer basically is a combination of a histogram and a meter and can again
    be declared via an annotation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: The code in this example waits for a small random amount of time to make the
    output a bit more interesting.
  prefs: []
  type: TYPE_NORMAL
- en: Tagging
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Tags or labels are a way to additionally organize information. These became
    popular with Docker and Kubernetes. Within MicroProfile Metrics 1.x, they are
    directly forwarded to the output without further ado and do not serve to distinguish
    metrics. MicroProfile Metrics supports server-wide and per-metrics tags, which
    are then merged together in the output.
  prefs: []
  type: TYPE_NORMAL
- en: Server-wide tags
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Server-wide tags are set via the environment variable, `MP_METRICS_TAGS`, as
    shown:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: These tags will be added to all metrics defined in the server and also added
    to the respective output format.
  prefs: []
  type: TYPE_NORMAL
- en: 'So, given the preceding command, a counter, `@Counted(absolute=true) int myCount;`,
    would end up in Prometheus as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: Per-metrics tags
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Tags can also be supplied on a per-metric basis:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: This example defines two labels, `version=v1` and `commit=abcde`, on the metric
    with the name `doSomething`. Those will be merged with the global tags for the
    output. With the preceding global tag, there would thus be three tags in the output.
  prefs: []
  type: TYPE_NORMAL
- en: In this section, we have seen how to add labels to metrics to provide additional
    metadata. These can be global, for all metrics exposed from a server, or application-specific,
    for one single metric.
  prefs: []
  type: TYPE_NORMAL
- en: Using Prometheus to retrieve metrics
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now that we have seen what metrics are exposed and how we can define our own,
    let's have a look at how we can collect them in a **time series database** (**TSDB**).
    For this purpose, we use Prometheus, a CNCF ([https://www.cncf.io/](https://www.cncf.io/))
    project that has gained widespread adoption in the cloud-native world.
  prefs: []
  type: TYPE_NORMAL
- en: You can download Prometheus from [https://prometheus.io](https://prometheus.io/)
    or on macOS via `brew install prometheus`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Once Prometheus is downloaded, we need a configuration file that defines which
    targets to scrape and can then start the server. For our purposes, we will use
    the following simple file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: New in MP-Metrics 2.0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'NOTE: MicroProfile Metrics 2.0 may not be released when you read this, and
    the content may have changed slightly depending on feedback from early users/implementors.'
  prefs: []
  type: TYPE_NORMAL
- en: Change for counters – introducing ConcurrentGauge
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Counters in Metrics 1.x had two functions:'
  prefs: []
  type: TYPE_NORMAL
- en: To provide a measure for the number of concurrent invocations
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: As a metric that can count up to the number of transactions committed, for example
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Unfortunately, the first way was the default when using the annotation without
    specifying the `monotonic` keyword, which is unexpected and was confusing a lot
    of users. The second version of this also had its issues, as a counter value could
    also decrease at will, which violates the understanding that a counter is a monotonically
    increasing metric.
  prefs: []
  type: TYPE_NORMAL
- en: For this reason, the Metrics working group has decided to change the behavior
    of counters so they only work as monotonically increasing metrics and to defer
    the ...
  prefs: []
  type: TYPE_NORMAL
- en: Tagging
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Tags now also serve to distinguish metrics with the same name and type, but
    different tags. They could be used to support many metrics `result_code` on a
    REST endpoint to count the number of (un)successful calls:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: Under the covers, metrics are no longer only keyed by name and type, but also
    by their tags. For this, new `MetricID` has been introduced to host the name and
    the tags.
  prefs: []
  type: TYPE_NORMAL
- en: Changes in data output format
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The introduction of multi-tag metrics in MicroProfile Metrics 2.0 necessitated
    changes in the format of metric data that is made available to clients.
  prefs: []
  type: TYPE_NORMAL
- en: 'The Prometheus format also had some inconsistencies, so we decided to revamp
    the formats in sometimes incompatible ways:'
  prefs: []
  type: TYPE_NORMAL
- en: The colon (:) as a separator between the scope and metric name has been changed
    to an underscore (_).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The Prometheus output format no longer requires that camelCase is turned into
    snake_case.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The format of the base metrics for garbage collectors has changed and now uses
    tags for the various garbage collectors.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Please consult the release notes in the MicroProfile 2.0 specification at [https://github.com/eclipse/microprofile-metrics/releases/tag/2.0
    ...](https://github.com/eclipse/microprofile-metrics/releases/tag/2.0)
  prefs: []
  type: TYPE_NORMAL
- en: MicroProfile OpenTracing
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the modern world of microservices, a single request can traverse multiple
    processes running on different machines, data centers, or even geographical regions.
  prefs: []
  type: TYPE_NORMAL
- en: The observability of such systems is a challenging task but, when done right,
    it allows us to *tell the story* about each individual request as opposed to the
    overall state of the system derived from signals such as metrics and logs. In
    this chapter, we will introduce you to distributed tracing and explain OpenTracing
    with its integration in MicroProfile OpenTracing 1.3.
  prefs: []
  type: TYPE_NORMAL
- en: In the previous section, we learned about metrics and how they observe an application
    or each individual component. This information is no doubt very valuable and provides
    a macro view of the system, but, at the same time, it says very little about each
    individual request that traverses multiple components. Distributed tracing shows
    a micro view of what happened with a request end to end so that we can retrospectively
    understand the behavior of each individual component of the application.
  prefs: []
  type: TYPE_NORMAL
- en: 'Distributed tracing is action-based; in other words, it records everything
    related to an action in the system. For example, it captures detailed information
    of a request and all causally related activities. We will not go through the details
    of how this tracing works, but, in a nutshell, we can state the following:'
  prefs: []
  type: TYPE_NORMAL
- en: The tracing infrastructure attaches contextual metadata to each request, typically,
    a set of unique IDs – `traceId`, `spanId`, and `parentId`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The instrumentation layer records profiling data and propagates metadata inside
    and between processes.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The captured profiling data contains metadata and causality references to preceding
    events.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Based on the captured data, distributed tracing systems usually offer the following
    functionality:'
  prefs: []
  type: TYPE_NORMAL
- en: Root-cause analysis
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Latency optimization – critical path analysis
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Distributed context propagation – baggage
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Contextualized logging
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Service dependency analysis
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Before we delve into MicroProfile OpenTracing, let's briefly look at OpenTracing
    so that we can better understand what the API offers.
  prefs: []
  type: TYPE_NORMAL
- en: OpenTracing project
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The OpenTracing project ([https://opentracing.io](https://opentracing.io/))
    provides a vendor-neutral specification [(https://github.com/opentracing/specification)](https://github.com/opentracing/specification) and
    polyglot APIs for describing distributed transactions. Vendor neutrality is important
    because code instrumentation is the most time-consuming and challenging task when
    enabling distributed tracing in large organizations. We would like to stress that
    OpenTracing is just an API. A real deployment will require a plugged tracer implementation
    that runs inside the monitored process and sends data to a tracing system.
  prefs: []
  type: TYPE_NORMAL
- en: 'From an API perspective, there are three key concepts: Tracer, Span, and SpanContext.
    Tracer is a singleton object available to the application that can be used to
    model a ...'
  prefs: []
  type: TYPE_NORMAL
- en: Configuration properties
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: OpenTracing is vendor-neutral and can, therefore, work with any vendor's tracing
    implementation that uses this API. Each tracer implementation will be configured
    differently. Therefore, the configuration is outside the scope of the MicroProfile
    OpenTracing specification. However, the specification itself exposes a couple
    of configuration properties to adjust the tracing scope or generated data. The
    configuration leverages the MicroProfile Config specification to provide a consistent
    means for all supported configuration options.
  prefs: []
  type: TYPE_NORMAL
- en: 'Currently, the specification exposes the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '`mp.opentracing.server.skip-pattern`: A skip pattern to avoid the tracing of
    selected REST endpoints.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`mp.opentracing.server.operation-name-provider`: This specifies the operation
    name provider for server spans. Possible values are `http-path` and `class-method`.
    The default value is `class-method`, which fully uses a qualified class name concatenated
    with a method name; for example, `GET:org.eclipse.Service.get`. The `http-path`
    uses a value of `@Path` annotation as an operation name.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Automatic instrumentation
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The motivation here is to have tracing automatically capture all crucial performance
    information and also automatically propagate tracing context between runtimes.
    The second part is especially crucial because it ensures that traces are not broken
    and we are able to investigate end-to-end invocation. For successful tracing,
    every communication technology between runtimes has to be instrumented. In the
    case of MicroProfile, it is JAX-RS and MicroProfile Rest Client.
  prefs: []
  type: TYPE_NORMAL
- en: JAX-RS
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: MicroProfile OpenTracing automatically traces all inbound JAX-RS endpoints.
    However, the JAX-RS client side is more tricky and requires the registration API, `org.eclipse.microprofile.opentracing.ClientTracingRegistrar.configure(ClientBuilder
    clientBuilder)`, to be called to add tracing capability. MicroProfile implementation
    can enable tracing for all client interfaces globally; however, it is recommended
    to use the registration API for better portability.
  prefs: []
  type: TYPE_NORMAL
- en: 'The default tracing behavior can be modified by disabling the tracing of specific
    requests or changing operation names of produced server spans. For more information,
    refer to the *Configuration properties* section later in this chapter. The instrumentation
    layer automatically adds the following request-scoped information to each span:'
  prefs: []
  type: TYPE_NORMAL
- en: '`http.method`: The HTTP method of the request.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`http.status_code`: The status code of the request.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`http.url`: The URL of the request.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`component`: The name of the instrumented component, `jaxrs`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`span.kind`: The client or server.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`error` – `true` or `false`. This is optional and, if present, instrumentation
    also adds an exception as `error.object` to span logs.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'All these tags can be used to query data via the tracing system user interface,
    or they can be used for data analytics jobs that many tracing systems provide.
    Additional metadata can be added to the current active span via an injected tracer
    instance. This can be conducted globally in filters or locally in rest handlers,
    as shown in the following code example, by adding a user agent header to the server
    span (1):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: By default, server-side spans have the operation name `http_method:package.className.method`.
    However, this can be changed locally by using the `@Traced` annotation (2), or
    globally via the configuration property (refer to the configuration section).
  prefs: []
  type: TYPE_NORMAL
- en: MicroProfile Rest Client
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As was mentioned in the previous section, all REST client interfaces are, by
    default, automatically traced with no additional configuration required. This
    behavior can be changed by applying the `@Traced` annotation to the interface
    or method to disable tracing. When applied to the interface, all methods are skipped
    from tracing. Note that the tracing context is not being propagated. Therefore,
    if the request continues to an instrumented runtime, a new trace is started.
  prefs: []
  type: TYPE_NORMAL
- en: Explicit instrumentation
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Sometimes, the automatic instrumentation does not capture all critical timing
    information and, therefore, additional trace points are needed. For example, we
    would like to trace an invocation of a business layer or initialize third-party
    instrumentation provided by the OpenTracing project ([https://github.com/opentracing-contrib](https://github.com/opentracing-contrib)).
  prefs: []
  type: TYPE_NORMAL
- en: 'The explicit instrumentation can be done in three ways:'
  prefs: []
  type: TYPE_NORMAL
- en: Add the `@Traced` annotation on **Context and Dependency Injection** (**CDI**)
    beans.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Inject the tracer and create spans manually.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Initialize third-party instrumentation. The initialization of external instrumentation
    depends on its own initialization requirements. MicroProfile just has to provide
    a tracer instance, which is covered in the previous bullet point.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Let's now discuss these in detail.
  prefs: []
  type: TYPE_NORMAL
- en: '@Traced annotation'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: MicroProfile OpenTracing defines an `@Traced` annotation that can be used to
    enable tracing on CDI beans or disable tracing on automatically traced interfaces.
    The annotation can also be used to override the operation name on other automatically
    traced components – JAX-RS endpoints.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following code example shows how the `@Traced` annotation can be used to
    enable tracing on a CDI bean. `(1)` enables tracing for all methods the bean defines.
    `(2)` overrides the default operation name (`package.className.method`) to `get_all_users`.
    `(3)` disables tracing of the health method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: Tracer injection
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The application can inject an `io.opentracing.Tracer` bean that exposes the
    full OpenTracing API. This allows application developers to leverage more advanced
    use cases, such as adding metadata to the currently active span, manually creating
    spans, using baggage for context propagation, or initializing additional third-party
    instrumentation.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following code shows how the tracer is used to attach data to the currently
    active span, `(1)`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: This can be useful for adding business-related data to spans, but also to log
    exceptions or any other profiling information.
  prefs: []
  type: TYPE_NORMAL
- en: Tracing with Jaeger
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: So far, we have only talked about different aspects of the instrumentation.
    However, to run the full tracing infrastructure, we need a tracing backend. In
    this section, we will use Jaeger ([https://www.jaegertracing.io/](https://www.jaegertracing.io/))
    to demonstrate how collected tracing data is presented in a tracing system. We
    have chosen Jaeger because Thorntail provides direct integration with Jaeger.
    Other vendors can provide integrations with other systems, for instance, Zipkin,
    and Instana. Almost every tracing system offers a Gannt chart style view (or timeline)
    of a trace. This view might be overwhelming for tracing novices, but it is a great
    tool to systematically analyze an invocation in a distributed system.
  prefs: []
  type: TYPE_NORMAL
- en: The following screenshot shows ...
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we learned about the observability of servers and applications.
  prefs: []
  type: TYPE_NORMAL
- en: Metrics, or telemetry, can help to pinpoint the performance characteristics
    of a server or an application. MicroProfile offers, via the Metrics specification,
    a way to export Metrics in standardized ways. Application writers can use MicroProfile
    Metrics to expose their data to monitoring clients decoratively via annotations
    or via calls to the Metrics API.
  prefs: []
  type: TYPE_NORMAL
- en: The chapter further explained how OpenTracing integration in MicroProfile provides
    an end-to-end view for each individual transaction going through the system. We
    went through the configuration properties, showcasing tracing for JAX-RS, and
    finally investigating data in the Jaeger system.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will learn how to document (REST) APIs via OpenAPI and
    call those APIs via the type-safe REST client.
  prefs: []
  type: TYPE_NORMAL
- en: Questions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: What is the difference between distributed tracing and metrics?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What functionality do distributed tracing systems usually provide?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What parts of the system are automatically traced in MicroProfile OpenTracing?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Which tags are added for every REST request by MicroProfile OpenTracing?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How can explicit instrumentation be added to the business code?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What are scopes in Metrics and what is their rationale?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What determines the output format of a REST request to the Metrics API?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What ways are available to export metrics within a user application?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
