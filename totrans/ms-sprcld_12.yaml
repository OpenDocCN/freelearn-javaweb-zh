- en: Securing an API
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Security is one of the most commonly discussed problems related to microservices-based
    architecture. There is always one main problem for all security concerns—a network.
    With microservices, where typically there is much more communication over the
    network than there is for monolithic applications, the approach to authentication
    and authorization should be reconsidered. Traditional systems are usually secured
    at the border and then allow the frontend service full access to the backend components.
    The migration to microservices forces us to change this approach to delegated-access
    management.
  prefs: []
  type: TYPE_NORMAL
- en: How does Spring Framework address the security concerns of microservices-based
    architecture? It provides several projects that implement different patterns regarding
    authentication and authorization. The first of these is Spring Security, which
    is a de facto standard for secure Spring-based Java applications. It consists
    of a few submodules that help you get started with SAML, OAuth2, or Kerberos.
    There is also the Spring Cloud Security project. It provides several components
    that allow you to integrate basic Spring Security features with the main elements
    of microservices architecture, such as gateways, load balancers, and REST HTTP
    clients.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, I'm going to show you how to secure all the main components
    of your microservices-based system. I will describe the particular elements relevant
    to the topic in the order of the chapters that compose the second part of this
    book. So, we would begin from service discovery with Eureka, then move on to the
    Spring Cloud Config Server and inter-service communication, and then finally discuss
    API gateway security.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here''s what we will look at in this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: Configuring a secure connection for a single Spring Boot application
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Enabling HTTPS communication for the most important elements of microservice-based
    architecture
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Encrypting and decrypting property values in configuration files stored on Config
    Server
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Simple in-memory based authentication with OAuth2 for microservices
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: More advanced OAuth2 configuration with JDBC backend store and JWT tokens
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using OAuth2 authorization in inter-service communication with Feign client
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: But first, let's begin with the basics. I'll show you how to create your first
    secure microservice that exposes an API over HTTPS.
  prefs: []
  type: TYPE_NORMAL
- en: Enabling HTTPS for Spring Boot
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'If you want to use SSL and serve your RESTful APIs over HTTPS, you will need
    to generate a certificate. The fastest way to achieve this is through a self-signed
    certificate, which is enough for development mode. JRE provides a simple tool
    for certificate management—`keytool`. It is available under your `JRE_HOME\bin`
    directory. The command in the following code generates a self-signed certificate
    and puts it into the PKCS12 KeyStore. Besides KeyStore''s type, you will also
    have to set its validity, alias, and the name of the file. Before starting the
    generation process, `keytool` will ask you for your password and some additional
    information, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'I have copied the generated certificate into the `src/main/resources` directory
    inside the Spring Boot application. After building and running the application,
    it will be available on the classpath. To enable SSL, we have to provide some
    configuration settings in the `application.yml` file. SSL can be customized for
    Spring by setting the various `server.ssl.*` properties:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: Secure discovery
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As you can see, the configuration of SSL for a microservice application is not
    a very hard task. However, it is time to increase the difficulty level. We have
    already launched a single microservice that serves a RESTful API over HTTPS. Now
    we want that microservice to integrate with the discovery server. There are two
    problems that arise from this. The first of these is the need to publish information
    about the secure microservice's instance in Eureka. The second of these concerns
    exposing Eureka over HTTPS and forcing the discovery client to authenticate against
    a discovery server using a private key. Let's discuss these issues in detail.
  prefs: []
  type: TYPE_NORMAL
- en: Registering a secure application
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'If your application is exposed over a secure SSL port, you should change two
    flags from the `EurekaInstanceConfig`—`nonSecurePortEnabled` to `false` and `securePortEnabled`
    to `true`. This forces Eureka to publish instance information that shows an explicit
    preference for secure communication. The Spring Cloud `DiscoveryClient` will always
    return a URL starting with HTTPS for a service that is configured this way, and
    the Eureka instance information will have a secure health check URL:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: Serving Eureka over HTTPS
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When the Eureka server starts with Spring Boot, it is deployed on an embedded
    Tomcat container, so the SSL configuration is the same as for the standard microservice.
    The difference is that we must take account of the client-side application, which
    establishes a secure connection with a discovery server over HTTPS. The discovery
    client should authenticate itself against the Eureka server and it should also
    verify the server's certificate. That communication process between client and
    server is called **two-way SSL** or **mutual authentication**. There is also one-way
    authentication, which is in fact the default option, where only the client validates
    the server's public key. Java applications use KeyStore and trustStore for storing
    private keys and certificates corresponding to public keys. The only difference
    between trustStore and KeyStore is what they store and for what purpose. When
    an SSL handshake between client and server is performed, a trustStore is used
    to verify the credentials, while a KeyStore is used to provide credentials. So
    in other words, a KeyStore keeps a private key and certificate for a given application,
    while a trustStore keeps the certificates that are used to identify it from the
    third party. Developers often do not pay much attention to those terms when configuring
    a secure connection, but a proper understanding of them helps you to easily understand
    what will happen next.
  prefs: []
  type: TYPE_NORMAL
- en: 'In a typical microservices-based architecture, there are plenty of independent
    applications and a single discovery server. Every application has its own private
    key stored in a KeyStore and a certificate corresponding to a discovery server''s
    public key in a trustStore. On the other hand, the server keeps all the certificates
    generated for the client-side applications. That''s enough theory for now. Let''s
    take a look at the following figure. It illustrates the current situation of our
    system that was used as an example in the previous chapters:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/4bdd8fff-ba4d-4694-82b7-5cd6658b7582.png)'
  prefs: []
  type: TYPE_IMG
- en: Keystore generation
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'After discussing the basics regarding security in Java, we may proceed to the
    generation of private and public keys for our microservices. Just like before,
    we will use the command-line tool provided under JRE—`keytool`. Let''s begin with
    a well-known command for generating a `keystore` file with a key pair. One KeyStore
    is generated for a discovery server, and a second for the one selected microservice,
    in this particular case, for `account-service`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, the self-signed certificate has to be exported from a KeyStore to a file—for
    example, with a `.cer` or `.crt` extension. You will then be prompted for the
    password you provided during the KeyStore''s generation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'The certificate corresponding to the public key has been extracted from the
    KeyStore, so now it can be distributed to all interested parties. The public certificate
    from `account-service` should be included in the discovery server''s trustStore
    and vice-versa:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'The same steps that were performed for `account-service `have to be repeated
    for each subsequent microservice that registers itself in the Eureka server. Here
    are the keytool''s commands used for generating SSL keys and certificates for
    `order-service`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: Configurating SSL for microservices and Eureka server
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Each `keystore` file has been placed in the `src/main/resources` directory
    of every secure microservice and service discovery. The SSL configuration settings
    of every microservice are very similar to those from the example in the section
    titled *Enabling HTTPS for Spring Boot*. The only difference is the type of currently
    used KeyStore, which is now JKS instead of PKCS12\. However, there are more differences
    between the earlier sample and the service discovery configuration. First, I have
    enabled client certificate authentication by setting the `server.ssl.client-auth` property to
    `need`. This in turn requires us to provide a trustStore with the `server.ssl.trust-store`
    property. Here are the current SSL configuration settings in `application.yml`
    for `discovery-service`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'If you run the Eureka application with the preceding configuration and then
    try to visit its web dashboard available under `https://localhost:8761/`, you
    will probably get an error code like `SSL_ERROR_BAD_CERT_ALERT`. This error occurs
    because there is no trusted certificate imported to your web browser. For this
    purpose, we may import one of the client''s application KeyStores, from `account-service`,
    for example. But first, we need to convert it from JKS format to another format
    supported by a web browser, such as PKCS12\. Here''s the `keytool` command for
    the conversion of KeyStore from JKS to PKCS12 format:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'PKCS12 is supported by all the most popular web browsers, such as Google Chrome
    and Mozilla Firefox. You can import a PKCS12 KeyStore to Google Chrome by navigating
    to the section Settings *|* Show advanced settings... | HTTPS/SSL *|* Manage certificates.
    If you try to visit the Eureka web dashboard one more time, you should be authenticated
    successfully, and you will be able to see the list of registered services. However,
    there will be no application registered there. In order to provide secure communication
    between the discovery clients and the server, we need to create a `@Bean` of a `DiscoveryClientOptionalArgs` type for
    every microservice, which overwrites the discovery client''s implementation. What
    is interesting is that Eureka uses Jersey as a REST client. With `EurekaJerseyClientBuilder`,
    we may easily build a new client implementation and pass the `keystore` and `truststore`
    file''s location. The following is the code fragment from `account-service`, where
    we create a new `EurekaJerseyClient` object and set it as an argument of `DiscoveryClientOptionalArgs`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'A similar implementation should be provided for every microservice in our sample
    system. A sample application source code is available on GitHub ([https://github.com/piomin/sample-spring-cloud-security.git](https://github.com/piomin/sample-spring-cloud-security.git)).
    You may clone it and run all the Spring Boot applications with your IDE. If everything
    works, you should see the same list of registered services in the Eureka dashboard
    as you can see in the following screenshot. In case of any problem with the SSL
    connection, try and set the `-Djava.net.debug=ssl` VM argument during the boot
    of the application to be able to check out the full logs from the SSL handshake
    process:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/450b5cda-04ec-455d-acc3-8fc21cf2d768.png)'
  prefs: []
  type: TYPE_IMG
- en: Secure configuration server
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: There is one other key element in our architecture that should be considered
    during our discussion about security—the Spring Cloud Config Server. I would say
    that it is even more important to protect the config server than the discovery
    service. Why? Because we usually store their authentication credentials to the
    external systems, along with other data that should be hidden from unauthorized
    access and usage. There are several ways to properly secure your config server.
    You may configure an HTTP basic authentication, a secure SSL connection, encrypt/decrypt
    sensitive data, or use third-party tools such as those already described in [Chapter
    5](37142825-02d0-48a0-99df-1a1a88a1bbd4.xhtml), Distributed Configuration with
    Spring Cloud Config. Let's take a closer look at some of them.
  prefs: []
  type: TYPE_NORMAL
- en: Encryption and decryption
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Before we begin, we have to download and install the **Java Cryptography Extension**
    (**JCE**) provided by Oracle. It consists of two JAR files (`local_policy.jar`
    and `US_export_policy.jar`), which need to override the existing policy files
    in the JRE lib/security directory.
  prefs: []
  type: TYPE_NORMAL
- en: If the remote property sources stored on the config server contain encrypted
    data, their values should be prefixed with `{cipher}` and wrapped in quotes to
    designate it as a YAML file. Wrapping in quotes is not necessary for `.properties`
    files. If such a value cannot be decrypted, it is replaced by an additional value
    (usually `<n/a>`) under the same key prefixed with `invalid`.
  prefs: []
  type: TYPE_NORMAL
- en: In our last sample, we stored the passphrase used for protecting the `keystore`
    file in the application configuration settings. Keeping it there as a plain text
    file may not be the best idea, so it is the first candidate for encryption. The
    question is, how do we encrypt it? Fortunately, Spring Boot provides two RESTful
    endpoints that can help with that.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s see how it works. First, we need to start a config server instance.
    The simplest way for this is to activate the `--spring.profiles.active=native` profile,
    which launches the server with the property sources from the local classpath or
    filesystem. Now we may call two POST endpoints `/encrypt` and `/decrypt`. The
    `/encrypt` method takes our plain-text password as an argument. The result can
    be checked out using an inverse operation, `/decrypt`, which takes an encrypted
    password as a parameter:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'The encryption is done with the public key, while the decryption is done with
    the private key. Therefore, you need to provide only the public key in the server
    if you perform just the encryption. For testing purposes, we can create the KeyStore
    using `keytool`. We have already created some KeyStores before, so you will not
    have any problems with that. The generated file should be placed in the classpath
    and then in the `config-service` configuration settings using `encrypt.keyStore.*`
    properties:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, if you move the configuration settings of each microservice to the config
    server, you can encrypt every password, as shown in the following sample fragment:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: Configuring authentication for a client and a server
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The implementation of authentication for Spring Cloud Config Server looks exactly
    the same as for the Eureka server. We can use an HTTP basic authentication basing
    on standard Spring security mechanisms. First, we need to make sure that the `spring-security`
    artifact is on the classpath. Then we should enable security with `security.basic.
  prefs: []
  type: TYPE_NORMAL
- en: 'enabled` set to `true` and define a username and password. The sample configuration
    settings are visible in the following code fragment:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'The basic authentication must also be enabled on the client side. It can be
    realized in two different ways. The first of these is via the config server URL:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'The second approach is based on separate `username` and `password` properties:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: If you would like to set up SSL authentication, you need to follow the steps
    described in the section titled *Secure discovery*. After generating the KeyStores
    with private keys and certificates and setting the proper configuration, we may
    run the config server. Now, it is exposing its RESTful API over HTTPS. The only
    difference is in the implementation on the client side. This is because Spring
    Cloud Config uses a different HTTP client than Spring Cloud Netflix Eureka. As
    you may probably guess, it leverages `RestTemplate`, as it is entirely created
    within the Spring Cloud project.
  prefs: []
  type: TYPE_NORMAL
- en: 'To force the client-side application to use two-way SSL authentication instead
    of a standard, nonsecure HTTP connection, first we should create a `@Configuration`
    bean implementing the `PropertySourceLocator` interface. There, we may build a
    custom `RestTemplate` that uses a secure HTTP connection factory:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'However, by default, this bean would not be created before the application
    tries to establish a connection with the config server. To change this behavior,
    we should also create the `spring.factories` file in `/src/main/resources/META-INF`
    and specify the custom bootstrap configuration class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: Authorization with OAuth2
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We have already discussed some concepts and solutions related to authentication
    in a microservices environment. I have shown you the examples of basic and SSL
    authentication between microservices and a service discovery, and also between
    microservices and a config server. In inter-service communication, authorization
    seems to be more important then authentication, which is instead implemented on
    the edge of the system. It's worth understanding the difference between authentication
    and authorization. Simply put, authentication verifies who you are, while authorization
    verifies what you are authorized to do.
  prefs: []
  type: TYPE_NORMAL
- en: Currently the most popular authorization methods for RESTful HTTP APIs are OAuth2
    and **Java Web Tokens** (**JWT**). They may be mixed together as they are rather
    more complementary than other solutions. Spring provides support for OAuth providers
    and consumers. With Spring Boot and Spring Security OAuth2, we may quickly implement
    common security patterns, such as single sign-on, token relay, or token exchange.
    But before we dive into the details regarding those projects, as well as other
    development details, we need to acquire a basic knowledge of the preceding solution.
  prefs: []
  type: TYPE_NORMAL
- en: Introduction to OAuth2
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'OAuth2 is the standard currently used by almost all major websites that allow
    you to access their resources through a shared API. It delegates user authentication
    to an independent service that stores user credentials and authorizes third-party
    applications to access shared information about users'' accounts. OAuth2 is used
    for giving your users access to data while protecting their account credentials.
    It provides flows for web, desktop, and mobile applications. The following are
    some basic terms and roles related to OAuth2:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Resource owner**: This role governs access to the resource. This access is
    limited by the scope of the granted authorization.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Authorization grant**: This grants permission for access. There are various
    ways you may choose to confirm access—authorization code, implicit, resource-owner
    password credentials, and client credentials.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Resource server**: This is a server that stores the owner’s resources that
    can be shared using a special token.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Authorization server**: This manages the allocation of keys, tokens, and
    other temporary resource access codes. It also has to ensure that access is granted
    to the relevant user.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Access token**: This is a key that allows access to a resource.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'In order to better understand what these terms and roles are in practice, take
    a look at the following diagram. It visualizes a typical flow of the authorization
    process using the OAuth protocol:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/fb8ff8a6-c870-4ff5-a776-a7f0aedcc84a.png)'
  prefs: []
  type: TYPE_IMG
- en: Let's run through the further steps of interaction between the individual components
    listed previously. The application requests authorization from the resource owner
    in order to be able to access the requested service. The resource sends an authorization
    grant as the response, which is then sent by the application, together with its
    own identity, to the authorization server. The authorization server verifies the
    application identity's credentials and authorization grant, and then sends an
    access token back. The application requests the resource from the resource server
    using a received access token. Finally, if the access token is valid, the application
    is able to invoke the request service.
  prefs: []
  type: TYPE_NORMAL
- en: Building an authorization server
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'After moving from monolithic applications to microservices, the obvious solution
    seems to be the centralization of the authorization effort by creating an authorization
    service. With Spring Boot and Spring Security, you may easily create, configure,
    and launch an authorization server. First, we need to include the following `starters`
    to the project dependencies:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: The implementation of an authorization server pattern with Spring Boot is very
    easy. We just have to annotate the main class or the configuration class with
    `@EnableAuthorizationServer` and then provide `security.oauth2.client.client-id`
    and `security.oauth2.client.client-secret` properties in the `application.yml`
    file. Of course, this variant is as simple as possible, since it defines an in-memory
    implementation of the client details service.
  prefs: []
  type: TYPE_NORMAL
- en: 'A sample application is available in the same repository as the previous samples
    in this chapter ([https://github.com/piomin/sample-spring-cloud-security.git](https://github.com/piomin/sample-spring-cloud-security.git)),
    but in a different branch, `oauth2` ([https://github.com/piomin/sample-spring-cloud-security/tree/oauth2](https://github.com/piomin/sample-spring-cloud-security/tree/oauth2)).
    The authorization server is available under the `auth-service` module. Here''s
    the main class of `auth-service`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'Here is the fragment of the application''s configuration settings. In addition
    to the client''s ID and secret, I have also set its default scope and enabled
    basic security for the whole project:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'After running our authorization service, we may perform some tests. For example,
    we may call the `POST /oauth/token` method in order to create an access token
    using resource owner password credentials, just like in the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'We may also use an authorization code grant type by calling the `GET /oauth/authorize`
    endpoint from your web browser:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'After that, you will be redirected to the approval page. You may confirm the
    action and finally get your access token. It will be sent to the callback URL
    passed in the `redirect_uri` parameter of the initial request. Here''s the sample
    response that I received after my test:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: '![](img/7e5e41f0-0bd3-4691-aea9-a93b0ecf709a.png)'
  prefs: []
  type: TYPE_IMG
- en: 'The same OAuth2 configuration that was provided within the `application.yml`
    file can be also implemented programatically. In order to achieve this, we should
    declare any `@Beans` that implements `AuthorizationServerConfigurer`. One of these
    is the `AuthorizationServerConfigurerAdapter` adapter, which provides empty methods,
    allowing you to create custom definitions of the following separated configurers:'
  prefs: []
  type: TYPE_NORMAL
- en: '`ClientDetailsServiceConfigurer`: This defines the client details service.
    Client details can be initialized, or you can just refer to an existing store.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`AuthorizationServerSecurityConfigurer`: This defines the security constraints
    on the token endpoints `/oauth/token_key` and `/oauth/check_token`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`AuthorizationServerEndpointsConfigurer`: This defines the authorization and
    token endpoints and the token services.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'This approach to the authorization server implementation gives us many more
    opportunities. For example, we may define more than one client with an ID and
    a secret, as shown in the following code fragment. I''ll show you some more advanced
    samples in the next part of this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'The last thing that has to be configured for our authorization server is web
    security. In the class extending `WebSecurityConfigurerAdapter`, we have defined
    an in-memory user credentials store and permissions to access specific resources,
    such as a login page:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: Client configuration
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Your application can use the OAuth2 client that is configured in two different
    ways. The first of these ways is through the `@EnableOAuth2Client` annotation,
    which creates a filter bean with an ID of `oauth2ClientContextFilter` that is
    responsible for storing the request and context. It also manages communication
    between your application and an authorization server. However, we will be looking
    at the second approach to OAuth2's client-side implementation, through `@EnableOAuth2Sso`.
    **Single sign-on** (**SSO**) is a well-known security pattern that allows a user
    to use one set of login credentials to access multiple applications. There are
    two features provided by this annotation—the OAuth2 client and the authentication.
    The authentication piece aligns your application with the typical Spring Security
    mechanisms, such as a form login. The client piece has the same functionality
    as that provided by `@EnableOAuth2Client`. So, we may think of `@EnableOAuth2Sso`
    as just a higher level annotation than `@EnableOAuth2Client`.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the following sample code fragment, I have annotated the class that extends
    `WebSecurityConfigurerAdapter` with `@EnableOAuth2Sso`. Thanks to this extension,
    Spring Boot configures the security filter chain that carries the OAuth2 authentication
    processor. In this case, requests to the `/login` page are permitted, while all
    other requests require authentication. The form login page path may be overridden
    with the `security.oauth2.sso.login-path` property. After overriding it there,
    we should also remember to change the path pattern inside `WebSecurityConfig`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'There are also some configuration settings that need to be set. First, we should
    disable basic authentication, because we use the form login method enabled together
    with the `@EnableOAuth2Sso` annotation. Then, we have to provide some basic OAuth2
    client properties, such as client credentials and the addresses of the HTTP API
    endpoints exposed by the authorization server:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'The last property from the fragment of the `application.yml` file is `security.oauth2.resource.userInfoUri`,
    which requires an additional endpoint on the server side. The endpoint implemented
    by `UserController` returns the `java.security.Principal` object, indicating the
    currently authenticated user:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: Now, if you invoke any endpoint exposed by one of our microservices, you will
    be automatically redirected to the login page. Since we set an `autoApprove` option for
    our in-memory clients' details store, the authorization grant and access token
    are generated automatically without any interaction from the user. After providing
    your credentials in the login page, you should get the response from the requested
    resource.
  prefs: []
  type: TYPE_NORMAL
- en: Using the JDBC backend store
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the previous sections, we configured an authentication server and client
    application, which grants access to the resources protected by the resource server.
    However, the whole authorization server configuration has been provided inside
    in-memory storage. Such a solution meets our needs during development, but it
    is not the most desirable approach in production mode. The target solution should
    store all the authentication credentials and tokens in the database. We may choose
    between many relational databases supported by Spring. In this case, I have decided
    to use MySQL.
  prefs: []
  type: TYPE_NORMAL
- en: 'So, the first step is to start the MySQL database locally. The most comfortable
    way to achieve this is through a Docker container. In addition to starting the
    database, the following command also creates a schema and a user called `oauth2`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'Once we have started MySQL, we now have to provide the connection settings
    on the client side. MySQL is available under the host address `192.168.99.100`
    if you run Docker on a Windows machine and on port `33306`. Data source properties
    should be set in the `application.yml` of `auth-service`. Spring Boot is also
    able to run some SQL scripts on the selected data source on the application''s
    startup. It''s good news for us because we have to create some tables on the schema
    dedicated for our OAuth2 process:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'The created schema contains some tables used for storing OAuth2 credentials
    and tokens—`oauth_client_details`, `oauth_client_token`, `oauth_access_token`,
    `oauth_refresh_token`, `oauth_code`, and `oauth_approvals`. The full script with
    SQL -creation commands is available inside `/src/main/resources/script/schema.sql`.
    There is also a second SQL script, `/src/main/resources/script/data.sql`, with
    some `insert` commands for test purposes. The most important thing is to add some
    client ID/client secret pairs:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'There are some differences in implementation between the current version of
    the authentication server and the version described in the basic example. The
    first important thing here is to set the default token storage to a database by
    providing a `JdbcTokenStore` bean with the default data source as a parameter.
    Although all tokens are now stored in a database, we still want to generate them
    in JWT format. That''s why the second bean, `JwtAccessTokenConverter`, has to
    be provided in that class. By overriding different `configure` methods inherited
    from the base class, we can set a default storage for OAuth2 client details and
    configure the authorization server to always verify the API key submitted in HTTP
    headers:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'The Spring application provides a custom authentication mechanism. To use it
    in the application, we must implement the `UserDetailsService` interface and override
    its `loadUserByUsername` method. In our example application, user credentials
    and authorities are also stored in the database, so we inject the `UserRepository`
    bean to the custom `UserDetailsService` class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: Inter-service authorization
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Inter-service communication in our sample is realized using Feign clients.
    Here''s one of the chosen implementations—in this case, from `order-service`—which
    calls the endpoint from `customer-service`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'In the same way as with the other services, all the available methods from
    `customer-service` are protected by the preauthorization mechanism based on the
    OAuth token scope. It allows us to annotate every method with `@PreAuthorize`,
    defining the required scope:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'Preauthorization is disabled by default. To enable it for API methods, we should
    use the `@EnableGlobalMethodSecurity` annotation. We should also indicate that
    such a preauthorization will be based on the OAuth2 token scope:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'If you call the account service endpoint via the Feign client, you get the
    following exception:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'Why does such an exception occur? Of course, `customer-service` is protected
    with a OAuth2 token authorization, but the Feign client does not send an authorization
    token in the request header. That approach may be customized by defining a custom
    configuration class for the Feign client. It allows us to declare a request interceptor.
    In that case, we can use an implementation for OAuth2 provided by `OAuth2FeignRequestInterceptor`
    from the Spring Cloud OAuth2 library. For test purposes, I decided to use a resource
    owner password grant type:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, we may test the implemented solution. This time, we will create a
    JUnit automated test instead of clicking it in a web browser or sending requests
    using other tools. The test method is shown in the following code snippet. We
    use `OAuth2RestTemplate` with `ResourceOwnerPasswordResourceDetails` to perform
    a resource owner credentials grant operation and call the `POST /` API method
    from `order-service` with an OAuth2 token sent in the request header. Of course,
    before running that test, you have to start all the microservices, as well as
    the discovery and authorization server:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: Enabling SSO on the API gateway
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'You may enable the single sign-on feature on the API gateway just by annotating
    the main class with `@EnableOAuth2Sso`. Indeed, that is the best choice for your
    microservices architecture to force Zuul to generate or get the access token for
    the currently authenticated user:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: By including `@EnableOAuth2Sso`, you trigger an auto-configuration available
    for a ZuulFilter. The filter is responsible for extracting an access token from
    the currently authenticated user, and then putting it into the request header
    forwarded to the microservices hidden behind the gateway. If `@EnableResourceServer`
    is activated for those services, they will receive the expected token in the `Authorization`
    HTTP header. The authorization behavior downstream of an `@EnableZuulProxy` may
    be controlled by declaring `proxy.auth.*` properties.
  prefs: []
  type: TYPE_NORMAL
- en: 'When using a gateway in your architecture, you may hide an authorization server
    behind it. In this case, you should provide the additional route in Zuul''s configuration
    settings—for example, `uaa`. Then, all the messages exchanged between OAuth2 clients
    and the server go through the gateway. Here''s the proper configuration in the
    gateway''s `application.yml` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: There wouldn't have been anything wrong if I had included a security section
    in every single chapter from part two of this book. But I have decided to create
    a dedicated chapter on this subject in order to show you a step-by-step process
    of how to secure the key elements of a microservices-based architecture. The topics
    related to security are usually more advanced than other topics, so I took a bit
    more time to explain some of the basic concepts around the field. I have shown
    you samples illustrating a two-way SSL authentication, encryption/decryption of
    sensitive data, Spring Security authentication, and OAuth2 authorization with
    JWT tokens. I will leave it to you to decide which of them should be used in your
    system architecture to provide your desired level of security.
  prefs: []
  type: TYPE_NORMAL
- en: After reading this chapter, you should be able to set up both the basic and
    the more advanced security configurations for your application. You should also be
    able to secure every component of your system's architecture. Of course, we have
    discussed only some of the possible solutions and frameworks. For example, you
    don't have to only rely on Spring as an authorization server provider. We may
    use third-party tools, such as Keycloak, which can act as an authorization and
    authentication server in a microservices-based system. It can also easily be integrated
    with Spring Boot applications. It provides support for all the most popular protocols,
    such as OAuth2, OpenId Connect, and SAML. So, in fact, Keycloak is a very powerful
    tool, and should be treated as an alternative to the Spring Authorization Server,
    especially for large, corporate systems and other more advanced use cases.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter we will discuss the different strategies of microservices
    testing.
  prefs: []
  type: TYPE_NORMAL
