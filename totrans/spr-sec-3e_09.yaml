- en: Client Certificate Authentication with TLS
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Although username and password authentication is extremely common, as we discussed
    in [Chapter 1](01.html), *Anatomy of an Unsafe Application*, and in [Chapter 2](02.html),
    *Getting Started with Spring Security*, forms of authentication exist that allow
    users to present different types of credentials. Spring Security caters to these
    requirements as well. In this chapter, we'll move beyond form-based authentication
    to explore authentication using trusted client-side certificates.
  prefs: []
  type: TYPE_NORMAL
- en: 'During the course of this chapter, we will cover the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Learning how client certificate authentication is negotiated between the user's
    browser and a compliant server
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Configuring Spring Security to authenticate users with client certificates
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Understanding the architecture of client certificate authentication in Spring
    Security
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Exploring advanced configuration options related to client certificate authentication
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Reviewing pros, cons, and common troubleshooting steps when dealing with client
    certificate authentication
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How does client certificate authentication work?
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Client certificate authentication requires a request for information from the
    server and a response from the browser to negotiate a trusted authentication relationship
    between the client (that is, a user's browser) and the server application. This
    trusted relationship is built through the use of the exchange of trusted and verifiable
    credentials, known as **certificates**.
  prefs: []
  type: TYPE_NORMAL
- en: Unlike much of what we have seen up to this point, with client certificate authentication,
    the servlet container or application server itself is typically responsible for
    negotiating the trust relationship between the browser and server by requesting
    a certificate, evaluating it, and accepting it as valid.
  prefs: []
  type: TYPE_NORMAL
- en: Client certificate authentication is also known as **mutual authentication**
    and is part of the **Secure Sockets Layer** (**SSL**) protocol and its successor,
    **Transport Layer Security** (**TLS**). As mutual authentication is part of the
    SSL and TLS protocols, it follows that an HTTPS connection (secured with SSL or
    TLS) is required in order to make use of client certificate authentication. For
    more details on SSL/TLS support in Spring Security, please refer to our discussion
    and the implementation of SSL/TLS in the Appendix, *Additional Reference Material*.
    Setting up SSL/TLS in Tomcat (or the application server you have been using to
    follow along with the examples) is required to implement client certificate authentication.
    As in the Appendix, *Additional Reference Material* we will refer to SSL/TLS as
    SSL for the remainder of this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following sequence diagram illustrates the interaction between the client
    browser and the web server when negotiating an SSL connection and validating the
    trust of a client certificate used for mutual authentication:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/0ddcd0e7-34ef-4a68-b891-1191cd9d6418.png)'
  prefs: []
  type: TYPE_IMG
- en: 'We can see that the exchange of two certificates, the server and client certificates,
    provides the authentication that both parties are known and can be trusted to
    continue their conversation securely. In the interest of clarity, we omit some
    details of the SSL handshake and trust the checking of the certificates themselves;
    however, you are encouraged to do further reading in the area of the SSL and TLS
    protocols, and certificates in general, as many good reference guides on these
    subjects exist. *RFC 5246*, *The Transport Layer Security (TLS) Protocol Version
    1.2* ([http://tools.ietf.org/html/rfc5246](http://tools.ietf.org/html/rfc5246)),
    is a good place to begin reading about client certificate presentation, and if
    you''d like to get into more detail, *SL and TLS: Designing and Building Secure
    Systems, Eric Rescorla, Addison-Wesley* ([https://www.amazon.com/SSL-TLS-Designing-Building-Systems/dp/0201615983](https://www.amazon.com/SSL-TLS-Designing-Building-Systems/dp/0201615983))
    has an incredibly detailed review of the protocol and its implementation.'
  prefs: []
  type: TYPE_NORMAL
- en: An alternative name for client certificate-based authentication is X.509 authentication.
    The term X.509 is derived from the X.509 standard, originally published by the
    ITU-T organization for use in directories based on the X.500 standard (the origins
    of LDAP, as you may recall from [Chapter 6](07.html), *LDAP Directory Services*).
    Later, this standard was adapted for use in securing internet communications.
  prefs: []
  type: TYPE_NORMAL
- en: We mention this here because many of the classes in Spring Security related
    to this subject refer to X.509\. Remember that X.509 doesn't define the mutual
    authentication protocol itself, but defines the format and structure of the certificates
    and the encompassing trusted certificate authorities instead.
  prefs: []
  type: TYPE_NORMAL
- en: Setting up the client certificate authentication infrastructure
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Unfortunately for you as an individual developer, being able to experiment with
    client certificate authentication requires some non-trivial configuration and
    setup prior to the relatively easy integration with Spring Security. As these
    setup steps tend to cause a lot of problems for first-time developers, we felt
    it was important to walk you through them.
  prefs: []
  type: TYPE_NORMAL
- en: We assume that you are using a local, self-signed server certificate, self-signed
    client certificates, and Apache Tomcat. This is typical of most development environments;
    however, it's possible that you may have access to a valid server certificate,
    a **certificate authority** (**CA**), or another application server. If this is
    the case, you may use these setup instructions as guidelines and configure your
    environment in an analogous manner. Please refer to the SSL setup instructions
    in the Appendix, *Additional Reference Material* for assistance on configuring
    Tomcat and Spring Security to work with SSL in a standalone environment.
  prefs: []
  type: TYPE_NORMAL
- en: Understanding the purpose of a public key infrastructure
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This chapter focuses on setting up a self-contained development environment
    for the purposes of learning and education. However, in most cases where you are
    integrating Spring Security into an existing client certificate-secured environment,
    there will be a significant amount of infrastructure (usually a combination of
    hardware and software) in place to provide functionality, such as certificate
    granting and management, user self-service, and revocation. Environments of this
    type define a public key infrastructure-a combination of hardware, software, and
    security policies that result in a highly secure authentication-driven network
    ecosystem.
  prefs: []
  type: TYPE_NORMAL
- en: In addition to being used for web application authentication, certificates or
    hardware devices in these environments can be used for secure, non-repudiated
    email (using S/MIME), network authentication, and even physical building access
    (using PKCS 11-based hardware devices).
  prefs: []
  type: TYPE_NORMAL
- en: While the management overhead of such an environment can be high (and requires
    both IT and process excellence to implement well), it is arguably one of the most
    secure operating environments possible for technology professionals.
  prefs: []
  type: TYPE_NORMAL
- en: Creating a client certificate key pair
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The self-signed client certificate is created in the same way as the self-signed
    server certificate is created-by generating a key pair using the `keytool` command.
    A client certificate key pair differs in that it requires the key store to be
    available to the web browser and requires the client's public key to be loaded
    into the server's trust store (we'll explain what this is in a moment).
  prefs: []
  type: TYPE_NORMAL
- en: 'If you do not wish to generate your own key right now, you may skip to the
    next section and use the sample certificates in the `./src/main/resources/keys`
    folder in the sample chapter. Otherwise, create the client key pair, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: You can find additional information about `keytool`, along with all of the configuration
    options, at Oracle's site, here [http://docs.oracle.com/javase/8/docs/technotes/tools/unix/keytool.html/keytool.html](http://docs.oracle.com/javase/8/docs/technotes/tools/unix/keytool.html/keytool.html).
  prefs: []
  type: TYPE_NORMAL
- en: 'Most of the arguments to `keytool` are fairly arbitrary for this use case.
    However, when prompted to set up the first and last name (the common name, or
    CN, the portion of the owner''s DN) for the client certificate, ensure that the
    answer to the first prompt matches a user that we have set up in our Spring Security
    JDBC store. For example, `admin1@example.com` is an appropriate value since we
    have the `admin1@example.com` user setup in Spring Security. An example of the
    command-line interaction is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: We'll see why this is important when we configure Spring Security to access
    the information from the certificate-authenticated user. We have one final step
    before we can set up certificate authentication within Tomcat, which is explained
    in the next section.
  prefs: []
  type: TYPE_NORMAL
- en: Configuring the Tomcat trust store
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Recall that the definition of a key pair includes both a private and public
    key. Similar to SSL certificates verifying and securing server communication,
    the validity of the client certificate needs to be verified by the certifying
    authority that created it.
  prefs: []
  type: TYPE_NORMAL
- en: As we have created our own self-signed client certificate using the `keytool`
    command, the Java VM will not implicitly trust it as having been assigned by a
    trusted certificate authority.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s take a look at the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: We will need to force Tomcat to recognize the certificate as a trusted certificate.
    We do this by exporting the public key from the key pair and adding it to the
    Tomcat trust store.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Again, if you do not wish to perform this step now, you can use the existing
    trust store in `.src/main/resources/keys` and skip to where we configure `server.xml`
    later in this section.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'We''ll export the public key to a standard certificate file named `jbcp_clientauth.cer`,
    as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, we''ll import the certificate into the trust store (this will create
    the trust store, but in a typical deployment scenario you''d probably already
    have some other certificates in the trust store):'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding command will create the trust store called `tomcat.truststore`
    and prompt you for a password (we chose the password `changeit`). You''ll also
    see some information about the certificate and will finally be asked to confirm
    that you do trust the certificate, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: Remember the location of the new `tomcat.truststore` file, as we will need to
    reference it in our Tomcat configuration.
  prefs: []
  type: TYPE_NORMAL
- en: What's the difference between a key store and a trust store?
  prefs: []
  type: TYPE_NORMAL
- en: The **Java Secure Socket Extension** (**JSSE**) documentation defines a key
    store as a storage mechanism for private keys and their corresponding public keys.
    The key store (containing key pairs) is used to encrypt or decrypt secure messages,
    and so on. The trust store is intended to store only public keys for trusted communication
    partners when verifying an identity (similar to how the trust store is used in
    certificate authentication). In many common administration scenarios, however,
    the key store and trust store are combined into a single file (in Tomcat, this
    would be done through the use of the `keystoreFile` and `truststoreFile` attributes
    of the connector). The format of the files themselves can be exactly the same.
    Really, each file can be any JSSE-supported keystore format, including **Java
    KeyStore** (**JKS**), PKCS 12, and so on.
  prefs: []
  type: TYPE_NORMAL
- en: As previously mentioned, we assume you have already configured the SSL Connector,
    as outlined in the Appendix, *Additional Reference Material*. If you do not see
    the `keystoreFile` or `keystorePass` attributes in `server.xml`, it means you
    should visit the Appendix, *Additional Reference Material* to get SSL set up.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Finally, we''ll need to point Tomcat at the trust store and enable client certificate
    authentication. This is done by adding three additional attributes to the SSL
    connector in the Tomcat `server.xml` file, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: The `server.xml` file can be found at `TOMCAT_HOME/conf/server.xml`. If you
    are interacting with Tomcat using Eclipse or Spring Tool Suite, you will find
    a project named `Servers` that contains `server.xml`. For example, if you are
    using Tomcat 8, the path in your Eclipse workspace might look something similar
    to `/Servers/Tomcat v7.0 Server` at `localhost-config/server.xml`.
  prefs: []
  type: TYPE_NORMAL
- en: 'This should be the remaining configuration required to trigger Tomcat to request
    a client certificate when an SSL connection is made. Of course, you will want
    to ensure you replace both `<CERT_PATH>` and `<KEYSTORE_PATH>` with the full paths.
    For example, on a Unix-based operating system, the path might look like this:
    `/home/mickknutson/packt/chapter8/keys/tomcat.keystore`.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Go ahead and try to start up Tomcat to ensure that the server starts up without
    any errors in the logs.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: There's also a way to configure Tomcat to optionally use client certificate
    authentication-we'll enable this later in the chapter. For now, we require the
    use of client certificates to even connect to the Tomcat server in the first place.
    This makes it easier to diagnose whether or not you have set this up correctly!
  prefs: []
  type: TYPE_NORMAL
- en: Configuring Tomcat in Spring Boot
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We can also configure the embedded Tomcat instance within Spring Boot, which
    is how we will be working with Tomcat for the rest of this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: 'Configuring Spring Boot to use our newly created certificates is as straightforward
    as properties of the YAML entry, as shown in the following code snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: The final step is to import the certificate into the client browser.
  prefs: []
  type: TYPE_NORMAL
- en: Importing the certificate key pair into a browser
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Depending on what browser you are using, the process of importing a certificate
    may differ. We will provide instructions for installations of Firefox, Chrome,
    and Internet Explorer here, but if you are using another browser, please consult
    its help section or your favorite search engine for assistance.
  prefs: []
  type: TYPE_NORMAL
- en: Using Firefox
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Perform the following steps to import the key store containing the client certificate
    key pair in Firefox:'
  prefs: []
  type: TYPE_NORMAL
- en: Click on Edit | Preferences.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Click on the Advanced button.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Click on the Encryption tab.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Click on the View Certificates button. The Certificate Manager window should
    open up.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Click on the Your Certificates tab.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Click on the Import... button.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Browse to the location where you saved the `jbcp_clientauth.p12` file and select
    it. You will need to enter the password (that is, `changeit`) that you used when
    you created the file.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The client certificate should be imported, and you should see it on the list.
  prefs: []
  type: TYPE_NORMAL
- en: Using Chrome
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Perform the following steps to import the key store containing the client certificate
    key pair in Chrome:'
  prefs: []
  type: TYPE_NORMAL
- en: Click on the wrench icon on the browser toolbar.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Select Settings.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Click on Show advanced settings....
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In the HTTPS/SSL section, click on the Manage certificates... button.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In the Your Certificates tab, click on the Import... button.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Browse to the location where you saved the `jbcp_clientauth.p12` file and select
    it.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: You will need to enter the password (that is, `changeit`) that you used when
    you created the file.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Click on OK.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Using Internet Explorer
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'As Internet Explorer is tightly integrated into the Windows OS, it''s a bit
    easier to import the key store. Let''s take a look at the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Double-click on the `jbcp_clientauth.p12` file in Windows Explorer. The Certificate
    Import Wizard window should open.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Click on Next and accept the default values until you are prompted for the certificate
    password.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Enter the certificate password (that is, `changeit`) and click Next.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Accept the default Automatically select the certificate store option and click
    Next.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Click on Finish.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'To verify that the certificate was installed correctly, you will need to perform
    another series of steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Open the Tools menu (*Alt* + *X*) in Internet Explorer.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Click on the Internet Options menu item.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Click on the Content tab.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Click on the Certificates button.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Click on the Personal tab, if it is not already selected. You should see the
    certificate listed here.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Wrapping up testing
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'You should now be able to connect to the JBCP calendar site using the client
    certificate. Navigate to `https://localhost:8443/`, taking care to use HTTPS and
    `8443`. If all is set up correctly, you should be prompted for a certificate when
    you attempt to access the site-in Firefox, the certificate is displayed as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/258c434d-cf14-459d-9507-fabe1c485e7c.png)'
  prefs: []
  type: TYPE_IMG
- en: You'll notice, however, that if you attempt to access a protected section of
    the site, such as the My Events section, you'll be redirected to the login page.
    This is because we haven't yet configured Spring Security to recognize the information
    in the certificate-at this point, the negotiation between the client and server
    has stopped at the Tomcat server itself.
  prefs: []
  type: TYPE_NORMAL
- en: You should start with the code from `chapter08.00-calendar`.
  prefs: []
  type: TYPE_NORMAL
- en: Troubleshooting client certificate authentication
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Unfortunately, if we said that getting client certificate authentication configured
    correctly for the first time-without anything going wrong-was easy, we'd be lying
    to you. The fact is, although this is a great and very powerful security apparatus,
    it is poorly documented by both the browser and web server manufacturers, and
    the error messages, when present, can be confusing at best and misleading at worst.
  prefs: []
  type: TYPE_NORMAL
- en: Remember that, at this point, we have not involved Spring Security in the equation
    at all, so a debugger will most likely not help you (unless you have the Tomcat
    source code handy). There are some common errors and things to check.
  prefs: []
  type: TYPE_NORMAL
- en: 'You aren''t prompted for a certificate when you access the site. There are
    many possible causes for this, and this can be the most puzzling problem to try
    to solve. Here are some things to check:'
  prefs: []
  type: TYPE_NORMAL
- en: Ensure that the certificate has been installed in the browser client you are
    using. Sometimes, you need to restart the whole browser (close all windows) if
    you attempted to access the site previously and were rejected.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Ensure you are accessing the SSL port for the server (typically `8443` in a
    development setup), and have selected the HTTPS protocol in your URL. The client
    certificates are not presented in insecure browser connections. Make sure the
    browser also trusts the server SSL certificate, even if you have to force it to
    trust a self-signed certificate.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Ensure you have added the `clientAuth` directive to your Tomcat configuration
    (or the equivalent for whatever application server you are using).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If all else fails, use a network analyzer or packet sniffer, such as Wireshark
    ([http://www.wireshark.org/](http://www.wireshark.org/)) or Fiddler2 ([http://www.fiddler2.com/](http://www.fiddler2.com/)),
    to review the traffic and SSL key exchange over the wire (check with your IT department
    first-many companies do not allow tools of this kind on their networks).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If you are using a self-signed client certificate, make sure the public key
    has been imported into the server's trust store. If you are using a CA-assigned
    certificate, make sure the CA is trusted by the JVM or that the CA certificate
    is imported into the server's trust store.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Internet Explorer, in particular, does not report details of client certificate
    failures at all (it simply reports a generic `Page Cannot be Displayed` error).
    Use Firefox for diagnosing if an issue you are seeing is related to client certificates
    or not.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Configuring client certificate authentication in Spring Security
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Unlike the authentication mechanisms that we have utilized thus far, the use
    of client certificate authentication results in the user's request being preauthenticated
    by the server. As the server (Tomcat) has already established that the user has
    provided a valid and trustworthy certificate, Spring Security can simply trust
    this assertion of validity.
  prefs: []
  type: TYPE_NORMAL
- en: An important component of the secure login process is still missing, that is,
    the authorization of the authenticated user. This is where our configuration of
    Spring Security comes in-we must add a component to Spring Security that will
    recognize the certificate authentication information from the user's HTTP session
    (populated by Tomcat), and then validate the presented credentials against the
    Spring Security `UserDetailsService` invocation. The invocation of `UserDetailsService`
    will result in the determination of whether the user declared in the certificate
    is known to Spring Security at all, and then it will assign `GrantedAuthority`
    as per the usual login rules.
  prefs: []
  type: TYPE_NORMAL
- en: Configuring client certificate authentication using the security namespace
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'With all of the complexity of LDAP configuration, configuring client certificate
    authentication is a welcome reprieve. If we are using the security namespace style
    of configuration, the addition of client certificate authentication is a simple
    one-line configuration change, added within the `HttpSecurity` declaration. Go
    ahead and make the following changes to the provided `SecurityConfig.java` configuration:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: Observe that the `.x509()` method references our existing `userDetailsService()`
    configuration. For simplicity, we use the `UserDetailsServiceImpl` implementation
    covered in [Chapter 5](05.html), *Authentication with Spring Data*. However, we
    could easily swap this out with any other implementation (that is, the LDAP or
    JDBC-based implementation covered in [Chapter 4](04.html), *JDBC-Based Authentication*).
  prefs: []
  type: TYPE_NORMAL
- en: After restarting the application, you'll again be prompted for a client certificate,
    but this time, you should be able to access areas of the site requiring authorization.
    You can see from the logs (if you have them enabled) that you have been logged
    in as the `admin1@example.com` user.
  prefs: []
  type: TYPE_NORMAL
- en: Your code should look like `chapter08.01-calendar`.
  prefs: []
  type: TYPE_NORMAL
- en: How does Spring Security use certificate information?
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'As previously discussed, Spring Security''s involvement in certificate exchange
    is to pick up information from the presented certificate and map the user''s credentials
    to a user service. What we did not see in the use of the `.x509()` method was
    the magic that makes this happen. Recall that when we set the client certificate
    up, a DN similar to an LDAP DN was associated with the certificate:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'Spring Security uses the information in this DN to determine the actual username
    of the principal and it will look for this information in `UserDetailsService`.
    In particular, it allows for the specification of a regular expression, which
    is used to match a portion of the DN established with the certificate, and the
    utilization of this portion of the DN as the principal name. The implicit, default
    configuration for the `.x509()` method would be as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: We can see that this regular expression would match the `admin1@example.com`
    value as the principal's name. This regular expression must contain a single matching
    group, but it can be configured to support the username and DN issuance requirements
    of your application. For example, if the DNs for your organization's certificates
    include the `email` or `userid` fields, the regular expression can be modified
    to use these values as the authenticated principal's name.
  prefs: []
  type: TYPE_NORMAL
- en: How Spring Security certificate authentication works
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s review the various actors involved in the review and evaluation of the
    client certificates and translation into a Spring Security-authenticated session,
    with the help of the following diagram:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/3aab8775-aafc-4781-891a-8e2680fc0d53.png)'
  prefs: []
  type: TYPE_IMG
- en: We can see that `o.s.s.web.authentication.preauth.x509.X509AuthenticationFilter`
    is responsible for examining the request of an unauthenticated user for the presentation
    of client certificates. If it sees that the request includes a valid client certificate,
    it will extract the principal using `o.s.s.web.authentication.preauth.x509.SubjectDnX509PrincipalExtractor`,
    using a regular expression matching the certificate owner's DN, as previously
    described.
  prefs: []
  type: TYPE_NORMAL
- en: Be aware that although the preceding diagram indicates that examination of the
    certificate occurs for unauthenticated users, a check can also be performed when
    the presented certificate identifies a different user than the one that was previously
    authenticated. This would result in a new authentication request using the newly
    provided credentials. The reason for this should be clear-any time a user presents
    a new set of credentials, the application must be aware of this and react in a
    responsible fashion by ensuring that the user is still able to access it.
  prefs: []
  type: TYPE_NORMAL
- en: 'Once the certificate has been accepted (or rejected/ignored), as with other
    authentication mechanisms, an `Authentication` token is built and passed along
    to `AuthenticationManager` for authentication. We can now review the very brief
    illustration of the `o.s.s.web.authentication.preauth.PreAuthenticatedAuthenticationProvider`
    handling of the authentication token:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/0703ce2b-53ab-47d8-870d-00788fe453ea.png)'
  prefs: []
  type: TYPE_IMG
- en: Though we will not go over them in detail, there are a number of other preauthenticated
    mechanisms supported by Spring Security. Some examples include Java EE role mapping
    (`J2eePreAuthenticatedProcessingFilter`), WebSphere integration (`WebSpherePreAuthenticatedProcessingFilter`),
    and Site Minder-style authentication (`RequestHeaderAuthenticationFilter`). If
    you understand the process flow of client certificate authentication, understanding
    these other authentication types is significantly easier.
  prefs: []
  type: TYPE_NORMAL
- en: Handling unauthenticated requests with AuthenticationEntryPoint
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Since `X509AuthenticationFilter` will continue processing the request if authentication
    fails, we'll need to handle situations where the user does not authenticate successfully
    and has requested a protected resource. The way that Spring Security allows developers
    to customize this is by plugging in a custom `o.s.s.web.AuthenticationEntryPoint`
    implementation. In a default form login scenario, `LoginUrlAuthenticationEntryPoint`
    is used to redirect the user to a login page if they have been denied access to
    a protected resource and are not authenticated.
  prefs: []
  type: TYPE_NORMAL
- en: 'In contrast, in typical client certificate authentication environments, alternative
    methods of authentication are simply not supported (remember that Tomcat expects
    the certificate well before the Spring Security form login takes place anyway).
    As such, it doesn''t make sense to retain the default behavior of redirection
    to a form login page. Instead, we''ll modify the entry point to simply return
    an `HTTP 403 Forbidden` message, using the `o.s.s.web.authentication.Http403ForbiddenEntryPoint`.
    Go ahead and make the following updates in your `SecurityConfig.java` file, as
    follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, if a user tries to access a protected resource and is unable to provide
    a valid certificate, they will be presented with the following page, instead of
    being redirected to the login page:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/27b77e5f-5478-4833-aa29-439e54efd47c.png)'
  prefs: []
  type: TYPE_IMG
- en: Your code should now look like `chapter08.02-calendar`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Other configuration or application flow adjustments that are commonly performed
    with client certificate authentication are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Removal of the form-based login page altogether
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Removal of the logout link (as there's no reason to log out because the browser
    will always present the user's certificate)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Removal of the functionality to rename the user account and change the password
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Removal of the user registration functionality (unless you are able to tie it
    into the issuance of a new certificate)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Supporting dual-mode authentication
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: It is also possible that some environments may support both certificate-based
    and form-based authentication. If this is the case in your environment, it is
    also possible (and trivial) to support it with Spring Security. We can simply
    leave the default `AuthenticationEntryPoint` interface (redirecting to the form-based
    login page) intact and allow the user to log in using the standard login form
    if they do not supply a client certificate.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you choose to configure your application this way, you''ll need to adjust
    the Tomcat SSL settings (change as appropriate for your application server). Simply
    change the `clientAuth` directive to `want`, instead of `true`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: We'll also need to remove the `authenticationEntryPoint()` method that we configured
    in the previous exercise, so that the standard form-based authentication workflow
    takes over if the user isn't able to supply a valid certificate upon the browser
    first being queried.
  prefs: []
  type: TYPE_NORMAL
- en: 'Although this is convenient, there are a few things to keep in mind about dual-mode
    (form-based and certificate-based) authentication, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Most browsers will not reprompt the user for a certificate if they have failed
    certificate authentication once, so make sure that your users are aware that they
    may need to reenter the browser to present their certificate again.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Recall that a password is not required to authenticate users with certificates;
    however, if you are still using `UserDetailsService` to support your form-based
    authenticated users, this may be the same `UserDetailsService` object that you
    use to give the `PreAuthenticatedAuthenticationProvider` information about your
    users. This presents a potential security risk, as users who you intend to sign
    in only with certificates could potentially authenticate using form login credentials.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'There are several ways to solve this problem, and they are described in the
    following list:'
  prefs: []
  type: TYPE_NORMAL
- en: Ensure that the users authenticating with certificates have an appropriately
    strong password in your user store.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Consider customizing your user store to clearly identify users who are enabled
    for form-based login. This can be tracked with an additional field in the table
    holding user account information, and with minor adjustments to the SQL queries
    used by the `JpaDaoImpl` object.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Configure a separate user details store altogether for users who are logging
    in as certificate-authenticated users, to completely segregate them from users
    that are allowed to use form-based login.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Dual-mode authentication can be a powerful addition to your site and can be
    deployed effectively and securely, provided that you keep in mind the situations
    under which users will be granted access to it.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Configuring client certificate authentication using Spring beans
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Earlier in this chapter, we reviewed the flow of the classes involved in client
    certificate authentication. As such, it should be straightforward for us to configure
    the JBCP calendar using explicit beans. By using the explicit configuration, we
    will have additional configuration options at our disposal. Let''s take a look
    and see how to use explicit configuration:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'We''ll also need to remove the `x509()` method and add `x509Filter` to our
    filter chain, and add our `AuthenticationProvider` implementation to `AuthenticationManger`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: Now, give the application a try. Nothing much has changed from a user perspective,
    but as developers, we have opened the door to a number of additional configuration
    options.
  prefs: []
  type: TYPE_NORMAL
- en: Your code should now look like `chapter08.03-calendar`.
  prefs: []
  type: TYPE_NORMAL
- en: Additional capabilities of bean-based configuration
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The use of Spring bean-based configuration provides us with additional capabilities
    through the exposure of bean properties that aren't exposed via the security namespace
    style of configuration.
  prefs: []
  type: TYPE_NORMAL
- en: 'Additional properties available on `X509AuthenticationFilter` are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Property** | **Description** | **Default** |'
  prefs: []
  type: TYPE_TB
- en: '| `continueFilterChainOn UnsuccessfulAuthentication` | If false, a failed authentication
    will throw an exception rather than allow the request to continue. This would
    typically be set in cases where a valid certificate is expected and required to
    access the secured site. If true, the filter chain will proceed, even if there
    is a failed authentication. | `true` |'
  prefs: []
  type: TYPE_TB
- en: '| `checkForPrincipalChanges` | If true, the filter will check to see if the
    currently authenticated username differs from the username presented in the client
    certificate. If so, authentication against the new certificate will be performed
    and the HTTP session will be invalidated (optionally, see the next attribute).
    If false, once the user is authenticated, they will remain authenticated even
    if they present different credentials. | `false` |'
  prefs: []
  type: TYPE_TB
- en: '| `invalidateSessionOn PrincipalChange` | If true, and the principal in the
    request changes, the user''s HTTP session will be invalidated prior to being reauthenticated.
    If false, the session will remain-note that this may introduce security risks.
    | `true` |'
  prefs: []
  type: TYPE_TB
- en: 'The `PreAuthenticatedAuthenticationProvider` implementation has a couple of
    interesting properties available to us, which are listed in the following table:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Property** | **Description** | **Default** |'
  prefs: []
  type: TYPE_TB
- en: '| `preAuthenticatedUser` `DetailsService` | This property is used to build
    a full `UserDetails` object from the username extracted from the certificate.
    | None |'
  prefs: []
  type: TYPE_TB
- en: '| `throwExceptionWhen` `TokenRejected` | If true, a `BadCredentialsException`
    exception will be thrown when the token is not constructed properly (does not
    contain a username or certificate). It is typically set to `true` in environments
    where certificates are used exclusively. | None |'
  prefs: []
  type: TYPE_TB
- en: In addition to these properties, there are a number of other opportunities for
    implementing interfaces or extending classes involved in certificate authentication
    to further customize your implementation.
  prefs: []
  type: TYPE_NORMAL
- en: Considerations when implementing client certificate authentication
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Client certificate authentication, while highly secure, isn't for everyone and
    isn't appropriate for every situation.
  prefs: []
  type: TYPE_NORMAL
- en: 'The pros of client certificate authentication are listed, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Certificates establish a framework of mutual trust and verifiability that both
    parties (client and server) are who they say they are
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Certificate-based authentication, if implemented properly, is much more difficult
    to spoof or tamper with than other forms of authentication
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If a well-supported browser is used and configured correctly, client certificate
    authentication can effectively act as a single sign-on solution, enabling transparent
    login to all certificate-secured applications
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The cons of client certificate authentication are listed, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: The use of certificates typically requires the entire user population to have
    them. This can lead to both a user training burden and an administrative burden.
    Most organizations deploying certificate-based authentication on a large scale
    must have sufficient self-service and helpdesk support for certificate maintenance,
    expiration tracking, and user assistance.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The use of certificates is generally an all-or-nothing affair, meaning that
    mixed-mode authentication and offering support for non-certificated users is not
    provided due to the complexity of web server configuration, or poor application
    support.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The use of certificates may not be well supported by all users in your user
    population, including the ones who use mobile devices.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The correct configuration of the infrastructure required to support certificate-based
    authentication may require advanced IT knowledge.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: As you can see, there are both benefits and drawbacks to client certificate
    authentication. When implemented correctly, it can be a very convenient mode of
    access for your users and has extremely attractive security and non-repudiation
    properties. You will need to determine your particular situation to see whether
    or not this type of authentication is appropriate.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we examined the architecture, flow, and Spring Security support
    for client certificate-based authentication. We have covered the concepts and
    overall flow of client certificate (mutual) authentication. We explored the important
    steps required to configure Apache Tomcat for a self-signed SSL and client certificate
    scenario.
  prefs: []
  type: TYPE_NORMAL
- en: We also learned about configuring Spring Security to understand certificate-based
    credentials presented by clients. We covered the architecture of Spring Security
    classes related to certificate authentication. We also know how to configure a
    Spring bean-style client certificate environment. We also covered the pros and
    cons of this type of authentication.
  prefs: []
  type: TYPE_NORMAL
- en: It's quite common for developers unfamiliar with client certificates to be confused
    by many of the complexities of this type of environment. We hope that this chapter
    has made this complicated subject a bit easier to understand and implement! In
    the next chapter, we will discuss how you can accomplish single sign-on with OpenID.
  prefs: []
  type: TYPE_NORMAL
