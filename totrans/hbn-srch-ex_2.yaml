- en: Chapter 2. Mapping Entity Classes
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In [Chapter 1](ch01.html "Chapter 1. Your First Application"), *Your First Application*,
    we used core Hibernate ORM to map an entity class to a database table, and then
    we used Hibernate Search to map two of its fields to a Lucene index. By itself,
    this provides a lot of search functionality that would be very cumbersome to code
    from scratch.
  prefs: []
  type: TYPE_NORMAL
- en: However, real-world applications usually involve numerous entities, many of
    which should be available for searching. Entities may be associated with each
    other, and our queries need to understand those associations so that we can search
    across multiple entities at once. We might want to declare that some mappings
    are more relevant to a search than others, or we might want to skip indexing data
    under certain conditions.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we will start to dive deeper into the options that Hibernate
    Search makes available for mapping entities. As a first step, we must take a look
    at the API options available in Hibernate ORM. How we map our entity classes to
    the database influences how Hibernate Search maps them to Lucene.
  prefs: []
  type: TYPE_NORMAL
- en: Choosing an API for Hibernate ORM
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'When the Hibernate Search documentation mentions different APIs for Hibernate
    ORM, it can be confusing. In some cases, this might refer to whether database
    queries are performed using an `org.hibernate.Session` or a `javax.persistence.EntityManager`
    object (an important part of the next chapter). However, in the context of entity
    mapping, this refers to the three different approaches offered by Hibernate ORM:'
  prefs: []
  type: TYPE_NORMAL
- en: Annotation-based mapping with classic Hibernate-specific annotations
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Annotation-based mapping with the Java Persistence API (JPA 2.0)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: XML-based mapping with `hbm.xml` files
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If you have only used Hibernate ORM with its classic annotations or XML-based
    mappings, or if you are new to Hibernate altogether, then this may be your first
    exposure to JPA. In a nutshell, JPA is a specification intended to serve as the
    official standard for object-relational mapping and similar features.
  prefs: []
  type: TYPE_NORMAL
- en: The idea is to provide for ORM what JDBC provides for low-level database connectivity.
    Once a developer has learned JDBC, they can quickly work with any database driver
    that implements the API (for example, Oracle, PostgreSQL, MySQL, and so on). Likewise,
    if you understand JPA, then you should be able to easily switch between ORM frameworks,
    such as Hibernate, EclipseLink, and Apache OpenJPA.
  prefs: []
  type: TYPE_NORMAL
- en: In practice, different implementations often have their own quirks and proprietary
    extensions, which can cause transition headaches. However, a common standard does
    reduce the pain and learning curve dramatically.
  prefs: []
  type: TYPE_NORMAL
- en: 'A comparison of using the Hibernate ORM native API versus using JPA for entity
    mapping is shown in the following diagram:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Choosing an API for Hibernate ORM](img/9205_01_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The good news for long-time Hibernate developers is that JPA entity mapping
    annotations are remarkably similar to Hibernate's own annotations. In fact, the
    founder of Hibernate worked on the committee that developed JPA, and these two
    APIs have strongly influenced each other.
  prefs: []
  type: TYPE_NORMAL
- en: The less-good news, depending on your perspective, is that Hibernate ORM 4.x
    deprecates its own mapping annotations in favor of their JPA counterparts. Those
    older annotations are targeted for removal in Hibernate ORM 5.x.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: It doesn't make sense to write a new code today using this deprecated approach,
    so we will disregard Hibernate-specific mapping annotations.
  prefs: []
  type: TYPE_NORMAL
- en: The third option, XML-based mapping, is still commonly found in legacy applications.
    It is falling out of favor, and the Hibernate Search documentation jokes about
    XML being unfit for the 21st century! Of course, that is somewhat tongue-in-cheek,
    considering that basic Hibernate configuration still lives in a `hibernate.cfg.xml`
    or `persistence.xml` file. Still, the clear trend with most Java frameworks is
    to use annotations for configuration that is tied to a particular class, and to
    use some form of text file for global configuration.
  prefs: []
  type: TYPE_NORMAL
- en: Even if you are using `hbm.xml` files to map your entities to the database,
    you can still use the Hibernate Search annotations to map those entities to Lucene
    indexes. The two are perfectly compatible. This is convenient if you want to add
    Hibernate Search to a legacy application with minimal effort, or if you have a
    philosophical preference for `hbm.xml` files even when developing new applications.
  prefs: []
  type: TYPE_NORMAL
- en: 'The sample code for this book includes three versions of the VAPORware Marketplace
    application for this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: The `chapter2` subdirectory continues where [Chapter 1](ch01.html "Chapter 1. Your
    First Application"), *Your First Application* left off, using JPA annotations
    for mapping entities to both the database and Lucene.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `chapter2-xml` subdirectory is a variant of the same code, modified to mix
    XML-based database mapping with JPA-based Lucene mapping.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `chapter2-mapping` subdirectory uses a special API to avoid annotations
    altogether. This is discussed further in the *Programmatic Mapping API* section
    near the end of this chapter.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You should explore all of this example code in detail to understand the available
    options. However, unless otherwise noted, the code examples in this book will
    focus on JPA annotations for both database and Lucene mapping.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: When JPA annotations are used for database mapping, Hibernate Search automatically
    creates a Lucene identifier for fields annotated with `@Id`.
  prefs: []
  type: TYPE_NORMAL
- en: For whatever reason, Hibernate Search cannot do the same with Hibernate ORM's
    own mapping API. So when you are not using JPA to map entities to the database,
    you must also add the `@DocumentId` annotation to fields that should be used as
    Lucene identifiers (entities are known as **documents** in Lucene terminology).
  prefs: []
  type: TYPE_NORMAL
- en: Field mapping options
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In [Chapter 1](ch01.html "Chapter 1. Your First Application"), *Your First Application*,
    we saw that member variables on a Hibernate-managed class are made searchable
    with the `@Field` annotation. Hibernate Search will put information about annotated
    fields into one or more Lucene indexes, using some sensible defaults.
  prefs: []
  type: TYPE_NORMAL
- en: 'However, you can customize indexing behavior in numerous ways, some of which
    are optional elements in the `@Field` annotation itself. Most of these elements
    will be explored further throughout this book, but we will briefly introduce them
    here in one centralized list:'
  prefs: []
  type: TYPE_NORMAL
- en: '`analyze`: This tells Lucene whether to store the field''s data as is, or put
    it through analysis, parsing, and processing it in various ways. It can be set
    to `Analyze.YES` (the default) or `Analyze.NO`. We will see this again in [Chapter
    3](ch03.html "Chapter 3. Performing Queries"), *Performing Queries*.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`index`: This controls whether or not the field should be indexed by Lucene.
    It can be set to `Index.YES` (the default) or `Index.NO`. It may sound nonsensical
    to use the `@Field` annotation and then not index the field, but this will make
    more sense after seeing projection-based searches in [Chapter 5](ch05.html "Chapter 5. Advanced
    Querying"), *Advanced Querying*.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`indexNullAs`: This declares how to handle null field values. By default, null
    values will simply be ignored and excluded from Lucene indexes. However, with
    this element fully covered in [Chapter 4](ch04.html "Chapter 4. Advanced Mapping"),
    *Advanced Mapping*, you can force null fields to be indexed with some default
    value instead.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`name`: This is a custom name, describing this field in the Lucene indexes.
    By default, Hibernate Search will use the name of the annotated member variable.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`norms`: This determines whether or not to store index-time information used
    for boosting, or adjusting the default relevance of search results. It can be
    set to `Norms.YES` (the default) or `Norms.NO`. Index-time boosting will appear
    in [Chapter 4](ch04.html "Chapter 4. Advanced Mapping"), *Advanced Mapping*.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`store`: Normally, fields are indexed in a manner optimized for searching,
    but this might not make it possible to retrieve the data in its original form.
    This option causes the raw data to be stored in such a way that you can later
    retrieve it directly from Lucene, rather than the database. It can be set to `Store.NO`
    (the default), `Store.YES`, or `Store.COMPRESS`. We will use this with projection-based
    searches in [Chapter 5](ch05.html "Chapter 5. Advanced Querying"), *Advanced Querying*.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Multiple mappings for the same field
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Sometimes, you need to use one set of options to do certain things with a field,
    and other set of options to do other things. We will see this later in [Chapter
    3](ch03.html "Chapter 3. Performing Queries"), *Performing Queries* when we make
    a field both searchable and sortable.
  prefs: []
  type: TYPE_NORMAL
- en: 'For the time being, suffice it to say that you can have as many custom mappings
    as you wish for the same field. Just include multiple `@Field` annotations, wrapped
    within the plural `@Fields`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: Don't worry too much about this example right now. Just note that when you create
    more than one mapping for the same field, you need to give them distinct names
    with the `name` element, so that you can later reference the correct mapping.
  prefs: []
  type: TYPE_NORMAL
- en: Mapping numeric fields
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In [Chapter 1](ch01.html "Chapter 1. Your First Application"), *Your First Application*,
    our entity mapping examples dealt exclusively with string properties. It is likewise
    perfectly fine to use the same `@Field` annotation with other basic data types
    as well.
  prefs: []
  type: TYPE_NORMAL
- en: However, fields mapped this way are indexed by Lucene in string format. That
    is very inefficient for techniques that we will explore later, such as sorting
    and querying over a range.
  prefs: []
  type: TYPE_NORMAL
- en: To improve the performance of such operations, Hibernate Search offers a specialized
    data structure for indexing numeric fields. This option is available when mapping
    fields of type `Integer`, `Long`, `Float`, and `Double` (or their primitive counterparts).
  prefs: []
  type: TYPE_NORMAL
- en: 'To use this optimized data structure for a numeric field, you simply add the
    `@NumericField` annotation in addition to the normal `@Field`. As an example,
    let''s give the `App` entity in our VAPORware Marketplace application a field
    for price:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: If you are applying this annotation to a property that has been mapped multiple
    times with `@Fields`, you must specify *which* of those mappings should use the
    specialized data structure. This is done by giving the `@NumericField` annotation
    an optional `forField` element, set to the same name as the desired `@Field`.
  prefs: []
  type: TYPE_NORMAL
- en: Relationships between entities
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Every time an entity class is annotated with `@Indexed`, by default Hibernate
    Search will create a Lucene index just for that class. We can have as many entities,
    and as many separate indexes, as we wish. However, searching each index separately
    would be a very awkward and cumbersome approach.
  prefs: []
  type: TYPE_NORMAL
- en: Most Hibernate ORM data models already capture the various associations between
    entity classes. When we search an entity's Lucene index, shouldn't Hibernate Search
    follow those associations? In this section we will see how to make it do just
    that.
  prefs: []
  type: TYPE_NORMAL
- en: Associated entities
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: So far, the entity fields in our example application have been simple data types.
    The `App` class represents a table named `APP`, and its member variables map to
    columns in that table. Now let's add a complex type field, for a second database
    table that is associated through a foreign key.
  prefs: []
  type: TYPE_NORMAL
- en: Online app stores usually support a range of different hardware devices. So
    we will create a new entity called `Device`, representing devices for which an
    `App` entity is available.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: Most details of this class should be familiar from [Chapter 1](ch01.html "Chapter 1. Your
    First Application"), *Your First Application*. `Device` is annotated with `@Entity`,
    so Hibernate Search will create a Lucene index just for it. The entity class contains
    searchable fields for device name, and manufacturer name.
  prefs: []
  type: TYPE_NORMAL
- en: However, the `supportedApps` member variable introduces a new annotation, for
    making the association between these two entities bidirectional. An `App` entity
    will contain a list of all its supported devices, and a `Device` entity will contain
    a list of all its supported apps.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: If for no other reason, using bidirectional associations improves the reliability
    of Hibernate Search.
  prefs: []
  type: TYPE_NORMAL
- en: A Lucene index contains denormalized data from associated entities, but those
    entities are still primarily tied to their own Lucene indexes. To cut a long story
    short, when the association between two entities is bidirectional, and changes
    are set to cascade, then you can count on both indexes being updated when either
    entity changes.
  prefs: []
  type: TYPE_NORMAL
- en: The Hibernate ORM reference manual describes several bidirectional mapping types
    and options. Here we are using `@ManyToMany`, to declare a many-to-many relationship
    between the `App` and `Device` entities. The `cascade` element is set to ensure
    that changes on this end of the association properly update the other side.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Normally, Hibernate is "lazy". It doesn't actually fetch associated entities
    from the database until they are needed.
  prefs: []
  type: TYPE_NORMAL
- en: However, here we are writing a multi-tiered application, and the controller
    servlet has already closed the Hibernate session by the time our search results
    JSP receives these entities. If a view tries to fetch associations after the session
    has closed, errors will occur.
  prefs: []
  type: TYPE_NORMAL
- en: There are several ways around this problem. For simplicity, we are also adding
    a `fetch` element to the `@ManyToMany` annotation, changing the fetch type from
    "lazy" to "eager". Now when we retrieve a Device entity, Hibernate will immediately
    fetch all the associated `App` entities while the session is still open.
  prefs: []
  type: TYPE_NORMAL
- en: Eager fetching is very inefficient with large amounts of data, however, so in
    [Chapter 5](ch05.html "Chapter 5. Advanced Querying"), *Advanced Querying*, we
    will explore a more advanced strategy for handling this.
  prefs: []
  type: TYPE_NORMAL
- en: Everything about `supportedApps` discussed so far has been in the realm of Hibernate
    ORM. So last but not least, we will add the Hibernate Search `@ContainedIn` annotation,
    declaring that `App`'s Lucene index should contain data from `Device`. Hibernate
    ORM already saw these two entities as being associated. The Hibernate Search `@ContainedIn`
    annotation sets up a bidirectional association from Lucene's perspective too.
  prefs: []
  type: TYPE_NORMAL
- en: The other half of the bidirectional association involves giving the `App` entity
    class a list of supported `Device` entity classes.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: This is very similar to the `Device` side of the association, except that the
    `@IndexedEmbedded` annotation here serves as the counterpoint to `@ContainedIn`.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: If your associated objects contain other associated objects themselves, then
    you might end up indexing a lot more data than you wanted. Even worse, you could
    run into problems with circular dependencies.
  prefs: []
  type: TYPE_NORMAL
- en: To safeguard against this, set the `@IndexEmbedded` annotation's optional `depth`
    element to a max limit. When indexing objects, Hibernate Search will go no further
    than the specified number of levels.
  prefs: []
  type: TYPE_NORMAL
- en: The previous code specifies a depth of one level. This means that an app will
    be indexed with information about its supported devices, but *not* information
    about a device's other supported apps.
  prefs: []
  type: TYPE_NORMAL
- en: Querying associated entities
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Once associated entities have been mapped for Hibernate Search, it is easy
    to include them in search queries. The following code snippet updates `SearchServlet`
    to add `supportedDevices` to the list of fields searched:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: Complex types are a bit different from the simple data types we have worked
    with so far. With complex types, we are not really interested in the field itself,
    because the field is actually just an object reference (or a collection of object
    references).
  prefs: []
  type: TYPE_NORMAL
- en: What we really want our searches to match are the simple data type fields within
    the complex type. In other words, we want to search the `Device` entity's `name`
    field. So, as long as an associated class field has been indexed (that is, with
    the `@Field` annotation), it can be queried with a [entity field].[nested field]
    format, such as `supportedDevices.name` in the previous code.
  prefs: []
  type: TYPE_NORMAL
- en: In the sample code for this chapter, `StartupDataLoader` has been expanded to
    save some `Device` entities in the database, and associate them with the `App`
    entities. One of these test devices is named xPhone. When we run the VAPORware
    Marketplace application and search for this keyword, the search results will include
    apps that are compatible with the xPhone, even if that keyword doesn't appear
    in the name or description of the app itself.
  prefs: []
  type: TYPE_NORMAL
- en: Embedded objects
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Associated entities are full-blown entities in their own right. They typically
    correspond to a database table and Lucene index of their own, and may stand apart
    from their associations. For example, if we delete an app entity that is supported
    on the xPhone, that doesn't mean we want to delete the xPhone `Device` too.
  prefs: []
  type: TYPE_NORMAL
- en: There is a different type of association, in which the lifecycle of associated
    objects depends on the entity that contains them. If the VAPORware Marketplace
    apps had customer reviews, and an app was permanently deleted from the database,
    then we would probably expect all its customer reviews to be removed along with
    it.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Classic Hibernate ORM terminology refers to such objects as **components** (or
    sometimes **elements** ). In the newer JPA jargon, they are known as **embedded
    objects**.
  prefs: []
  type: TYPE_NORMAL
- en: Embedded objects are not entities themselves. Hibernate Search does not create
    separate Lucene indexes for them, and they cannot be searched outside the context
    of the entity containing them. Otherwise, they look and feel quite similar to
    associated entities.
  prefs: []
  type: TYPE_NORMAL
- en: Let's give the example application an embedded object type for customer reviews.
    A `CustomerReview` instance will consist of the username of the person submitting
    the review, the rating they gave (for example, five stars), and any additional
    comments they wrote.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: This class is annotated with `@Embeddable` rather than the usual `@Entity` annotation,
    telling Hibernate ORM that the lifecycle of a `CustomerReview` instance is dependent
    on whichever entity object contains it.
  prefs: []
  type: TYPE_NORMAL
- en: The `@Field` annotation is applied to searchable fields as before. However,
    Hibernate Search will not create a standalone Lucene index just for `CustomerReview`.
    This annotation only adds information to the indexes of other entities that contain
    this embeddable class.
  prefs: []
  type: TYPE_NORMAL
- en: 'In our case, the containing class will be `App`. Let''s give it a set of customer
    reviews as a member variable:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: Rather than one of the usual JPA relationship annotations (for example, `@OneToOne`,
    `@ManyToMany`, and so on), this field is annotated as a JPA `@ElementCollection`.
    If this field were a single object, no annotation would be necessary. JPA would
    simply figure it out based on that object class having the `@Embeddable` annotation.
    However, the `@ElementCollection` annotation is necessary when dealing with collections
    of embeddable elements.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: When using classic XML-based Hibernate mapping, the `hbm.xml` file equivalents
    are `<component>` for single instances, and `<composite-element>` for collections.
    See the `chapter2-xml` variant of the downloadable sample application source.
  prefs: []
  type: TYPE_NORMAL
- en: The `@ElementCollection` annotation has a `fetch` element set to use eager fetching,
    for the same reasons discussed earlier in this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: On the next line we use the Hibernate-specific `@Fetch` annotation, to ensure
    that the `CustomerReview` instances are fetched through multiple `SELECT` statements
    rather than a single `OUTER JOIN`. This avoids duplication of customer reviews,
    due to Hibernate ORM quirks that are discussed further in comments within the
    downloadable source code. Unfortunately, this mode is inefficient when dealing
    with very large collections, so you may wish to consider another approach in such
    cases.
  prefs: []
  type: TYPE_NORMAL
- en: 'Querying embedded objects is the same as with associated entities. Here is
    the query code snippet from `SearchServlet`, modified to also search against the
    comments fields of the embedded `CustomerReview` instances:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: Now we have a query that is really doing some searching! The `chapter2` version
    of `StartupDataLoader` has been extended to load some customer reviews for all
    of the test apps. Searches will now produce results when a match is found in a
    customer review, even though the keyword doesn't otherwise appear in the `App`
    itself.
  prefs: []
  type: TYPE_NORMAL
- en: 'The HTML in the VAPORware Marketplace application has also been updated. Now
    each search result has a **Full Details** button, which pops-up a modal box with
    supported devices and customer reviews for that app. Notice that the search keyword
    in this screenshot is matched against a customer review rather the actual app
    description:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Embedded objects](img/9205_02_02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Partial indexing
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Associated entities each have their own Lucene index, and also store some data
    in each other's indexes. With embedded objects, search information is stored *exclusively*
    in the containing entity's index.
  prefs: []
  type: TYPE_NORMAL
- en: However, bear in mind that these classes may be associated or embedded in more
    than one place. For example, if you had the `Customer` and `Publisher` entities
    in your data model, both of them might have an embedded object of type `Address`.
  prefs: []
  type: TYPE_NORMAL
- en: Normally, we use the `@Field` annotation to tell Hibernate Search which fields
    should be indexed and searchable. However, what if we want this to vary with associated
    or embedded objects? What if we want a field to be indexed, or not indexed, depending
    on which other entity contains it? Hibernate Search provides this ability through
    an optional element in the `@IndexedEmbedded` annotation. This `includePaths`
    element indicates that within the Lucene index for *this* containing entity, only
    certain fields of the associated entity or embedded object should be included.
  prefs: []
  type: TYPE_NORMAL
- en: 'In our example application, the `CustomerReview` class has both its `username`
    and `comments` variable annotated as searchable fields. However, let''s say that
    for the `customerReviews` embedded within `App`, we only care about searching
    on comments. The change to `App` looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: Even though `CustomerReview.username` is annotated with `@Field`, that field
    will not be added to the Lucene index for `App`. This saves space, and improves
    performance by not making Lucene work hard on unnecessary indexing. The only trade-off
    is that to prevent errors, we must remember to avoid using any non-included fields
    in our query code.
  prefs: []
  type: TYPE_NORMAL
- en: The programmatic mapping API
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the beginning of this chapter we said that even when you map entities to
    the database with `hbm.xml` files, you can still use Hibernate Search annotations
    mapping to Lucene. However, if you really want to avoid putting annotations in
    your entity classes altogether, there is an API available for declaring your Lucene
    mappings programmatically at runtime.
  prefs: []
  type: TYPE_NORMAL
- en: This might come in handy if your search configuration needs to change at runtime
    based on some circumstances. It is also the only approach available if you cannot
    alter your entity classes for some reason, or if you are a hard-line believer
    in separating your configuration from your POJO's.
  prefs: []
  type: TYPE_NORMAL
- en: The heart of the programmatic mapping API is the `SearchMapping` class, which
    stores the Hibernate Search configuration that is normally pulled from annotations.
    Typical usage looks like the query DSL code that we saw in the previous chapter.
    You call a method on a `SearchMapping` object, call a method on the object returned,
    and so on in a long nested series.
  prefs: []
  type: TYPE_NORMAL
- en: The methods available at each step of the way intuitively resemble the search
    annotations that you have already seen. The `entity()` method replaces the `@Entity`
    annotation, `indexed()` replaces `@Indexed`, `field()` replaces `@Field`, and
    so on.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: If you need to use the programmatic mapping API in an application, then you
    can find more details in *Reference Manual* and *Javadocs*, both available at
    [http://www.hibernate.org/subprojects/search/docs](http://www.hibernate.org/subprojects/search/docs).
  prefs: []
  type: TYPE_NORMAL
- en: The starting point in Javadocs is the `org.hibernate.search.cfg.SearchMapping`
    class, and the other relevant classes are all in the `org.hibernate.search.cfg`
    package as well.
  prefs: []
  type: TYPE_NORMAL
- en: In the downloadable source code available from the Packt Publishing website,
    the `chapter2-mapping` subdirectory contains a version of the VAPORware Marketplace
    application that uses the programmatic mapping API.
  prefs: []
  type: TYPE_NORMAL
- en: 'This version of the example application includes a factory class, with a method
    that configures and returns a `SearchMapping` object upon demand. It doesn''t
    matter what you name the class or the method, so long as the method is annotated
    with `@org.hibernate.search.annotations.Factory`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: Notice that this factory method is only three lines long, strictly speaking.
    The bulk of it is one continuous line of chained method calls, originating from
    the `SearchMapping` object, that map our three persistent classes.
  prefs: []
  type: TYPE_NORMAL
- en: 'To integrate the mapping factory into Hibernate Search, we add a property to
    the main `hibernate.cfg.xml` configuration file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: Now, whenever Hibernate ORM opens a `Session`, Hibernate Search and all of the
    Lucene mappings come along for the ride!
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we expanded our knowledge of how to map classes for searching.
    We can now use Hibernate Search to map entities and other classes to Lucene, regardless
    of how Hibernate ORM maps them to the database. If we ever need to map classes
    to Lucene without adding annotations, we can use a programmatic mapping API to
    handle this at runtime.
  prefs: []
  type: TYPE_NORMAL
- en: We have now seen how to manage Hibernate Search across associated entities,
    as well as embedded objects whose lifecycle depend on their containing entity.
    In both cases, we covered some obscure quirks that can trip up developers. Finally,
    we learned how to control which fields of an associated or embedded class are
    indexed, depending on which entity contains them.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will use these mappings in a variety of search query
    types, and explore some important features common to all of them.
  prefs: []
  type: TYPE_NORMAL
