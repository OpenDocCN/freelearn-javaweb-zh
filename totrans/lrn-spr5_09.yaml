- en: 'Chapter 9. Exchange the Message: The Messaging'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Up till now we have discussed a lot about bidirectional web applications, which
    happens over the traditional HTTP communication. These browser based applications
    provide two way communication by opening multiple connections. The **websocket
    protocol** provides a mean for messaging over TCP which doesn''t rely on the opening
    of multiple HTTP connections. In this chapter, we will discuss websocket protocol
    with the help of following points:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Introduction to messaging**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Introduction to WebSocket protocol**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**WebSocket API**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Overview of STOMP**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'In web applications the bidirectional communication between client and server
    happens to be synchronous where the client request the resource and server sends
    the notification as the HTTP call. It addresses the following problems:'
  prefs: []
  type: TYPE_NORMAL
- en: The multiple connections have to open to send the information and to collect
    the incoming messages
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The track of mapping outgoing connections to the incoming connections so as
    to track the request and its replies
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The better solution will be to maintain a single TCP connection for both sending
    as well as receiving which has been provided by WebSocket as low level protocol
    without headers. As headers are not getting added, the amount of data being transmitted
    over the network decreases, in turn the load reduces. It is done by the process
    known as pull technology instead of push technology done in long pulling as in
    AJAX. Now a days, developers are using **XMLHttpRequest (XHR)** for the asynchronous
    HTTP communication. WebSocket uses the HTTP as transport layer to support the
    existing infrastructure using 80, 443 ports. In such two way communication of
    successful connection data transfer happens independently on their will.
  prefs: []
  type: TYPE_NORMAL
- en: 'The RFC 6455 defines the WebSocket protocol as, one which facilitates the two
    way communication between the client and the server where the client is running
    in the controlled environment communicating to the remote host, who had given
    the permission to accept mail, email or any direct communication from the code.
    The protocol consists of opening the handshake followed by the basic message framing
    which is layered over the TCP protocol. The HTTP status code 101 is sent by the
    server, if it agrees denoting successful handshake. Now the connection will remain
    open and the message exchange can be done. The following diagram gives an idea
    how the communication happens:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/image_10_001.png)'
  prefs: []
  type: TYPE_IMG
- en: 'The WebSocket does the following things on top of TCP:'
  prefs: []
  type: TYPE_NORMAL
- en: It adds the web security model to the browser.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: As one port needs to supports multiple host names and multiple services, it
    adds addressing and naming mechanism to provide such support.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It forms a layer framing mechanism on top of TCP to facilitate IP packet mechanism.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A closing handshake mechanism.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The data transfer in WebSocket uses a sequence of the frames. Such data frames
    can be transmitted by either side at any time after opening the handshake, but
    before the endpoint has sent the Close frame.
  prefs: []
  type: TYPE_NORMAL
- en: Spring and Messaging
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '* * *'
  prefs: []
  type: TYPE_NORMAL
- en: From Spring 4.0 onwards, there is a support for WebSocket introducing spring-websocket
    module, which is compatible with Java WebSocket API(JSR-356). The HTTPServlet
    and REST application uses URLs, HTTP methods to exchange the data between the
    client and the server. But opposite to this the WebSocket application may use
    single URL for the initial handshakes which is asynchronous, messaging and even
    driven architecture as JMS or AMQP. Spring 4 includes spring-messaging module
    to integrate Message, MessageChannel, MessageHandler, a set of annotations for
    mapping messages to the methods and many more to support the basic messaging architecture.
    The @Controller and @RestController which we already used to create Spring MVC
    web application and RESTful web services which allows handling HTTP request also
    support handler methods for WebSocket messaging. Also the handler methods from
    Controllers can broadcasts the message to either all interested or user specific
    WebSocket client.
  prefs: []
  type: TYPE_NORMAL
- en: The Use
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The WebSocket architecture is suitable in all those web applications, which
    needs to exchange events frequently but where the time with which the data exchanged
    to the target matters as:'
  prefs: []
  type: TYPE_NORMAL
- en: The social media is playing a very important role now days and playing a vital
    role to be in touch with family and friends. The user always enjoys real time
    updates of the feed done by their circle.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Now a day's many online multiplayer games are available on web. In such games,
    each player is always keen to know what his opponent is doing. Nobody wants to
    discover opponents move when they took their action.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In development the version control tools like Tortoise SVN, Git helps to keep
    the track of the files. So that, the exchange of the code becomes easier without
    conflict. But here, we won't get information about who is working on which of
    the file at real time.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In financial investments one always wants to know the real time price of the
    company in which he is interested and the not the one before some time.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Overview of WebSocket API
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '* * *'
  prefs: []
  type: TYPE_NORMAL
- en: The spring framework facilitates creation of WebSocket by providing the APIs
    to adopt various WebSocket engines. Today Tomcat7.0.47+, Jetty 9.1+, WebLogic
    12.1.3+, GlassFish 4.1+ provides runtime environments for WebSocket.
  prefs: []
  type: TYPE_NORMAL
- en: Creation of WebSocket handler
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The creation of WebSocketHandler can be done either by implementing the WebSocketHandler
    interface or extending from TextWebSocketHandler or BinaryWebSocketHandler as
    we have done in the following snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: The WebSocketDecorator class can be used to decorate the WebSocketHandler. Spring
    provides some decorator classes to handle exceptions, logging mechanism, and handling
    binary. The class ExceptionWebSocketHandler, is an Exception handling WebSocketHandlerDecorator
    which helps in handling all instances of the Throwable. The LoggingWebSocketHandlerDecorator,
    adds the logging to events which takes place in the life cycle of the WebSocket.
  prefs: []
  type: TYPE_NORMAL
- en: Registering WebSocketHandler
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The WebSocket handlers are mapped to a specific URL to register this mapping
    .The framework can be done either by Java configuration or XML based configuration.
  prefs: []
  type: TYPE_NORMAL
- en: Java Based configuration
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'The WebSocketConfigurer is used to map the handler with its specific URL in
    the `registerWebSocketHandlers()` method as shown in the code below:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: Here our WebSocketHandler is mapped to /webSocketHandler URL.
  prefs: []
  type: TYPE_NORMAL
- en: 'The customization of the WebSocketHandler to customize the handshake can be
    done as:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: The HandshakeInterceptor exposes `beforeHandshake()` and `afterhandshake()`
    methods to customize the WebSocket handshake. The `HttpSessionHandshakeInterceptor`
    facilitates binding information from HtttpSession to the handshake attributes
    under the name `HTTP_SESSION_ID_ATTR_NAME`. These attribute can be used as `WebSocketSession.getAttributes()` method.
  prefs: []
  type: TYPE_NORMAL
- en: XML Based configuration
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'The registration done in the above Java snippet, can be done in XML as well.
    We need to register the web-socket namespace in the XML and then configure the
    handler as shown below:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'The customised WebSocketConfigurer in XML can be written as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: WebSocket Engine Configuration
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Tomcat7.0.47+, Jetty 9.1+,WebLogic 12.1.3+, GlassFish 4.1+ provides runtime
    environments for WebSocket. The characteristics such as buffer size of the messages,
    timeout, can be configured for Tomcat runtime environment by adding the bean for
    WebSocketConfigurer as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'The equivalent XML configuration can be written as:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: Configuration of allowed origins
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: The 'origin' is the scope of the privilege by the agent. The variety of content
    exists in various format created by numerous authors, something out of which may
    be harmful. The content created by one origin can freely interact with the content
    created by other origin. The agents has the facility to set up the rules under
    which one content interact with other called as **'same-origin policy'**.
  prefs: []
  type: TYPE_NORMAL
- en: Let's take an example of HTML, where we are having form submission. Whenever
    the user agent enters the data, the entered data is exported to the URI. Here
    the URI declares the trust on the integrity of the information which the script
    file has received through the URI.
  prefs: []
  type: TYPE_NORMAL
- en: '`http://packt.com/`, `http://packt.com:8080/`, `http://www.packt.com/`, `https://packt.com:80/`,
    `https://packt.com/`, `http://packt.org/` are different URIs.'
  prefs: []
  type: TYPE_NORMAL
- en: 'There are three ways to configure origin as:'
  prefs: []
  type: TYPE_NORMAL
- en: Allow same origin
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Allow specified list of origins
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Allow all origins
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Let''s first discuss in detail about the creation and use of WebSocket for
    client server communication:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Creation of WebSocket:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'Where URL contains:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Schema**: the URL must contain either `ws` denoting insecure connection or
    `wss` denoting secure connections'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Host:** it''s a name or IP of the server'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Port**: the remote port where you the we want to get connected ws connection
    by default uses port ''80'' and wss uses 443'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Resource name**: path URL of the resource to fetch'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'We can write the URL for WebSocket as:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: scheme://host_name:port_no/resource_path
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: ws://host_name:port_no/resource_path
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: wss://host_name:port_no/resource_path
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Closing the WebSocket:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: To close the connection we use `close()` method as `close(code, reason).`
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'code: It''s a numeric status sent to the server. 1000 indicates normal closing
    of connections.'
  prefs: []
  type: TYPE_NORMAL
- en: 'States of the WebSocket:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Following are the connection states of the WebSocket, giving information in
    which state it is:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Connecting**: The WebSocket is constructed and it is attempting to connect
    to the specified URL. This state is considered as the connecting state having
    ready State as 0.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Open**: Once the WebSocket is successfully connected to the URL it will enter
    to the open state. The data can be sent to and from the network only when the
    WebSocket is in open state. The ready state value of open state is "1".'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Closing**: The WebSocket won''t directly close, it must communicate to the
    server to inform it is disconnecting. This state is considered as closing state.
    The ready state value of open state is"2".'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Closed**: After the successful disconnection from the server the WebSocket
    enters in the closed state. The WebSocket in the closed state has a "readyState"
    value of 3.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Event Handling in WebSocket:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The WebSocket works on the principle of event handling, where the call back
    methods get invoked to complete the process. Following are the events which occurs
    in the life cycle of the WebSocket:'
  prefs: []
  type: TYPE_NORMAL
- en: '**onopen**: When the WebSocket transit to open state the "onopen" event handler
    gets called.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**onmessage**: When the WebSocket receives data from the server the "onmessage"
    event handler gets called. The received data gets stored in the "data" field of
    the "message" event.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The data field has the parameters as:'
  prefs: []
  type: TYPE_NORMAL
- en: '**onclose**: When the WebSocket is closed the "onclose" event handler gets
    called. The event object will get passed to "onclose". It has three fields named:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**code**: a numeric status value provided by the server'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**reason**: its a string describing the close event.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**wasClean**: has a boolean value indicating whether the connection closed
    without any problem. Under normal circumstances, "wasClean" is true.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**onerror**: When a WebSocket encounters any problem the "onerror" event handler
    gets called. The event passed to the handler will be a standard error object which
    includes "name" and "message" fields.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Sending the data:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The data transmission happens via `send()` method which deals with UTF-8 text
    data, data of type ArrayBuffer and a data of type blob. The 'bufferedAmount '
    property with value as zero ensures data sent successfully.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let us develop a demo for WebSocket with the help of following steps to find
    capital of the country:'
  prefs: []
  type: TYPE_NORMAL
- en: Create Ch10_Spring_Message_Handler as dynamic web application.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Add jars for Spring core, Spring web , spring-websocket, spring-messaging modules.
    Also add jars for Jackson.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Let''s add MyMessageHandler as a child of TextWebSocketHandler in the compackt.ch10.config
    package. Override the methods for handling message, WebSocket connection, connection
    closing as shown below:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'This MessageHandler needs to register with WebSocketConfigurer for URL ''/myHandler''
    for all origins as shown below:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: Add Front controller mapping in web.xml as we did in earlier applications with
    servlet name as 'books'.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Add books-servlet.xml to add bean for 'viewResolver'. You can decide adding
    it as a bean depending upon the application requirement.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Also add configuration to enable spring web MVC as:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'Add country.jsp as a JSP page having list of countries where user can select
    the country from drop down to get name of its capital:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'Add the SockJS support by adding sockjs-0.3.4.js in your resources or adding
    the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'On form submission a method of JavaScript gets invoked, where we handle the
    WebSocket events onopen, onmessage etc as discussed earlier:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: We already discussed about how to write the WebSocket URLs and event handling
    mechanism.
  prefs: []
  type: TYPE_NORMAL
- en: Deploy the application and access the page. Select the country from dropdown
    and click on show capital button. The message will appear displaying the name
    of the capital.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following diagram shows the flow of the application:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/image_10_002.png)'
  prefs: []
  type: TYPE_IMG
- en: We had added the Console logs as well as the Alert messages to know the progress
    and to and fro of the messages. As per requirement you can customize it or can
    completely omit as well.
  prefs: []
  type: TYPE_NORMAL
- en: In the earlier example, we have used WebSocket for communication but still its
    support is limited. The SockJS is a JavaScript library which provides the objects
    like WebSocket.
  prefs: []
  type: TYPE_NORMAL
- en: SockJS
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '* * *'
  prefs: []
  type: TYPE_NORMAL
- en: 'The SockJS library provides cross browser, JavaScript API to enable low latency,
    cross domain communication between the browser and server. It aims to support
    the following goals:'
  prefs: []
  type: TYPE_NORMAL
- en: Instead of using WebSocket instance, the SockJS instance is used
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The API which are close to WebSocket API both for server as well as client side
    APIs
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Faster communication support
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: JavaScript for client side
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It comes with some chosen protocols which supports cross domain communication
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The following code shows how to enable in the SockJS support for WebSocketConfigurere
    as:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'Or even we can configure in XML as:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'We can update the Capital demo developed earlier to support SockJS as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Add country_sockjs.jsp in WebContent to use with SockJS as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: Add MyWebSocketConfigurer_sockjs in com.packt.ch10.config package to configure
    the WebSocket as we did earlier. To enable the SockJS support we have to modify
    the `registerWebSocketHandlers()` method as shown in the configuration above using
    `withSockJS()`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Run the application and request for country_sockjs.jsp to use the SockJS. You
    can observe the console logs as well.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In the above example, we had use WebSocket to get the connection and handle
    the events. The new WebSocket protocol also has been introduced for the communication
    which we used here. It uses less bandwidth. It has no headers like HTTP gives
    simpler, efficient communication. We can also use STOMP for the communication.
  prefs: []
  type: TYPE_NORMAL
- en: STOMP
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '* * *'
  prefs: []
  type: TYPE_NORMAL
- en: '**Simple (or Streaming) Text Oriented Message Protocol (STOMP)** over WebSocket
    provides a straightforward mapping from a STOMP frame to a JavaScript object.
    WebSocket is fastest protocol but, still it is not supported by all browsers.
    The browsers have problems to support proxies and protocol handling. It will take
    a while to get wide support by all the browsers, meanwhile we need to find some
    substitute or real time solution. The SockJS supports STOMP protocol for communicating
    with any message broker from the scripting languages and is an alternative to
    AMQP. STOMP is lightweight and easy to implement both on client as well as server
    side. It comes with reliable sending single message and then disconnect or consume
    all messages from the destination It defines following different frames that are
    mapped to WebSocket frames:'
  prefs: []
  type: TYPE_NORMAL
- en: '**CONNECT**: It connects the client to the server.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**SUBSCRIBE**: It is used to register which can listen to the given destination.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**UNSUBSCRIBE**: It is used to remove existing subscription.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**SEND (messages sent to the server)**: The frame sends a message to the destination.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**MESSAGE (for messages send from the server**): It conveys the messages from
    the subscriptions to the client.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**BEGIN:** It starts the transaction.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**COMMIT**: It commits the ongoing transaction.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**ABORT**: It rollbacks the ongoing transaction.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**DISCONNECT**: It disconnects the client from the server.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'It also supports the following standard headers:'
  prefs: []
  type: TYPE_NORMAL
- en: '**content-length:** The SEND, MESSAGE and ERROR frames contain content-length
    header having its value as content length of the message body.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**content-type**: The SEND, MESSAGE and ERROR frames contain content-type.
    It is similar to MIME type in web technology.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**receipt**: The CONNECT frame may contain receipt as header attribute to acknowledge
    the server of the RECEIPT frame.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**heart-beat**: It got added by the CONNECT and CONNECTED frames. It contains
    two positive integer values separated by the comma.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 1st value represents outgoing heart beats. '0' specifies it cannot send heart
    beats.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 2nd value denotes incoming heart beats. '0' denotes unwillingness to receive
    the heart beats.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Spring STOMP support
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The Spring WebSocket application works as a STOMP broker to all the clients.
    Each message will be routed through the Spring controllers. These controllers
    are capable of handling HTTP request and response by @RequestMapping annotation.
    Similarly they are capable of handling WebSocket Messages in all those methods
    who are annotated by @Messaging. Spring also facilitates integration of RabbitMQ,
    ActiveMQ as the STOMP brokers for the message broad casting.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let'' us develop an application to use STOMP step by step:'
  prefs: []
  type: TYPE_NORMAL
- en: Create Ch10_Spring_Messaging_STOMP as a dynamic web application and add the
    jars which we added earlier.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Add mapping for DispatcherServlet in web.xml having books as name and 'webS'
    as URL pattern.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Add books-servlet.xml to register bean for 'viewResolver'. Registration to discover
    the controllers and to consider all MVC annotations.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Add WebSocketConfig_custom as a class in com.packt.ch10.config package to add
    the ''`/book''` as endpoint enabled for SockJS. ''`/topic''` as SimpleBroker for
    ''`/bookApp''` as prefix. The code is as shown below:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: The @EnableWebSocketMessageBroker enables the class to act as a message broker.
  prefs: []
  type: TYPE_NORMAL
- en: Add POJO MyBook with bookName as data member in com.packt.ch10.model package.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Similarly add Result having result as data member as POJO having getOffer method
    as:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'Add index.html to have the link for the ''`bookPage''` from the controller
    as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: Add WebSocketController class in com.packt.ch10.controller package and annotate
    it by @Controller("webs").
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Add `bookPage()` method annotated by @RequestMapping to send bookPage.jsp to
    the client as shown below:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'Add bookPage.jsp in the jsps folder. The page will display book names to get
    offers associated with them. The code will be as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'We will be handling the call back methods, once the client click the button.
    Add the scripts for sockjs and STOMP as:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'Now we will add connect, disconnect, send, subscribe one by one. Let'' us first
    add connect method to get the STOMP connection as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'The connect method creates an object of SockJS and using `Stomp.over()` adds
    support for STOMP protocol. The connection adds the `subscribe()` to subscribe
    the messages from `''topic/showOffer''` handler. We had added ''`/topic''` as
    the SimpleBroker in the WebSocketConfig_custom class. We are handling, sending
    and receiving the JSON objects. The offers received by the Result JSON object
    will be in form of result: `value_of_offer`.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Add disconnect method as:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'Add sendBook to sent the request to get the offer as:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: The `send()` gives request to the handler `/bookApp/book`, which will accept
    JSON object having `bookName` data member. We registered destination prefix as
    '`bookApp`' which we are using while sending the request.
  prefs: []
  type: TYPE_NORMAL
- en: 'Add method to display the offer as:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'Now let us add the handler method in controller for ''`/book''`. This method
    will be annotated by `@SendTo("/topic/showOffer''` as below:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: Deploy the application. And click on the link to get offer page.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Click on connect to get server connection. Select the book to know offer and
    click on send. The offers associated with the book will get displayed.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The following diagram explains the application flow:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/image_10_003.png)'
  prefs: []
  type: TYPE_IMG
- en: 'On console the log will be displayed as below showing different frames of STOMP:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/image_10_004.png)'
  prefs: []
  type: TYPE_IMG
- en: Summary
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '* * *'
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter we discussed in depth about the messaging using WebSocket. We
    took overview of why WebSocket is important and how it differs from the traditional
    web applications as well as the XMLHttpRequest based AJAX applications. We discussed
    the areas in which WebSocket can play a vital role. Spring provides API to work
    with WebSocket. We had seen WebSocketHandler, WebSocketConfigurer and its registration
    both using Java classes as well as XML based configurations using Capital of Country
    application. The SockJS library provides cross browser, JavaScript API to enable
    low latency, cross domain communication between the browser and server. We enabled
    the SockJS both in XML and Java configuration. We had also seen in depth about
    STOMP to be used in WebSocket over SockJS and to enable it and its event handling
    methods.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will discover the reactive web programming.
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/image_01_038.png)'
  prefs: []
  type: TYPE_IMG
- en: If you have any feedback on this eBook or are struggling with something we haven't
                                               covered, let us know at survey [link](https://goo.gl/y7BQfO).
  prefs: []
  type: TYPE_NORMAL
- en: If you have any concerns you can also get in touch with us at
  prefs: []
  type: TYPE_NORMAL
- en: '[customercare@packtpub.com](mailto:customercare@packtpub.com)'
  prefs: []
  type: TYPE_NORMAL
- en: We will send you the next chapters when they are ready.........!
  prefs: []
  type: TYPE_NORMAL
- en: Hope you like the content presented.
  prefs: []
  type: TYPE_NORMAL
