- en: Deployment and Testing
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we'll continue from where we left off in [Chapter 4](4561ba72-866e-45f9-88ac-761a62242e26.xhtml),
    *Implementing a Microservice*. We'll add a few more services to groom our online
    table reservation system (OTRS) application that only depends on three functional
    services (Restaurant, User, and Booking services) and Eureka (service discovery
    and registration) to create a fully functional microservice stack. This stack
    will have gateway (Zuul), load balancing (Ribbon with Zuul and Eureka), and monitoring
    (Hystrix, Turbine, and the Hystrix dashboard). You want to have composite APIs
    and see how one microservice talks to others. This chapter will also explain how
    to containerize microservices using Docker and how to run multiple containers
    together using `docker-compose`. On top of this, we'll also add the integration
    tests.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: An overview of microservice architecture using Netflix OSS
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Edge servers
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Load balancing microservices
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Circuit breakers and monitoring
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Microservice deployment using containers
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Microservice integration testing using Docker containers
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Mandatory services for good microservices
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'There are a few patterns/services that should be in place for implementing
    microservice-based design. This list consists of the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Service discovery and registration
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Edge or proxy server
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Load balancing
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Circuit breaker
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Monitoring
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We'll implement these services in this chapter to complete our OTRS system.
    Following is a brief overview. We'll discuss these patterns/services in detail
    later.
  prefs: []
  type: TYPE_NORMAL
- en: Service discovery and registration
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The Netflix Eureka server is used for service discovery and registration. We
    created the Eureka service in the last chapter. It not only allows you to register
    and discover services, but also provides load balancing using Ribbon.
  prefs: []
  type: TYPE_NORMAL
- en: Edge servers
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: An edge server provides a single point of access to allow the external world
    to interact with your system. All of your APIs and frontends are only accessible
    using this server. Therefore, these are also referred to as gateway or proxy servers.
    These are configured to route requests to different microservices or frontend
    applications. We'll use the Netflix Zuul server as an edge server in the OTRS
    application.
  prefs: []
  type: TYPE_NORMAL
- en: Load balancing
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Netflix Ribbon is used for load balancing. It is integrated with the Zuul and
    Eureka services to provide load balancing for both internal and external calls.
  prefs: []
  type: TYPE_NORMAL
- en: Circuit breakers
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A fault or break should not prevent your whole system from working. Also, the
    repeated failure of a service or an API should be handled properly. Circuit breakers
    provide these features. Netflix Hystrix is used as a circuit breaker and helps
    to keep the system up.
  prefs: []
  type: TYPE_NORMAL
- en: Monitoring
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The Hystrix dashboard is used with Netflix Turbine for microservice monitoring.
    It provides a dashboard to check the health of running microservices.
  prefs: []
  type: TYPE_NORMAL
- en: An overview of microservice architecture using Netflix OSS
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Netflix are pioneers in microservice architecture. They were the first to successfully
    implement microservice architecture on a large scale. They also helped increase
    its popularity and contributed immensely to microservices by open sourcing most
    of their microservice tools with Netflix **Open Source Software Center** (**OSS**).
  prefs: []
  type: TYPE_NORMAL
- en: According to the Netflix blog, when Netflix was developing their platform, they
    used Apache Cassandra for data storage, which is an open source tool from Apache.
    They started contributing to Cassandra with fixes and optimization extensions.
    This led to Netflix seeing the benefits of releasing Netflix projects with the
    name OSS.
  prefs: []
  type: TYPE_NORMAL
- en: Spring took the opportunity to integrate many Netflix OSS projects, such as
    Zuul, Ribbon, Hystrix, the Eureka server, and Turbine, into Spring Cloud. This
    is one of the reasons Spring Cloud provides a ready-made platform for developing
    production-ready microservices.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let''s take a look at a few important Netflix tools and how they fit into
    microservice architecture:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/451c2530-d3dd-4dca-ab1e-04a6f2c8c0a0.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Microservice architecture diagram
  prefs: []
  type: TYPE_NORMAL
- en: 'As you can see in the preceding diagram, for each of the microservice practices,
    we have a Netflix tool associated with it. We can go through the following mapping
    to understand it. Detailed information is covered in the respective sections of
    this chapter except concerning Eureka, which is elaborated on in the last chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Edge server**: We use the Netflix Zuul server as an edge server.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Load balancing**: Netflix Ribbon is used for load balancing.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Circuit breaker**: Netflix Hystrix is used as a circuit breaker and helps
    to keep the system up.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Service discovery and registration**: The Netflix Eureka server is used for
    service discovery and registration.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Monitoring dashboard**: The Hystrix dashboard is used with Netflix Turbine
    for microservice monitoring. It provides a dashboard to check the health of running
    microservices.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Load balancing
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Load balancing is required to service requests in a manner that maximizes speed
    and capacity utilization, and it makes sure that no server is overloaded with
    requests. The load balancer also redirects requests to the remaining host servers
    if a server goes down. In microservice architecture, a microservice can serve
    internal or external requests. Based on this, we can have two types of load balancingâ€”client-side
    and server-side load balancing.
  prefs: []
  type: TYPE_NORMAL
- en: Server-side load balancing
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We'll discuss server-side load balancing; before that, we'll discuss routing.
    It is important to define the routing mechanism for our OTRS application from
    the microservice architecture point of view. For example, `/` (root) could be
    mapped to our UI application. Similarly, `/restaurantapi` and `/userapi` could
    be mapped to the Restaurant service and User service respectively. The edge server
    also performs routing with load balancing.
  prefs: []
  type: TYPE_NORMAL
- en: We'll use the Netflix Zuul server as our edge server. Zuul is a JVM-based router
    and server-side load balancer. Zuul supports any JVM language for writing rules
    and filters and has built-in support for Java and Groovy.
  prefs: []
  type: TYPE_NORMAL
- en: Netflix Zuul, by default, has discovery client (Eureka client) support. Zuul
    also makes use of Ribbon and Eureka for load balancing.
  prefs: []
  type: TYPE_NORMAL
- en: The external world (the UI and other clients) calls the edge server, which uses
    the routes defined in `application.yml` to call internal services and provide
    the response. Your guess is right if you think it acts as a proxy server, carries
    gateway responsibility for internal networks, and calls internal services for
    defined and configured routes.
  prefs: []
  type: TYPE_NORMAL
- en: Normally, it is recommended to have a single edge server for all requests. However,
    a few companies use a single edge server per client to scale. For example, Netflix
    uses a dedicated edge server for each device type.
  prefs: []
  type: TYPE_NORMAL
- en: An edge server will also be used in the next chapter, when we configure and
    implement microservice security.
  prefs: []
  type: TYPE_NORMAL
- en: 'Configuring and using the edge server is pretty simple in Spring Cloud. You
    need to perform the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Define the Zuul server dependency in the `pom.xml` file:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: Use the `@EnableZuulProxy` annotation in your application class. It also internally
    uses the `@EnableDiscoveryClient` annotation; therefore, it is also registered
    to the Eureka server automatically. You can find the registered Zuul server in
    the figure in *Client-side load balancing section*.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Update the Zuul configuration in the `application.yml` file, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`zuul:ignoredServices`: This skips the automatic addition of services. We can
    define service ID patterns here. The `*` denotes that we are ignoring all services.
    In the following sample, all services are ignored except `restaurant-service`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Zuul.routes`: This contains the `path` attribute that defines the URI''s pattern.
    Here, `/restaurantapi` is mapped to `restaurant-service` using the `serviceId`
    attribute. The `serviceId` attribute represents the service in the Eureka server.
    You can use a URL in place of a service, if the Eureka server is not used. We
    have also used the `stripPrefix` attribute to strip the prefix (`/restaurantapi`),
    and the resultant `/restaurantapi/v1/restaurants/1` call converts to `/v1/restaurants/1`
    while calling the service:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'Please note that Eureka applications only register a single instance of any
    service for each host. You need to use the following value for `metadataMap.instanceid`
    to register multiple instances of the same application on one host for load balancing
    to work:'
  prefs: []
  type: TYPE_NORMAL
- en: '`${spring.application.name}:${vcap.application.instance_id:${spring.application.instance_id:${random.value}}}`'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s see a working edge server. First, we''ll call the Restaurant service
    deployed on port `3402`, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/96fe451a-e8c4-48fc-b80a-a09784c1795b.png)'
  prefs: []
  type: TYPE_IMG
- en: Direct Restaurant service call
  prefs: []
  type: TYPE_NORMAL
- en: 'Then, we''ll call the same service using the edge server that is deployed on
    port `8765`. You can see that the `/restaurantapi` prefix is used for calling
    `/v1/restaurants?name=o`, and it gives the same result:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/6202f3a7-e83f-4f7f-a992-5f153e395f66.png)'
  prefs: []
  type: TYPE_IMG
- en: Restaurant Service call using the edge server
  prefs: []
  type: TYPE_NORMAL
- en: Client-side load balancing
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Microservices need interprocess communication so that services can communicate
    with each other. Spring Cloud uses Netflix Ribbon, a client-side load balancer
    that plays this critical role and can handle both HTTP and TCP. Ribbon is cloud-enabled
    and provides built-in failure resiliency. Ribbon also allows you to use multiple
    and pluggable load balancing rules. It integrates clients with load balancers.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the last chapter, we added the Eureka server. Ribbon is integrated with
    the Eureka server in Spring Cloud by default. This integration provides the following
    features:'
  prefs: []
  type: TYPE_NORMAL
- en: You don't need to hardcode remote server URLs for discovery when the Eureka
    server is used. This is a prominent advantage, although you can still use the
    configured server list (`listOfServers`) in the `application.yml` file if required.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The server list gets populated from the Eureka server. The Eureka server overrides
    `ribbonServerList` with the `DiscoveryEnabledNIWSServerList` interface.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The request to find out whether the server is up is delegated to Eureka. The
    `DiscoveryEnabledNIWSServerList` interface is used in place of Ribbon's `IPing`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: There are different clients available in Spring Cloud that use Ribbon, such
    as `RestTemplate` or `FeignClient`. These clients allow microservices to communicate
    with each other. Clients use instance IDs in place of hostnames and ports for
    making an HTTP call to service instances when the Eureka server is used. The client
    passes the service ID to Ribbon and it then uses the load balancer to pick the
    instance from the Eureka server.
  prefs: []
  type: TYPE_NORMAL
- en: 'If there are multiple instances of services available in Eureka, as shown in
    the following screenshot, Ribbon picks only one for the request, based on load
    balancing algorithms:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/ff86c7a3-c57c-4228-b6a2-5b87de6eacea.png)'
  prefs: []
  type: TYPE_IMG
- en: Multiple service registration - Restaurant service
  prefs: []
  type: TYPE_NORMAL
- en: We can use the `DiscoveryClient` to find all of the available service instances
    in the Eureka server, as shown in the following code. The `getLocalServiceInstance()`
    method of the `DiscoveryClientSample` class returns all of the local service instances
    available in the Eureka server.
  prefs: []
  type: TYPE_NORMAL
- en: 'This is the `DiscoveryClient` sample:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'When executed, this code prints the following information. It shows two instances
    of the Restaurant service:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: The following samples showcase how these clients can be used. You can see that
    in both clients, the service name `restaurant-service` is used in place of a service
    hostname and port. These clients call `/v1/restaurants` to get a list of restaurants
    containing the name given in the name query parameter.
  prefs: []
  type: TYPE_NORMAL
- en: 'This is the`RestTemplate` sample:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'This is the`FeignClient` sample:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'All preceding examples will print the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: For demonstration purposes, we have added all clientsâ€”`discovery` client, `RestTemplate`
    client, and `FeignClient` added in the edge application main class Java file.
    Since we have all of these clients implementing the `CommandLineRunner` interface,
    this gets executed immediately after the edge application service starts.
  prefs: []
  type: TYPE_NORMAL
- en: Circuit breakers and monitoring
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In general terms, a circuit breaker is a*n automatic device for stopping the
    flow of current in an electric circuit as a safety measure.*
  prefs: []
  type: TYPE_NORMAL
- en: The same concept is used for microservice development, known as the **circuit
    breaker** design pattern. It tracks the availability of external services such
    as the Eureka server, API services such as `restaurant-service`, and so on, and
    prevents service consumers from performing any action on any service that is not
    available.
  prefs: []
  type: TYPE_NORMAL
- en: It is another important aspect of microservice architecture, a safety measure
  prefs: []
  type: TYPE_NORMAL
- en: (failsafe mechanism) when the service does not respond to a call made by the
    service consumer, which is called a circuit breaker.
  prefs: []
  type: TYPE_NORMAL
- en: We'll use Netflix Hystrix as a circuit breaker. It calls the internal fallback
    method in the service consumer when failures occur (for example, due to a communication
    error or timeout). It executes embedded within its consumer of service. In the
    next section, you will find the code that implements this feature.
  prefs: []
  type: TYPE_NORMAL
- en: Hystrix opens the circuit and failfast when the service fails to respond repeatedly,
    until the service is available again. When calls to a particular service reach
    a certain threshold (the default threshold is 20 failures in five seconds), the
    circuit opens and the call is not made. You must be wondering, if Hystrix opens
    the circuit, then how does it know that the service is available? It exceptionally
    allows some requests to call the service.
  prefs: []
  type: TYPE_NORMAL
- en: Using Hystrix's fallback methods
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'There are five steps for implementing fallback methods. For this purpose, we''ll
    create another service, `api-service`, in the same way as we have created other
    services. The `api-service` service will consume the other services such as `restaurant-service`
    and so on, and will be configured in the edge server for exposing the OTRS API
    to external use. The five steps are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Enable the circuit breaker**: The main class of microservice that consumes
    other services should be annotated with `@EnableCircuitBreaker`. Therefore, we''ll
    annotate `src\main\java\com\packtpub\mmj\api\service\ApiApp.java`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: '**Configure the fallback method**: The annotation `@HystrixCommand` is used
    to configure the `fallbackMethod`. We''ll annotate controller methods to configure
    the fallback methods. This is the file: `src\main\java\com\packtpub\mmj\api\service\restaurant\RestaurantServiceAPI.java`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: '**Define the fallback method**: A method that handles the failure and performs
    the steps for safety. Here, we have just added a sample; this can be modified
    based on the way we want to handle the failure:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: '**Maven dependencies**: We need to add the following dependencies in `pom.xml`
    for an API service or in a project in which we want to failsafe API calls:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: '**Configuring Hystrix in `application.yml`**: We will add the following Hystrix
    properties in our `application.yml` file:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: These steps should be enough to failsafe the service calls and return a more
    appropriate response to the service consumer.
  prefs: []
  type: TYPE_NORMAL
- en: Monitoring
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Hystrix provides a dashboard with a web UI that provides nice graphics of circuit
    breakers:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/88b20511-ffd5-4562-979d-50210d86d46c.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Default Hystrix dashboard
  prefs: []
  type: TYPE_NORMAL
- en: Netflix Turbine is a web application that connects to the instances of your
    Hystrix applications in a cluster and aggregates information, which it does in
    real time (updated every 0.5 seconds). Turbine provides information using a stream
    that is known as a Turbine stream.
  prefs: []
  type: TYPE_NORMAL
- en: If you combine Hystrix with Netflix Turbine, then you can get all of the information
    from the Eureka server on the Hystrix dashboard. This gives you a landscape view
    of all of the information about the circuit breakers.
  prefs: []
  type: TYPE_NORMAL
- en: To use Turbine with Hystrix, just type in the Turbine URL `http://localhost:8989/turbine.stream`
    (port `8989` is configured for the Turbine server in `application.yml`) in the
    first textbox shown in the preceding screenshot, and click on Monitor Stream.
  prefs: []
  type: TYPE_NORMAL
- en: Netflix Hystrix and Turbine use RabbitMQ, an open source message queuing software.
    RabbitMQ works on **Advance Messaging Queue Protocol** (**AMQP**). It is a software
    in which queues can be defined and used by connected applications to exchange
    messages. A message can include any kind of information. A message can be stored
    in the RabbitMQ queue until a receiver application connects and consumes the message
    (taking the message off the queue).
  prefs: []
  type: TYPE_NORMAL
- en: Hystrix uses RabbitMQ to send metrics data feed to Turbine.
  prefs: []
  type: TYPE_NORMAL
- en: Before we configure Hystrix and Turbine, please install the RabbitMQ application
    on your platform. Hystrix and Turbine use RabbitMQ to communicate between themselves.
  prefs: []
  type: TYPE_NORMAL
- en: Setting up the Hystrix dashboard
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We'll create another project in the IDE for the Hystrix dashboard in the same
    way as we created other services. Inside this new project, we'll add the new Maven
    dependency, `dashboard-server`, for the Hystrix server. Configuring and using
    the Hystrix dashboard is pretty simple in Spring Cloud.
  prefs: []
  type: TYPE_NORMAL
- en: 'When you run the Hystrix dashboard application, it will look like the default
    Hystrix dashboard screenshot shown earlier. You just need to follow these steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Define the Hystrix dashboard dependency in the `pom.xml` file:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'The `@EnableHystrixDashboard` annotation in the main Java class does everything
    for you to use it. We''ll also use the `@Controller` to forward the request from
    the root URI to the Hystrix dashboard UI URI (`/hystrix`), as shown here:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'Update the dashboard application configuration in `application.yml`, as shown
    here:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: Creating Turbine services
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Turbine aggregates all `/hystrix.stream` endpoints into a combined `/turbine.stream`
    for use in the Hystrix dashboard, which is more helpful as it allows to see the
    overall health of the system in a single dashboard rather than monitoring the
    individual services using `/hystrix.stream`. We'll create another service project
    in the IDE like the others. Then, we'll add Maven dependencies for Turbine in
    `pom.xml`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, we will configure the Turbine server using the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Define the Turbine Server dependency in `pom.xml`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: Use the `@EnableTurbineStream` annotation in your application class, as
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'shown here. We are also defining a bean that will return the RabbitMQ `ConnectionFactory`:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'Update the Turbine configuration in `application.yml`, as shown here:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`server:port`: The main port used by the the Turbine HTTP'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`management:port`: Port of Turbine actuator endpoints:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: Earlier, we have added the User and Restaurant services in a cluster using the
    `turbine.aggregator.clusterConfig` property. Here, values are in uppercase because
    Eureka returns the service names in capital letters. Also, the `turbine.appConfig`
    property contains the list of the Eureka service IDs that will be used by the
    Turbine to look up instances. Please be aware that the preceding steps always
    create the respective servers with default configurations. If required, you can
    override the default configuration with specific settings.
  prefs: []
  type: TYPE_NORMAL
- en: Building and running the OTRS application
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Build all of the projects using `mvn clean install` using the following file:
    `..\Chapter5 \pom.xml`.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The output should look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, on command prompt, go to `<path to source>/6392_chapter5` and run the
    following commands:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'Note: Before starting the Zuul service, please make sure that all of the services
    are up in the Eureka dashboard: `http://localhost:8761/`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: Again, check the Eureka dashboard that all applications should be up. Then,
    perform the testing.
  prefs: []
  type: TYPE_NORMAL
- en: Microservice deployment using containers
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: You might have got the point about Docker after reading [Chapter 1](8ea8ade6-8194-4739-94ed-92454e884d9d.xhtml),
    *A Solution Approach*.
  prefs: []
  type: TYPE_NORMAL
- en: A Docker container provides a lightweight runtime environment, consisting of
    the core features of a virtual machine and the isolated services of operating
    systems, known as a Docker image. Docker makes the packaging and execution of
    microservices easier and smoother. Each operating system can have multiple Dockers,
    and each Docker can run single application.
  prefs: []
  type: TYPE_NORMAL
- en: Installation and configuration
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Docker needs a virtualized server if you are not using a Linux OS. You can install
    VirtualBox or similar tools such as Docker Toolbox to make it work for you. The
    Docker installation page gives more details about it and lets you know how to
    do it. So, leave it to the Docker installation guide available on Docker's website.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can install Docker, based on your platform, by following the instructions
    given at: [https://docs.docker.com/engine/installation/](https://docs.docker.com/engine/installation/).'
  prefs: []
  type: TYPE_NORMAL
- en: DockerToolbox-1.9.1f was the latest version available at the time of writing.
    This is the version we used.
  prefs: []
  type: TYPE_NORMAL
- en: Docker machine with 4 GB
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Default machines are created with 2 GB of memory. We''ll recreate a Docker
    machine with 4 GB of memory:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: Building Docker images with Maven
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'There are various Docker Maven plugins that can be used:'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://github.com/rhuss/docker-maven-plugin](https://github.com/rhuss/docker-maven-plugin)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[https://github.com/alexec/docker-maven-plugin](https://github.com/alexec/docker-maven-plugin)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[https://github.com/spotify/docker-maven-plugin](https://github.com/spotify/docker-maven-plugin)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You can use any of these, based on your choice. I found the Docker Maven plugin
    by `@rhuss` to be best suited for us. It is updated regularly and has many extra
    features when compared to the others.
  prefs: []
  type: TYPE_NORMAL
- en: 'We need to introduce the Docker Spring profile in `application.yml` before
    we start discussing the configuration of `docker-maven-plugin`. It will make our
    job easier when building services for various platforms. We need to configure
    the following four properties:'
  prefs: []
  type: TYPE_NORMAL
- en: We'll use the Spring profile identified as Docker.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: There won't be any conflict of ports among embedded Tomcat, since services will
    be executed in their own respective containers. We can now use port `8080`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We will prefer to use an IP address to register our services in Eureka. Therefore,
    the Eureka instance property `preferIpAddress` will be set to `true`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Finally, we'll use the Eureka server hostname in `serviceUrl:defaultZone`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'To add a Spring profile in your project, add the following lines in `application.yml`
    after the existing content:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: The `mvn -P docker clean package` command will generate the `service` JAR with
    Tomcat's `8080` port and will get registered on the Eureka Server with the hostname
    `eureka`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let''s configure the `docker-maven-plugin` to build the image with our
    restaurant microservice. This plugin has to create a Dockerfile first. The Dockerfile
    is configured in two placesâ€”in the `pom.xml` and `docker-assembly.xml` files.
    We''ll use the following plugin configuration in `pom.xml`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: Create a Dockerfile before the Docker Maven plugin configuration that extends
    the JRE 8 (`java:8-jre`) base image. This exposes ports `8080` and `8081`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, we''ll configure the `docker-assembly.xml` file, which tells the plugin
    which files should be put into the container. It will be placed under the `src/main/docker`
    directory:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding assembly, adds the `service` JAR and the `docker-config.yml`
    file in the generated Dockerfile. This Dockerfile is located under `target/docker/`.
    On opening this file, you will find the content to be similar to this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: The preceding file can be found in the `restaurant-service\target\docker\sousharm\restaurant-service\PACKT-SNAPSHOT\build`
    directory. The `build` directory also contains the `maven` directory, which contains
    everything mentioned in the `docker-assembly.xml` file.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s build the Docker image:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'Once this command completes, we can validate the image in the local repository
    using Docker images, or by running the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: Use `-it` to execute this command in the foreground, in place of `-d`.
  prefs: []
  type: TYPE_NORMAL
- en: Running Docker using Maven
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To execute a Docker image with Maven, we need to add the following configuration
    in the `pom.xml` file. The `<run>` block, to be put where we marked the `To Do`
    under the image block of `docker-maven-plugin` section in the `pom.xml` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: Here, we have defined the parameters for running our Restaurant service container.
    We have mapped Docker container ports `8080` and `8081` to the host system's ports,
    which allows us to access the service. Similarly, we have also bound the container's
    `log` directory to the host system's `<home>/logs` directory.
  prefs: []
  type: TYPE_NORMAL
- en: The Docker Maven plugin can detect whether the container has finished starting
    up by polling the ping URL of the admin backend until it receives an answer.
  prefs: []
  type: TYPE_NORMAL
- en: Please note that the Docker host is not localhost if you are using DockerToolbox
    or boot2docker on Windows or MacOS X. You can check the Docker image IP by executing
    `docker-machine ip default`. It is also shown while starting up.
  prefs: []
  type: TYPE_NORMAL
- en: 'The Docker container is ready to start. Use the following command to start
    it using Maven:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: Integration testing with Docker
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Starting and stopping a Docker container can be done by binding the following
    executions to the `docker-maven-plugin` life cycle phase in `pom.xml`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: We will now configure the Failsafe plugin to perform integration testing with
    Docker. This allows us to execute the integration tests. We are passing the service
    URL in the `service.url` tag, so that our integration test can use it to perform
    integration testing.
  prefs: []
  type: TYPE_NORMAL
- en: 'We''ll use the `DockerIntegrationTest` marker to mark our Docker integration
    tests. It is defined as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'Look at the following integration `plugin` code. You can see that `DockerIT`
    is configured for the inclusion of integration tests (Failsafe plugin), whereas
    it is used for excluding in unit tests (Surefire plugin):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'A simple integration test looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'You can use the following command to perform integration testing using Maven
    (please make sure to run `mvn clean install` from the root of the project directory
    before running integration tests):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: Pushing the image to a registry
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Add the following tags under `docker-maven-plugin` to publish the Docker image
    to the Docker hub:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'You can skip JAR publishing by using the following configuration for `maven-deploy-plugin`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'Publishing a Docker image in the Docker hub also requires a username and password:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: You can also push a Docker image to your own Docker registry. To do this, add
  prefs: []
  type: TYPE_NORMAL
- en: the `docker.registry.name` tag, as shown in the following code. For example,
  prefs: []
  type: TYPE_NORMAL
- en: if your Docker registry is available at `xyz.domain.com` on port `4994`, then
    define
  prefs: []
  type: TYPE_NORMAL
- en: 'it by adding the following line of code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: This does the job and we can not only deploy, but also test our Dockerized service.
  prefs: []
  type: TYPE_NORMAL
- en: Managing Docker containers
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Each microservice will have its own Docker container. Therefore, we'll use `Docker
    Compose` to manage our containers.
  prefs: []
  type: TYPE_NORMAL
- en: Docker Compose will help us to specify the number of containers and how these
    will be executed. We can specify the Docker image, ports, and each container's
    links to other Docker containers.
  prefs: []
  type: TYPE_NORMAL
- en: 'We''ll create a file called `docker-compose.yml` in our root project directory
    and add all of the microservice containers to it. We''ll first specify the Eureka
    server, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: Here, `image` represents the published Docker image for the Eureka server and
    `ports` represents the mapping between the host being used for executing the Docker
    image and the Docker host.
  prefs: []
  type: TYPE_NORMAL
- en: This will start the Eureka server and publish the specified ports for external
    access.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now our services can use these containers (dependent containers such as Eureka).
    Let''s see how `restaurant-service` can be linked to dependent containers. It
    is simple; just use the `links` directive:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding links declaration will update the `/etc/hosts` file in the `restaurant-service`
    container with one line per service that the `restaurant-service` depends on (let''s
    assume the `security` container is also linked), for example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: If you don't have a Docker local registry set up, then please do this first
    for issueless or smoother execution.
  prefs: []
  type: TYPE_NORMAL
- en: 'Build the docker local registry by running the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '**docker run -d -p 5000:5000 --restart=always --name registry registry:2**'
  prefs: []
  type: TYPE_NORMAL
- en: 'Then, perform push and pull commands for the local images:'
  prefs: []
  type: TYPE_NORMAL
- en: '**docker push localhost:5000/sourabhh/restaurant-service:PACKT- SNAPSHOT**'
  prefs: []
  type: TYPE_NORMAL
- en: '**docker-compose pull**'
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, execute docker-compose:'
  prefs: []
  type: TYPE_NORMAL
- en: '**docker-compose up -d**'
  prefs: []
  type: TYPE_NORMAL
- en: 'Once all of the microservice containers (service and server) are configured,
    we can start all Docker containers with a single command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: 'This will start up all Docker containers configured in Docker Composer. The
    following command will list them:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: 'You can also check Docker image logs using the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: References
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The following links will give you more information:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Netflix** **Ribbon**: [https://github.com/Netflix/ribbon](https://github.com/Netflix/ribbon)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Netflix** **Zuul**: [https://github.com/Netflix/zuul](https://github.com/Netflix/zuul)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**RabbitMQ**: [https://www.rabbitmq.com/download.html](https://www.rabbitmq.com/download.html)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Hystrix**: [https://github.com/Netflix/Hystrix](https://github.com/Netflix/Hystrix)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Turbine**: [https://github.com/Netflix/Turbine](https://github.com/Netflix/Turbine)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Docker**: [https://www.docker.com/](https://www.docker.com/)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this chapter, we have learned about various microservice management features:
    load balancing, edge (gateway) servers, circuit breakers, and monitoring. You
    should now know how to implement load balancing and routing after going through
    this chapter. We have also learned how edge servers can be set up and configured.
    The failsafe mechanism is another important part that you have learned in this
    chapter. Deployment can be made simple by using Docker or any other container.
    Docker was demonstrated and integrated using Maven Build.'
  prefs: []
  type: TYPE_NORMAL
- en: From a testing point of view, we performed the integration testing on the Docker
    image of the service. We also explored the way we can write clients such as `RestTemplate`
    and Netflix Feign.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will learn to secure the microservices with respect
    to authentication and authorization. We will also explore the other aspects of
    microservice securities.
  prefs: []
  type: TYPE_NORMAL
