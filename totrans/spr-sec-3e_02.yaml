- en: Getting Started with Spring Security
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we'll apply a minimal Spring Security configuration to start
    addressing our first finding-inadvertent privilege escalation due to a lack of
    URL protection, and general authentication from the security audit discussed in
    [Chapter 1](01.html), *Anatomy of an Unsafe Application*. We will then build on
    the basic configuration to provide a customized experience for our users. This
    chapter is intended to get you up and running with Spring Security and to provide
    a foundation for any other security-related tasks you will need to perform.
  prefs: []
  type: TYPE_NORMAL
- en: 'During the course of this chapter, we will cover the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Implementing a basic level of security on the JBCP calendar application, using
    the automatic configuration option in Spring Security
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Learning how to customize both the login and logout experience
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Configuring Spring Security to restrict access differently, depending on the
    URL
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Leveraging the expression-based access controls of Spring Security
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Conditionally displaying basic information about the logged-in user using the
    JSP library in Spring Security
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Determining the user's default location after login, based on their role
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Hello Spring Security
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Although Spring Security can be extremely difficult to configure, the creators
    of the product have been thoughtful and have provided us with a very simple mechanism
    to enable much of the software's functionality with a strong baseline. From this
    baseline, additional configuration will allow for a fine level of detailed control
    over the security behavior of the application.
  prefs: []
  type: TYPE_NORMAL
- en: We'll start with our unsecured calendar application from [Chapter 1](01.html),
    *Anatomy of an Unsafe Application*, and turn it into a site that's secured with
    a rudimentary username and password authentication. This authentication serves
    merely to illustrate the steps involved in enabling Spring Security for our web
    application; you'll see that there are some obvious flaws in this approach that
    will lead us to make further configuration refinements.
  prefs: []
  type: TYPE_NORMAL
- en: Importing the sample application
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We encourage you to import the `chapter02.00-calendar` project into your IDE,
    and follow along by obtaining the source code from this chapter, as described
    in the *Getting started with JBCP calendar sample code* section in the Appendix,
    *Additional Reference Material*.
  prefs: []
  type: TYPE_NORMAL
- en: For each chapter, you will find multiple revisions of the code that represent
    checkpoints within the book. This makes it easy to compare your work to the correct
    answers as you go. At the beginning of each chapter, we will import the first
    revision of that chapter as a starting point. For example, in this chapter, we
    start with `chapter02.00-calendar`, and the first checkpoint will be `chapter02.01-calendar`.
    In Appendix, *Additional Reference Material,* so be sure to refer to it for details.
  prefs: []
  type: TYPE_NORMAL
- en: Updating your dependencies
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The first step is to update the project's dependencies to include the necessary
    Spring Security JAR files. Update the Gradle `build.gradle` file (from the sample
    application you imported previously) to include the Spring Security JAR files
    that we will use in the following few sections.
  prefs: []
  type: TYPE_NORMAL
- en: Throughout the book, we will be demonstrating how to provide the required dependencies
    using Gradle. The `build.gradle` file is located in the root of the project and
    represents all that is needed to build the project (including the project's dependencies).
    Remember that Gradle will download the transitive dependencies for each listed
    dependency. So, if you are using another mechanism to manage dependencies, ensure
    that you also include the transitive dependencies. When managing the dependencies
    manually, it is useful to know that the Spring Security reference includes a list
    of its transitive dependencies. A link to the Spring Security reference can be
    found in the *Supplementary Materials* section in the *Supplementary materials*
    section in the Appendix, *Additional Reference Material*.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s take a look at the following code snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: Using Spring 4.3 and Spring Security 4.2
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Spring 4.2 is used consistently. Our sample applications provide an example
    of the former option, which means that no additional work is required by you.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the following code, we present an example fragment of what is added to the
    Gradle `build.gradle` file to utilize the dependency management feature of Gradle;
    this ensures that correct Spring version is used throughout the entire application.
    We are going to leverage the Spring IO **bill of materials** (**BOM**) dependency,
    which will ensure that all the dependency versions imported by the BOM will work
    together correctly:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: If you are using Spring Tool Suite, any time you update the `build.gradle` file,
    ensure you right-click on the project and navigate to Gradle | Refresh Gradle
    ProjectÂ¦ and select OK to update all the dependencies.
  prefs: []
  type: TYPE_NORMAL
- en: For more information about how Gradle handles transitive dependencies, as well
    as the BOM, refer to the Gradle documentation, which is listed in the *Supplementary
    materials* section, in Appendix, *Additional Reference Material*.
  prefs: []
  type: TYPE_NORMAL
- en: Implementing a Spring Security XML configuration file
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The next step in the configuration process is to create a Java configuration
    file representing all Spring Security components required to cover standard web
    requests.
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a new Java file in the `src/main/java/com/packtpub/springsecurity/configuration/`
    directory with the name `SecurityConfig.java`, and the following content. Among
    other things, the following file demonstrates user login requirements for every
    page in our application, provides a login page, authenticates the user, and requires
    the logged-in user to be associated with a role called `USER` for every URL element:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: If you are using Spring Tool Suite, you can easily review `WebSecurityConfigurerAdapter`
    by using *F3*. Remember that the next checkpoint (`chapter02.01-calendar`) has
    a working solution, so the file can be copied from there as well.
  prefs: []
  type: TYPE_NORMAL
- en: This is the only Spring Security configuration required to get our web application
    secured with a minimal standard configuration. This style of configuration, using
    a Spring Security-specific Java configuration, is known as **Java Config**.
  prefs: []
  type: TYPE_NORMAL
- en: Let's take a minute to break this configuration apart so we can get a high-level
    idea of what is happening. In the `configure(HttpSecurity)` method, the `HttpSecurity`
    object creates a Servlet Filter, which ensures that the currently logged-in user
    is associated with the appropriate role. In this instance, the filter will ensure
    that the user is associated with `ROLE_USER`. It is important to understand that
    the name of the role is arbitrary. Later, we will create a user with `ROLE_ADMIN`
    and will allow this user to have access to additional URLs that our current user
    does not have access to.
  prefs: []
  type: TYPE_NORMAL
- en: In the `configure(AuthenticationManagerBuilder)` method, the `AuthenticationManagerBuilder`
    object is how Spring Security authenticates the user. In this instance, we utilize
    an in-memory data store to compare a username and password.
  prefs: []
  type: TYPE_NORMAL
- en: Our example and explanation of what is happening are a bit contrived. An in-memory
    authentication store would not work in a production environment. However, it allows
    us to get things up and running quickly. We will incrementally improve our understanding
    of Spring Security as we update our application to use production quality security
    throughout this book.
  prefs: []
  type: TYPE_NORMAL
- en: General support for **Java Configuration** was added to Spring Framework in
    Spring 3.1\. Since Spring Security 3.2 release, there has been Spring Security
    Java Configuration support, which enables users to easily configure Spring Security
    without the use of any XML. If you are familiar with [Chapter 6](07.html), *LDAP
    Directory Services*, and the Spring Security documentation, then you should find
    quite a few similarities between it and **Security Java Configuration** support.
  prefs: []
  type: TYPE_NORMAL
- en: Updating your web.xml file
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The next steps involve a series of updates to the `web.xml` file. Some of the
    steps have already been performed because the application was already using Spring
    MVC. However, we will go over these requirements to ensure that more fundamental
    Spring requirements are understood, in the event that you are using Spring Security
    in an application that is not Spring-enabled.
  prefs: []
  type: TYPE_NORMAL
- en: The ContextLoaderListener class
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The first step of updating the `web.xml` file is to remove it and replace it
    with `javax.servlet.ServletContainerInitializer`, which is the preferred approach
    to Servlet 3.0+ initialization. Spring MVC provides the `o.s.w.WebApplicationInitializer`
    interface, which leverages this mechanism. In Spring MVC, the preferred approach
    is to extend `o.s.w.servlet.support.AbstractAnnotationConfigDispatcherServletInitializer`.
    The `WebApplicationInitializer` class is polymorphically `o.s.w.context.AbstractContextLoaderInitializer`
    and uses the abstract `createRootApplicationContext()` method to create a root
    `ApplicationContext`, then delegates it to `ContextLoaderListener`, which is registered
    in the `ServletContext` instance, as shown in the following code snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: The updated configuration will now load `SecurityConfig.class` from the classpath
    of the WAR file.
  prefs: []
  type: TYPE_NORMAL
- en: ContextLoaderListener versus DispatcherServlet
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The `o.s.web.servlet.DispatcherServlet` interface specifies configuration classes
    to be loaded on their own using the `getServletConfigClasses()` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: The `DispatcherServlet` class creates `o.s.context.ApplicationContext`, which
    is a child of the root `ApplicationContext` interface. Typically, Spring MVC-specific
    components are initialized in the `ApplicationContext` interface of `DispatcherServlet`,
    while the rest are loaded by `ContextLoaderListener`. It is important to know
    that beans in a child `ApplicationContext` (such as those created by `DispatcherServlet`)
    can reference beans of the parent `ApplicationContext` (such as those created
    by `ContextLoaderListener`). However, the parent `ApplicationContext` interface
    cannot refer to beans of the child `ApplicationContext`.
  prefs: []
  type: TYPE_NORMAL
- en: 'This is illustrated in the following diagram, in which **Child Beans** can
    refer to **Root Beans**, but **Root Beans** cannot refer to **Child Beans**:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/51f10ca9-eaa2-4b05-a6a9-2cf02949886c.png)'
  prefs: []
  type: TYPE_IMG
- en: As in most use cases of Spring Security, we do not need Spring Security to refer
    to any of the MVC-declared beans. Therefore, we have decided to have `ContextLoaderListener`
    initialize all configurations of Spring Security.
  prefs: []
  type: TYPE_NORMAL
- en: The springSecurityFilterChain filter
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The next step is to configure `springSecurityFilterChain` to intercept all
    requests by creating an implementation of `AbstractSecurityWebApplicationInitializer`.
    It is critical for `springSecurityFilterChain` to be declared first, to ensure
    the request is secured prior to any other logic being invoked. To ensure `springSecurityFilterChain`
    gets loaded first, we can use `@Order(1)` as shown in the following configuration:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: The `SecurityWebAppInitializer` class will automatically register the `springSecurityFilterChain`
    filter for every URL in your application and will add `ContextLoaderListener`,
    which loads `SecurityConfig`.
  prefs: []
  type: TYPE_NORMAL
- en: The DelegatingFilterProxy class
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The `o.s.web.filter.DelegatingFilterProxy` class is a Servlet Filter provided
    by Spring Web that will delegate all work to a Spring bean from the `ApplicationContext`
    root, which must implement `javax.servlet.Filter`. Since by default the bean is
    looked up by name, using the `<filter-name>` value, we must ensure we use `springSecurityFilterChain`
    as the value of `<filter-name>`. The pseudocode for how `o.s.web.filter.DelegatingFilterProxy`
    works for our `web.xml` file can be found in the following code snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: The FilterChainProxy class
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'When working in conjunction with Spring Security, `o.s.web.filter.DelegatingFilterProxy`
    will delegate to the `o.s.s.web.FilterChainProxy` interface of Spring Security,
    which was created in our minimal `security.xml` file. The `FilterChainProxy` class
    allows Spring Security to conditionally apply any number of Servlet Filters to
    the servlet request. We will learn more about each of the Spring Security filters,
    and their roles in ensuring that our application is properly secured, throughout
    the rest of the book. The pseudocode for how `FilterChainProxy` works are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: Due to the fact that both `DelegatingFilterProxy` and `FilterChainProxy` are
    the front door to Spring Security, when used in a web application, you would add
    a debug point when trying to figure out what is happening.
  prefs: []
  type: TYPE_NORMAL
- en: Running a secured application
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'If you have not already done so, restart the application and visit `http://localhost:8080/`.
    You will be presented with the following screen:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/f21bbf6c-69e2-4013-8263-8048fc161cc3.png)'
  prefs: []
  type: TYPE_IMG
- en: Great job! We've implemented a basic layer of security in our application using
    Spring Security. At this point, you should be able to log in using `user1@example.com`
    as User and `user1` as Password. You'll see the calendar welcome page, which describes
    at a high level what to expect from the application in terms of security.
  prefs: []
  type: TYPE_NORMAL
- en: Your code should now look like `chapter02.01-calendar`.
  prefs: []
  type: TYPE_NORMAL
- en: Common problems
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Many users have trouble with the initial implementation of Spring Security in
    their application. A few common issues and suggestions are listed next. We want
    to ensure that you can run the example application and follow along!
  prefs: []
  type: TYPE_NORMAL
- en: Make sure you can build and deploy the application before putting Spring Security
    in place.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Review some introductory samples and documentation on your servlet container
    if needed.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It's usually easiest to use an IDE, such as Eclipse, to run your servlet container.
    Not only is deployment typically seamless, but the console log is also readily
    available to review for errors. You can also set breakpoints at strategic locations,
    to be triggered by exceptions to better diagnose errors.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Make sure the versions of Spring and Spring Security that you're using match
    and that there aren't any unexpected Spring JARs remaining as part of your application.
    As previously mentioned, when using Gradle, it can be a good idea to declare the
    Spring dependencies in the dependency management section.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A little bit of polish
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Stop at this point and think about what we've just built. You may have noticed
    some obvious issues that will require some additional work and knowledge of the
    Spring Security product before our application is production-ready. Try to make
    a list of the changes that you think are required before this security implementation
    is ready to roll out on the public-facing website.
  prefs: []
  type: TYPE_NORMAL
- en: 'Applying the Hello World Spring Security implementation was blindingly fast
    and has provided us with a login page, username, and password-based authentication,
    as well as the automatic interception of URLs in our calendar application. However,
    there are gaps between what the automatic configuration setup provides and what
    our end goal is, which are listed as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: While the login page is helpful, it's completely generic and doesn't look like
    the rest of our JBCP calendar application. We should add a login form that's integrated
    with our application's look and feel.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: There is no obvious way for a user to log out. We've locked down all pages in
    the application, including the Welcome page, which a potential user may want to
    browse anonymously. We'll need to redefine the roles required to accommodate anonymous,
    authenticated, and administrative users.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We do not display any contextual information to indicate to the user that they
    are authenticated. It would be nice to display a greeting similar to welcome `user1@example.com`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'We''ve had to hardcode the username, password, and role information of the
    user in the `SecurityConfig` configuration file. Recall this section of the `configure(AuthenticationManagerBuilder)`
    method we added:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: You can see that the username and password are right there in the file. It's
    unlikely that we'd want to add a new declaration to the file for every user of
    the system! To address this, we'll need to update the configuration with another
    type of authentication.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We'll explore different authentication options throughout the first half of
    the book.
  prefs: []
  type: TYPE_NORMAL
- en: Configuring logout
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The `HttpSecurity` configuration of Spring Security automatically adds support
    for logging the user out. All that is needed is to create a link that points to
    `/j_spring_security_logout`. However, we will demonstrate how to customize the
    URL used to log the user out by performing the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Update the Spring Security configuration as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'You have to provide a link for the user to click on that will log them out.
    We will update the `header.html` file so that the `Logout` link appears on every
    page:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'The last step is to update the `login.html` file to display a message indicating
    logout was successful when the `logout` parameter is present:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: Your code should now look like `chapter02.02-calendar`.
  prefs: []
  type: TYPE_NORMAL
- en: The page isn't redirecting properly
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'If you have not already, restart the application and visit `http://localhost:8080`
    in Firefox; you will see an error, as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/4c6fdfaa-ef71-4e5a-aac8-ba674db7d23f.png)'
  prefs: []
  type: TYPE_IMG
- en: 'What went wrong? The problem is, since Spring Security is no longer rendering
    the login page, we must allow everyone (not just the `USER` role) to access the
    Login page. Without granting access to the Login page, the following happens:'
  prefs: []
  type: TYPE_NORMAL
- en: We request the Welcome page in the browser.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Spring Security sees that the Welcome page requires the `USER` role and that
    we are not authenticated, so it redirects the browser to the Login page.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The browser requests the Login page.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Spring Security sees that the Login page requires the `USER` role and that we
    are still not authenticated, so it redirects the browser to the Login page again.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The browser requests the Login page again.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Spring Security sees that the Login page requires the `USER` role, as shown
    in the following diagram:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/f7a75dc4-9fcf-44ab-be04-4402b50a9123.png)'
  prefs: []
  type: TYPE_IMG
- en: The process could just keep repeating indefinitely. Fortunately for us, Firefox
    realizes that there are too many redirects occurring, stops performing the redirect,
    and displays a very informative error message. In the next section, we will learn
    how to fix this error by configuring URLs differently, depending on the access
    that they require.
  prefs: []
  type: TYPE_NORMAL
- en: Expression-based authorization
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'You may have noticed that granting access to everyone was not nearly as concise
    as we may have liked. Fortunately, Spring Security can leverage **Spring Expression
    Language** (**SpEL**) to determine whether a user has authorization. In the following
    code snippet, you can see the updates when using SpEL with Spring Security:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: You may notice that the `/events/` security constraint is brittle. For example,
    the `/events` URL is not protected by Spring Security to restrict the `ADMIN`
    role. This demonstrates the need to ensure that we provide multiple layers of
    security. We will exploit this sort of weakness in [Chapter 11](12.html), *Fine-Grained
    Access Control*.
  prefs: []
  type: TYPE_NORMAL
- en: Changing the `access` attribute from `hasAnyRole('ANONYMOUS', 'USER')` to `permitAll()`
    might not seem like much, but this only scratches the surface of the power of
    Spring Security's expressions. We will go into much greater detail about access
    control and Spring expressions in the second half of the book. Go ahead and verify
    that the updates work by running the application.
  prefs: []
  type: TYPE_NORMAL
- en: Your code should now look like `chapter02.04-calendar`.
  prefs: []
  type: TYPE_NORMAL
- en: Conditionally displaying authentication information
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Currently, our application has no indication as to whether we are logged in
    or not. In fact, it appears as though we are always logged in since the `Logout`
    link is always displayed. In this section, we will demonstrate how to display
    the authenticated user''s username and conditionally display portions of the page
    using Thymeleaf''s Spring Security tag library. We do so by performing the following
    steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Update your dependencies to include the `thymeleaf-extras-springsecurity4`
    JAR file. Since we are using Gradle, we will add a new dependency declaration
    in our `build.gradle` file, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, we need to add `SpringSecurityDialect` to the Thymeleaf engine as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'Update the `header.html` file to leverage the Spring Security tag library.
    You can find the updates as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: The `sec:authorize` attribute determines whether the user is authenticated with
    the `isAuthenticated()`value, and displays the HTML node if the user is authenticated,
    and hides the node in the event that the user is not authenticated. The `access`
    attribute should be rather familiar from the `antMatcher().access()` element.
    In fact, both components leverage the same SpEL support. There are attributes
    in the Thymeleaf tag libraries that do not use expressions. However, using SpEL
    is typically the preferred method since it is more powerful.
  prefs: []
  type: TYPE_NORMAL
- en: The `sec:authentication` attribute will look up the current `o.s.s.core.Authentication`
    object. The `property` attribute will find the principal attribute of the `o.s.s.core.Authentication`,object,
    which in this case is `o.s.s.core.userdetails.UserDetails`. It then obtains the
    `UserDetails` username property and renders it to the page. Don't worry if the
    details of this are confusing. We are going to go over this in more detail in
    [Chapter 3](03.html), *Custom Authentication*.
  prefs: []
  type: TYPE_NORMAL
- en: If you haven't done so already, restart the application to see the updates we
    have made. At this point, you may realize that we are still displaying links we
    do not have access to. For example, `user1@example.com` should not see a link
    to the All Events page. Rest assured, we'll fix this when we cover the tags in
    greater detail in [Chapter 11](12.html), *Fine-Grained Access Control*.
  prefs: []
  type: TYPE_NORMAL
- en: 'Your code should now look like this: `chapter02.05-calendar`.'
  prefs: []
  type: TYPE_NORMAL
- en: Customizing behavior after login
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We have already discussed how to customize a user's experience during login,
    but sometimes it is necessary to customize the behavior after login. In this section,
    we will discuss how Spring Security behaves after login and will provide a simple
    mechanism to customize this behavior.
  prefs: []
  type: TYPE_NORMAL
- en: In the default configuration, Spring Security has two different flows after
    successful authentication. The first scenario occurs if a user never visits a
    resource that requires authentication. In this instance, after a successful login
    attempt, the user will be sent to the `defaultSuccessUrl()` method chained to
    the `formLogin()` method. If left undefined, `defaultSuccessUrl()` will be the
    context root of the application.
  prefs: []
  type: TYPE_NORMAL
- en: If a user requests a protected page before being authenticated, Spring Security
    will remember the last protected page that was accessed prior to authenticating,
    using `o.s.s.web.savedrequest.RequestCache`. Upon successful authentication, Spring
    Security will send the user to the last protected page that was accessed prior
    to authentication. For example, if an unauthenticated user requests the My Events
    page, they will be sent to the Login page.
  prefs: []
  type: TYPE_NORMAL
- en: After successful authentication, they will be sent to the previously requested
    My Events page.
  prefs: []
  type: TYPE_NORMAL
- en: 'A common requirement is to customize Spring Security to send the user to a
    different `defaultSuccessUrl()` method, depending on the user''s role. Let''s
    take a look at how this can be accomplished by performing the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'The first step is to configure the `defaultSuccessUrl()` method chained after
    the `formLogin()` method. Go ahead and update the `security.xml` file to use `/default`
    instead of the context root:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'The next step is to create a controller that processes `/default`. In the following
    code, you will find a sample Spring MVC controller, `DefaultController`, which
    demonstrates how to redirect administrators to the All Events page and other users
    to the Welcome page. Create a new file in the following location:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: In Spring Tool Suite, you can use *Shift* + *Ctrl* + *O* to automatically add
    the missing imports.
  prefs: []
  type: TYPE_NORMAL
- en: There are a few things to point out about `DefaultController` and how it works.
    The first is that Spring Security makes the `HttpServletRequest` parameter aware
    of the currently logged-in user. In this instance, we are able to inspect which
    role the user belongs to without relying on any of Spring Security's APIs. This
    is good because if Spring Security's APIs change or we decide we want to switch
    our security implementation, we have less code that needs to be updated. It should
    also be noted that while we implement this controller with a Spring MVC controller,
    our `defaultSuccessUrl()` method can be handled by any controller implementation
    (for example, Struts, a standard servlet, and so on) if we desire.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you wish to always go to the `defaultSuccessUrl()` method, you can leverage
    the second parameter to the `defaultSuccessUrl()` method, which is a `Boolean`
    for always use. We will not do this in our configuration, but you can see an example
    of it as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: You are now ready to give it a try. Restart the application and go directly
    to the My Events page, then log in; you will see that you are on the My Events
    page.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Next, log out and try logging in as `user1@example.com`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: You should be on the Welcome page. Log out and log in as `admin1@example.com`,
    and you will be
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: sent to the All Events page.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Your code should now look like `chapter02.06-calendar`.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we have applied a very basic Spring Security configuration,
    explained how to customize the user's login and logout experience, and demonstrated
    how to display basic information, such as a username, in our web application.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will discuss how authentication in Spring Security works
    and how we can customize it to our needs.
  prefs: []
  type: TYPE_NORMAL
