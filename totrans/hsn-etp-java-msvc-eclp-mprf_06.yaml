- en: MicroProfile Health Check and JWT Propagation
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we will introduce the MicroProfile Health Check and **JSON
    Web Token** (**JWT**) Propagation projects. The Health Check project is concerned
    with exposing the application-defined health to the outside world, and JWT Propagation
    is concerned with defining an interoperable security token and use of that token
    in an application. In this chapter, you will learn the concerns that these specifications
    address, their constructs, and how to use them in your application. The code snippets
    throughout this chapter are for reference only. If you would like a working code
    version of this specification, please refer to [Chapter 8](5535a9c6-c887-40a5-95cd-c8b51ef75bf1.xhtml),
    *A Working Eclipse MicroProfile Code Sample*.
  prefs: []
  type: TYPE_NORMAL
- en: 'We will cover the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: What a health check is
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How MicroProfile Health Check exposes the health check endpoint and the format
    of a query to that endpoint
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to write a MicroProfile Health Check for your application
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The required format for the tokens in MicroProfile JWT Propagation
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How we can leverage MicroProfile JWT Propagation for security decisions
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: To build and run the samples in this chapter, you need Maven 3.5+ and a Java
    8 JDK. The code for this chapter can be found at [https://github.com/PacktPublishing/Hands-On-Enterprise-Java-Microservices-with-Eclipse-MicroProfile/tree/master/Chapter04-healthcheck](https://github.com/PacktPublishing/Hands-On-Enterprise-Java-Microservices-with-Eclipse-MicroProfile/tree/master/Chapter04-healthcheck) and
    [https://github.com/PacktPublishing/Hands-On-Enterprise-Java-Microservices-with-Eclipse-MicroProfile/tree/master/Chapter04-jwtpropagation](https://github.com/PacktPublishing/Hands-On-Enterprise-Java-Microservices-with-Eclipse-MicroProfile/tree/master/Chapter04-jwtpropagation)
    for the MicroProfile Health Check and MicroProfile Propagation JWT sections, respectively.
  prefs: []
  type: TYPE_NORMAL
- en: Understanding health checks and how MicroProfile handles them
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In cloud-native architectures, health checks are used to determine whether a
    computing node is alive and ready to perform work. The concept of readiness describes
    the state when containers start up or roll over (that is, redeployment). During
    this time, the cloud platform needs to ensure that no network traffic is routed
    to that instance before it is ready to perform work.
  prefs: []
  type: TYPE_NORMAL
- en: Liveness, on the other hand, describes the state of a running container; that
    is, can it still respond to requests? If either the liveness or readiness states
    are seen as invalid, the computing node will be discarded (terminated or shut
    down) and eventually replaced by another, healthy, instance.
  prefs: []
  type: TYPE_NORMAL
- en: Health checks are an essential contract with the orchestration framework and
    scheduler of the cloud platform. The check procedures are provided by the application
    developer and the platform uses these to continuously ensure the availability
    of your application or service.
  prefs: []
  type: TYPE_NORMAL
- en: MicroProfile Health Check 1.0 (MP-HC) supports a single health check endpoint
    that can be utilized for either a liveness or readiness check. MicroProfile Health
    Check 2.0 plans to add support for multiple endpoints to allow an application
    to define both liveness and readiness probes.
  prefs: []
  type: TYPE_NORMAL
- en: 'The MP-HC specification details two elements: a protocol along with a response
    wire format part and a Java API for defining the response content.'
  prefs: []
  type: TYPE_NORMAL
- en: The architecture of the MP-HC feature is modeled as an application that consists
    of zero or more health check procedures that are logically linked together with
    `AND` to derive the overall health check status. A procedure represents an application-defined
    check of a required condition that has a name, state, and, optionally, data about
    the check.
  prefs: []
  type: TYPE_NORMAL
- en: The Health Check protocol and wire format
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The MP-HC specification defines the requirement to support the HTTP GET requests
    against a logical `/health` REST endpoint that may return any one of the following
    codes to represent the endpoint''s status:'
  prefs: []
  type: TYPE_NORMAL
- en: '`200`: It is up and healthy.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`500`: It is unhealthy due to an unknown error.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`503`: It is down and not ready to respond to requests.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Note that many cloud environments simply look at the request return code as
    either success or failure, so the differentiation between a `500` and `503` code
    may not be distinguishable.
  prefs: []
  type: TYPE_NORMAL
- en: The payload of a `/health` request must be a JSON object that matches the schema
    given in the following (for more information on the JSON schema syntax see [http://jsonschema.net/#/](http://jsonschema.net/#/)).
  prefs: []
  type: TYPE_NORMAL
- en: Following is ...
  prefs: []
  type: TYPE_NORMAL
- en: The Health Check Java API
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Most of the plumbing is performed by the application framework that implements
    the MP-HC specification. Your part is to decide how liveness or readiness are
    determined through the health check procedures that your microservice defines
    using the MP-HC API.
  prefs: []
  type: TYPE_NORMAL
- en: To do this, you need to implement a health check procedure by implementing one
    or more instances of the `HealthCheck` interface using beans that are marked with
    a `Health` annotation.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `HealthCheck` interface is provided in the following code block:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'The code for the `Health` annotation is provided in the following code block:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: An example `HealthCheck` implementation that represents the status of a hypothetical
    disk space check is shown in the following example. Note that the check includes
    the current free space as part of the response data. The `HealthCheckResponse` class
    supports a builder interface to populate the response object.
  prefs: []
  type: TYPE_NORMAL
- en: 'Following is a hypothetical disk space `HealthCheck` procedure implementation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: In this example, we created a health response that is named `diskspace` with
    a status of `up` and custom data named `free` with a string value of `780mb`.
  prefs: []
  type: TYPE_NORMAL
- en: Another health check example representing some service endpoint is shown in
    the following.
  prefs: []
  type: TYPE_NORMAL
- en: 'A hypothetical service `HealthCheck` procedure implementation is shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'In this example, we created a health response named `service-check` with a
    status of `up` that includes the following additional data:'
  prefs: []
  type: TYPE_NORMAL
- en: A `port` item with an integer value of `12345`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: An `isSecure` item with a Boolean value of `true`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A `hostname` item with a string value of `service.jboss.com`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The CDI-managed health checks are discovered and registered automatically by
    the application runtime. The runtime automatically exposes an HTTP endpoint, `/health`,
    used by the cloud platform to poke into your application to determine its state.
    You can test this by building the `Chapter04-healthcheck` application and running
    it. You will see the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'Once the server has started, test the health checks by querying the health
    endpoint:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'This shows the overall health to be `UP`. The overall status is the logical
    `OR` of all of the health check procedures found in the application. In this case,
    it is `AND` of the two health check procedures we have seen: `diskspace` and `service-check`.'
  prefs: []
  type: TYPE_NORMAL
- en: Integration with the cloud platform
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Most cloud platforms support both TCP- and HTTP-based checks. To integrate health
    checks with your selected cloud platform, you need to configure your cloud deployment
    to point to the HTTP entry point, `/health`, on the node that hosts your application.
  prefs: []
  type: TYPE_NORMAL
- en: The cloud platform will invoke a `GET` query on the HTTP entry point; all checks
    that are registered will be performed and the sum of individual checks determines
    the overall outcome.
  prefs: []
  type: TYPE_NORMAL
- en: Usually, the response payload is ignored by the cloud platform and it only looks
    at the HTTP status code to determine the liveness or readiness of your application.
    A successful outcome, `UP`, will be mapped to `200` and `DOWN` to `503`.
  prefs: []
  type: TYPE_NORMAL
- en: Human operators
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The primary use case for the JSON response payload is to provide a way for
    operators to investigate the application state. To support this, health checks
    allow for additional data to be attached to a health check response as we have
    seen in the `CheckDiskspace` and `ServiceCheck` examples. Consider the following
    fragment:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'Here, the additional information about `free-heap` is provided and will become
    part of the response payload, as shown in this response fragment. The JSON response
    fragment showing `memory-check` procedure content is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: Here, we see the `memory-check` procedure with its `UP` state and additional
    `free-heap` data item of the string type with the value of `64mb`.
  prefs: []
  type: TYPE_NORMAL
- en: '**Eclipse resources/GitHub coordinates for MP-Health**:'
  prefs: []
  type: TYPE_NORMAL
- en: The MP-Health project source code can be found at [https://github.com/eclipse/microprofile-health](https://github.com/eclipse/microprofile-health).
  prefs: []
  type: TYPE_NORMAL
- en: Changes in Health Check response messages
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: MicroProfile Health Check 3.0 introduced changes to the message format of health
    check JSON responses. Specifically, the field's outcome and state have been replaced
    by the field status.
  prefs: []
  type: TYPE_NORMAL
- en: In addition, the `@Health` qualifier was deprecated in the Health Check 3.0
    release, while the `@Liveness` and `@Readiness` qualifiers were introduced. For
    the two qualifiers, the `/health/live` and `/health/ready` endpoints were also
    introduced to call all the liveliness and readiness procedures, respectively.
    Lastly, for backward compatibility, `/health` endpoint now calls all the procedures
    that have `@Health`, `@Liveness`, or `@Readiness` qualifiers.
  prefs: []
  type: TYPE_NORMAL
- en: It's time to discuss JWT Propagation now.
  prefs: []
  type: TYPE_NORMAL
- en: Using JSON Web Token Propagation in MicroProfile
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A **JSON Web Token** (**JWT**) is a common format for carrying security information
    that is used by many different web-based security protocols. However, there is
    a lack of standardization around exactly what the contents of the JWT are and
    what security algorithms are used with signed JWTs. The **MicroProfile JWT** (**MP-JWT**) Propagation
    project specification looked at the **OpenID Connect** (**OIDC**)-based ([http://openid.net/connect/](http://openid.net/connect/)) JWT
    ([https://tools.ietf.org/html/rfc7519](https://tools.ietf.org/html/rfc7519)) specifications
    and built upon those to define a set of requirements to promote interoperability
    of JWTs for use in MicroProfile-based microservices, along with APIs to access
    information from the JWTs.
  prefs: []
  type: TYPE_NORMAL
- en: For a description of how OIDC and JWT work, including how an application/microservice
    intercepts bearer tokens, please refer to the *Basic Client Implementer's Guide*
    at [http://openid.net/connect/](http://openid.net/connect/).
  prefs: []
  type: TYPE_NORMAL
- en: 'In this section, you will learn about the following:'
  prefs: []
  type: TYPE_NORMAL
- en: The claims and signature algorithms from OIDC and JWT specifications that were
    required for interoperability
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using JWTs for **Role-Based Access Control** (**RBAC**) of microservice endpoints
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to use the MP-JWT APIs to access a JWT and its claim values
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Recommendations for interoperability
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The maximum utility of MP-JWT as a token format depends on the agreement between
    both identity providers and service providers. This means identity providers—responsible
    for issuing tokens—should be able to issue tokens using the MP-JWT format in a
    way that service providers can understand to inspect the token and gather information
    about a subject. The primary goals for MP-JWT are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: It should be usable as an authentication token.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It should be usable as an authorization token that contains application-level
    roles indirectly granted via a group's claim.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It can support additional standard claims described in IANA JWT Assignments
    ([https://www.iana.org/assignments/jwt/jwt.xhtml](https://www.iana.org/assignments/jwt/jwt.xhtml)),
    as well as non-standard ...
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Required MP-JWT claims
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The required set of MP-JWT claims for which an implementation needs to provide
    support contains the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '`typ`: This header parameter identifies the token type and is required to be
    `JWT`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`alg`: This header algorithm was used to sign the JWT and must be specified
    as `RS256`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`kid`: This header parameter provides a hint about which public key was used
    to sign the JWT.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`iss`: This is the issuer and signer of the token.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`sub`: This identifies the subject of the JWT.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`exp`: This identifies the expiration time on, or after, which the JWT MUST
    NOT be accepted for processing.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`iat`: This identifies the time at which the JWT was issued and can be used
    to determine the age of the JWT.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`jti`: This provides a unique identifier for the JWT.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`upn`: This MP-JWT custom claim is the preferred way to specify a user principal
    name.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`groups`: This MP-JWT custom claim is the list of group or role names assigned
    to the JWT principal.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`NumericDate` used by `exp`, `iat`, and other date-related claims is a JSON
    numeric value representing the number of seconds from `1970-01-01T00:00:00Z` UTC
    until the specified UTC date/time, ignoring leap seconds. Additionally, more details
    about the standard claims may be found in the MP-JWT specification ([https://github.com/eclipse/microprofile-jwt-auth/releases/tag/1.1.1](https://github.com/eclipse/microprofile-jwt-auth/releases/tag/1.1.1))
    and the JSON Web Token RFC ([https://tools.ietf.org/html/rfc7519](https://tools.ietf.org/html/rfc7519)).'
  prefs: []
  type: TYPE_NORMAL
- en: 'An example basic MP-JWT in JSON would be a sample header and payload of an
    MP-JWT compatible JWT, as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: This example shows the header with `typ=JWT`, `alg=RS256`, and `kid=abc-1234567890`.
    The body includes the `iss`, `jti`, `exp`, `iat`, `sub`, `upn`, and `groups` claims.
  prefs: []
  type: TYPE_NORMAL
- en: The high-level description of the MP-JWT API
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The MP-JWT project introduces the following API interfaces and classes under
    the `org.eclipse.microprofile.jwt` package namespace:'
  prefs: []
  type: TYPE_NORMAL
- en: '`JsonWebToken`: This is a `java.security.Principal` interface extension that
    makes the set of required claims available via get-style accessors, along with
    general access to any claim in the JWT.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Claims`: This is an enumeration utility class that encapsulates all of the
    standard JWT-related claims along with a description and the required Java type
    for the claim as returned from the `JsonWebToken#getClaim(String)` method.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Claim`: This is a qualifier annotation used to signify an injection point
    for `ClaimValue`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`ClaimValue<T>`: This is a `java.security.Principal` interface extension ...'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Sample code that uses MP-JWT
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The basic usage of the MP-JWT API is to inject `JsonWebToken`, its `ClaimValue`,
    or both. In this section, we present snippets of typical usage. This book's code
    for this section is available at [https://github.com/PacktPublishing/Hands-On-Enterprise-Java-Microservices-with-Eclipse-MicroProfile/tree/master/Chapter04-jwtpropagation](https://github.com/PacktPublishing/Hands-On-Enterprise-Java-Microservices-with-Eclipse-MicroProfile/tree/master/Chapter04-jwtpropagation).
  prefs: []
  type: TYPE_NORMAL
- en: Injection of JsonWebToken information
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The following code sample illustrates access of the incoming MP-JWT token as `JsonWebToken`,
    the raw JWT token string, the `upn` claim, and integration with JAX-RS `SecurityContext`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: Injection of JWT claim values
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The code snippet in this section illustrates the injection of individual JWT
    claim values. There are several different formats we can use for the injected
    value. Standard claims support the object subtypes defined in the `Claim#getType`
    field and `JsonValue` subtypes. Custom claim types only support the injection
    of the `JsonValue` subtypes.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following code example illustrates injection of the standard `groups` and
    `iss` claims, along with `customString`, `customInteger`, `customDouble`, and
    `customObject` custom claims:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'The eight commented injections are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Injection of the standard `groups` claim as its default `Set<String>` type
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Injection of the standard `iss` claim as its default String type
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Injection of the standard `groups` claim as its default `JsonArray` type
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Injection of the standard `iss` claim as its default `JsonString` type
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Injection of a non-standard `customString` claim as a `JsonString` type
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Injection of a non-standard `customInteger` claim as a `JsonNumber` type
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Injection of a non-standard `customDouble` claim as a `JsonNumber` type
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Injection of a non-standard `customObject` claim as a `JsonString` type
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Configuring authentication of JWTs
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To accept a JWT as representing an identity that should be authenticated and
    therefore trusted, we need to configure the MP-JWT feature with the information
    to verify who signed and who issued the JWT. This is done via MP-Config properties:'
  prefs: []
  type: TYPE_NORMAL
- en: '`mp.jwt.verify.publickey`: This provides the embedded key material of the public
    key for the MP-JWT signer, typically in PKCS8 PEM format.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`mp.jwt.verify.issuer`: This specifies the expected value of the `iss` claim
    found in the JWT.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'An example `microprofile-configuration.properties` file for this book is as
    follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: Running the samples
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The samples we looked at can be deployed to Thorntail and accessed via command-line
    queries against the endpoints to validate the expected behaviors. Since authentication
    against the endpoints marked with security constraints requires a valid JWT, we
    need a way to generate a JWT that will be accepted by the Thorntail server.
  prefs: []
  type: TYPE_NORMAL
- en: 'This chapter''s code provides an `io.packt.jwt.test.GenerateToken` utility
    that will create a JWT signed by a key that has been configured with the Thorntail
    server. The claims included in the JWT are defined by the `src/test/resources/JwtClaims.json`
    document of this chapter''s project. You run the utility using the `mvn exec:java`
    command, as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'The utility outputs the claims that were added and then prints out the base64-encoded
    JWT. You would use this JWT as the value in the `Authorization: Bearer …` header
    of the `curl` command line you used to access the server endpoints.'
  prefs: []
  type: TYPE_NORMAL
- en: 'To start up the Thorntail server with the example endpoints, `cd` into the `Chapter04-jwtpropagation` project
    directory and then run `mvn` to build the executable JAR:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'The resulting executable JAR is located at `target/jwt-propagation-thorntail.jar`.
    You start up the Thorntail server with this chapter''s sample deployment using
    `java -jar …`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'At this point, we can query the server endpoints. There is one endpoint that
    we defined that does not require any authentication. This is the `jwt/openHello`
    endpoint of the `io.pckt.jwt.rest.SecureEndpoint` class. Run the following command
    to validate that your Thorntail server is running as expected:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, try the secured endpoint. It should fail with a 401 Not authorized error
    because we are not providing any authorization information:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, we need to generate a fresh JWT and pass that along with the curl command
    in the `Authorization` header, so let''s try that. We will save the JWT generated
    by the mvn command in a JWT environment variable to simplify the curl command
    line:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: In the previous code snippet, for Windows users, please install a bash-compatible
    shell for Windows; otherwise, you will get an error due to the `echo` command.
  prefs: []
  type: TYPE_NORMAL
- en: This time, the query succeeds and we see that the username, `upn` claim value,
    scheme, and `isUserInRole("User")` check are as expected.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, try accessing the `/jwt/printClaims` endpoint that illustrated the injection
    of standard and non-standard claims as different types:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'Note that, if you begin to experience `Not authorized errors` after a while,
    the problem is that the JWT has expired. You either need to generate a new token
    or generate a token with a longer expiration. You can do this by passing in the
    expiration in seconds to the `GenerateToken` utility. For example, to generate
    a token that is valid for a full hour''s use, perform the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: These samples should give you a feel for the interaction between the microservice
    client and how the use of JWTs to secure microservice endpoints allows for stateless
    authentication and RBAC, as well as custom authorization based on claims in the
    JWT.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we learned about the MicroProfile Health Check and JWT Propagation
    projects. You should now understand what a health check is and how to add application-specific
    checks, known as procedures. These allow your microservice to describe its non-trivial
    health requirements in a cloud environment. You should also understand how JWTs
    can be used to provide an authentication and authorization capability on top of
    your microservices to control access to your endpoints. You should also understand
    how content from the JWT can be used to augment your microservice in user-specific
    ways.
  prefs: []
  type: TYPE_NORMAL
- en: The next chapter will introduce the MicroProfile Metrics and OpenTracing features.
    These allow your microservices to provide additional information ...
  prefs: []
  type: TYPE_NORMAL
- en: Questions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Is the MP-HC wire format useful in all environments?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Can an MP-HC response contain arbitrary properties?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What if my application has different types of services that need to report health
    status?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What is a JWT?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What is a claim?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Are there restrictions on what can be in a JWT?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What is/are the main step(s) in authenticating a JWT?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Beyond the security annotations, how might we perform an authorization check
    using JWTs?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
