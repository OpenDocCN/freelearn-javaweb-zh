- en: Creating a Set of Cooperating Microservices
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we will build our first couple of microservices. We will learn
    how to create cooperating microservices with minimalistic functionality. In upcoming
    chapters, we will add more and more functionality to these microservices. By the
    end of this chapter, we will have a RESTful API exposed by a composite microservice.
    The composite microservice will call three other microservices using their RESTful
    API's to create an aggregated response.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following topics will be covered in this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: Introducing the microservice landscape
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Generating skeleton microservices
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Adding RESTful APIs
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Adding a composite microservice
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Adding error handling
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Testing the APIs manually
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Adding automated tests of microservices in isolation
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Adding semi-automated tests to a microservice landscape
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: All of the commands that are described in this book are run on a MacBook Pro
    using macOS Mojave but should be straightforward to modify so that they can be
    run on another platform such as Linux or Windows.
  prefs: []
  type: TYPE_NORMAL
- en: Tool installation
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To be able to execute the commands that are used in this chapter, you need
    to have the following tools installed on your computer:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Git: **Can be downloaded and installed from [https://git-scm.com/downloads](https://git-scm.com/downloads).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Java: **Can be downloaded and installed from [https://www.oracle.com/technetwork/java/javase/downloads/index.html](https://www.oracle.com/technetwork/java/javase/downloads/index.html).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`curl`: This command-line tool for testing HTTP-based APIs can be downloaded
    and installed from [https://curl.haxx.se/download.html](https://curl.haxx.se/download.html).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`jq`: This command-line JSON processor can be downloaded and installed from [https://stedolan.github.io/jq/download/](https://stedolan.github.io/jq/download/).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Spring Boot CLI**: This command-line tool for Spring Boot applications can
    be downloaded and installed from [https://docs.spring.io/spring-boot/docs/current/reference/html/getting-started-installing-spring-boot.html#getting-started-installing-the-cli](https://docs.spring.io/spring-boot/docs/current/reference/html/getting-started-installing-spring-boot.html#getting-started-installing-the-cli).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Installing Homebrew
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To install these tools on macOS, I recommend that you use Homebrew, [https://brew.sh/](https://brew.sh/).
    If you don''t have it installed, you can install it with the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: Installing the command-line tools for Xcode installs Homebrew, so it might take
    a while if you don't have it installed already.
  prefs: []
  type: TYPE_NORMAL
- en: 'Verify the installation of Homebrew with the following commands:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'Expect a response such as the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: Using Homebrew to install Java, curl, jq, and the Spring Boot CLI
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'On a macOS, `curl` is already preinstalled and `git` was installed as part
    of the installation of Homebrew. The remaining tools can be installed on a macOS
    using Homebrew with the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'The installation of these tools can be verified by the following commands:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'These commands will return something like the following (some extra irrelevant
    output was removed):'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/cf7decb8-42ed-41c9-a9fe-6143e7d1c0e5.png)'
  prefs: []
  type: TYPE_IMG
- en: Using an IDE
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: I recommend that you work with your Java code using an IDE that supports the
    development of Spring Boot applications such as Spring Tool Suite or IntelliJ
    IDEA Ultimate Edition. See the *Testing APIs manually* section to learn how to
    use the Spring Boot Dashboard. However, you don't need an IDE to be able to follow
    the instructions in this book.
  prefs: []
  type: TYPE_NORMAL
- en: Accessing the source code
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The source code for this chapter can be found in this book''s GitHub repository:
    [https://github.com/PacktPublishing/Hands-On-Microservices-with-Spring-Boot-and-Spring-Cloud/tree/master/Chapter03](https://github.com/PacktPublishing/Hands-On-Microservices-with-Spring-Boot-and-Spring-Cloud/tree/master/Chapter03).'
  prefs: []
  type: TYPE_NORMAL
- en: 'To be able to run the commands that are described in this book, download the
    source code to a folder and set up an environment variable, `$BOOK_HOME`, that
    points to that folder. Some sample commands are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: The Java source code is written for Java 8 and tested to run on Java 12\. To
    avoid some problems with Spring Boot 2.0 (and Spring 5.0), this chapter uses Spring
    Boot 2.1.0 RC1 (and Spring 5.1.1), the latest available version of Spring Boot
    at the time of writing.
  prefs: []
  type: TYPE_NORMAL
- en: The code examples in this chapter all come from the source code in `$BOOK_HOME/Chapter03`
    but are in many cases edited to remove irrelevant parts of the source code, such
    as comments, imports, and log statements.
  prefs: []
  type: TYPE_NORMAL
- en: With this, we have the required tools installed and the source code for the
    chapter downloaded. In the next section, we will learn about the system landscape
    of cooperating microservices that we will create in this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Introducing the microservice landscape
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In [Chapter 1](282e7b49-42b8-4649-af81-b4b6830d391d.xhtml), *Introduction to
    Microservices*, we were briefly introduced to the microservice-based system landscape
    that we will use throughout this book:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/cf74f5f6-c0f7-471c-8eae-a2566ecee996.png)'
  prefs: []
  type: TYPE_IMG
- en: It consists of three core microservices, the **Product**, **Review**, and **Recommendation**
    services, all of which deal with one type of resource, and a composite microservice
    called the **Product Composite** service, which aggregates information from the
    three core services.
  prefs: []
  type: TYPE_NORMAL
- en: Temporarily replacing a discovery service
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Since, at this stage, we don''t have any service discovery mechanism in place,
    we will use hardcoded port numbers for each microservice. We will use the following
    ports:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Product composite service: `7000`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Product service: `7001`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Review service: `7002`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Recommendation service: `7003`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We will get rid of the hardcoded ports later when we start using Docker and
    Kubernetes!
  prefs: []
  type: TYPE_NORMAL
- en: In this section, we have been introduced to the microservices we are going to
    create and the information that they will handle. In the next section, we will
    use Spring Initializr to create skeleton code for the microservices.
  prefs: []
  type: TYPE_NORMAL
- en: Information handled by microservices
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: To keep the source code examples in this book easy to understand, they have
    a minimal amount of business logic. The information model for the business objects
    they process is kept minimal for the same reason. In this section, we will go
    through the information that's handled by each microservice, plus infrastructure-related
    information that microservices handle.
  prefs: []
  type: TYPE_NORMAL
- en: Product service
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The `product` service manages product information and describes each product
    with the following attributes:'
  prefs: []
  type: TYPE_NORMAL
- en: Product ID
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Name
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Weight
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Review service
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The `review` service manages product reviews and stores the following information
    about each review:'
  prefs: []
  type: TYPE_NORMAL
- en: Product ID
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Review ID
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Author
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Subject
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Content
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Recommendation service
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The `recommendation` service manages product recommendations and stores the
    following information about each recommendation:'
  prefs: []
  type: TYPE_NORMAL
- en: Product ID
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Recommendation ID
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Author
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Rate
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Content
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Product composite service
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The product composite service aggregates information from the three core services
    and presents information about a product as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Product information, as described in the `product` service
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A list of product reviews for the specified product, as described in the `review`
    service
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A list of product recommendations for the specified product, as described in
    the `recommendation` service
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Infrastructure-related information
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Once we start to run our microservices as containers that are managed by the
    infrastructure (first Docker and later on Kubernetes), it will be of interest
    to track which container actually responded to our requests. To simplify this
    tracking, we have also added a `serviceAddress` attribute to all our responses, formatted
    as `hostname/ip-address:port`.
  prefs: []
  type: TYPE_NORMAL
- en: Generating skeleton microservices
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now it's time to see how we can create projects for our microservices. The final
    result for this topic can be found in the `$BOOK_HOME/Chapter03/1-spring-init`folder.
    To simplify setting up the projects, we will use Spring Initializr to generate
    a skeleton project for each microservice. A skeleton project contains the necessary
    files for building the project, along with an empty `main` class and test class
    for the microservice. After that, we will see how we can build all our microservices
    with one command using multi-project builds in the build tool that we will use,
    Gradle.
  prefs: []
  type: TYPE_NORMAL
- en: Using Spring Initializr to generate skeleton code
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: To get started with developing our microservices, we will use a tool called
    **Spring Initializr** to generate skeleton code for us. It can either be invoked
    from a web browser using the [https://start.spring.io/](https://start.spring.io/) URL
    or by a command-line tool, `spring init`. To make it easier to reproduce the creation
    of the microservices, we will use the command-line tool.
  prefs: []
  type: TYPE_NORMAL
- en: 'For each microservice, we will create a Spring Boot project which does the
    following:'
  prefs: []
  type: TYPE_NORMAL
- en: Uses Gradle as a build tool
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Generates code for Java 8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Packages the project as a fat JAR file
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Brings in dependencies for the `Actuator` and `WebFlux` Spring modules
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Is based on Spring Boot v2.1.0 RC1 (which depends on Spring Framework v5.1.1)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Spring Boot Actuator enables a number of valuable endpoints for management and
    monitoring. We will see them in action later on. Spring WebFlux will be used here
    to create our RESTful APIs.
  prefs: []
  type: TYPE_NORMAL
- en: 'To create skeleton code for our microservices, we need to run the following
    command for `product-service`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: If you want to learn more about the `spring init` CLI, you can run the `spring
    help init` command. To see what dependencies you can add, run the `spring init
    --list` command.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you want to create the four projects on your own instead of using the source
    code in this book''s GitHub repository, try out `$BOOK_HOME/Chapter03/1-spring-init/create-projects.bash`,
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'After creating our four projects using `create-projects.bash`, we will have
    the following file structure:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'For each project, we can list the created files. Let''s do this for the `product-service`
    project:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'We will receive the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/21a0ab5c-8c4c-4898-9cab-598833bd976f.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Spring Initializr created a number of files for Gradle, including a `.gitignore`
    file and three Spring Boot files:'
  prefs: []
  type: TYPE_NORMAL
- en: '`ProductServiceApplication.java`, our main application class'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`application.properties`, an empty property file'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`ProductServiceApplicationTests.java`, a test class that''s been configured
    to run tests on our Spring Boot application using JUnit'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The `main` application class, `ProductServiceApplication.java`, looks as we''d
    expect based on the previous chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'The test class looks as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: The `@RunWith(SpringRunner.class)` and `@SpringBootTest` annotations will initialize
    our application in the same way as `@SpringBootApplication` does when running
    the application; that is, the Spring application context will be set up before
    the tests are executed using component scanning and auto-configuration, as described
    in the previous chapter.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s also look at the most important Gradle file, `build.gradle`. The content
    of this file describes how to build the project, for example, compile, test, and
    package the source code. The Gradle file starts by setting up the conditions for
    the rest of the build file by declaring the `buildscript` element and listing
    what plugins to apply:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s explain the preceding source code in more detail:'
  prefs: []
  type: TYPE_NORMAL
- en: The Spring Boot version is set to what we specified when we ran the `spring
    init` command, `2.1.0.RC1`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A number of Gradle plugins are declared. The most important ones are the `org.springframework.boot` and `io.spring.dependency-management` plugins,
    which together ensure that Gradle will build a fat JAR file and that we don't
    need to specify any explicit version numbers on our Spring Boot starter dependencies.
    Instead, they are implied by the `springBootVersion` property.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Plugins are fetched from the central Maven repository and from Spring's snapshot
    and milestone repositories since we have specified a release candidate of Spring
    Boot, v2.1.0 RC1, and not a version that's been released and is available in the
    central Maven repository.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'In the rest of the build file, we basically declare a group name and version
    for our project, Java version, and its dependencies:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s explain the preceding source code in more detail as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Dependencies are, as with the preceding plugins, fetched from the central Maven
    repository and from Spring's snapshot and milestone repositories.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Dependencies are set up as specified in the `Actuator` and `WebFlux` modules,
    along with a couple of useful test dependencies.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'We can build each microservice separately with the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: Note how we use the `gradlew` executables that are created by Spring Initializr;
    that is, we don't need to have Gradle installed!
  prefs: []
  type: TYPE_NORMAL
- en: The first time we run a command with `gradlew`, it will download Gradle automatically.
    The Gradle version that's used is determined by the `distributionUrl` property
    in the `gradle/wrapper/gradle-wrapper.properties` file.
  prefs: []
  type: TYPE_NORMAL
- en: Setting up multi-project builds in Gradle
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To make it a bit simpler to build all the microservices with one command, we
    can set up a multi-project build in Gradle. The steps are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: 'First, we create the `settings.gradle` file, which describes what projects
    that Gradle should build:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, we copy the Gradle executable files that were generated from one of the
    projects so that we can reuse them for the multi-project builds:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'We no longer need the generated Gradle executable files in each project, so
    we can remove them with the following commands:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: The result should be similar to the code you can find in the folder `$BOOK_HOME/Chapter03/1-spring-init`**.**
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, we can build all the microservices with one command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'If you haven''t run the preceding commands, you can simply go to the book''s
    source code and build it from there:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'This should result in the following output:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/efd0c892-cbca-4962-8248-b17da6fe8cd0.png)'
  prefs: []
  type: TYPE_IMG
- en: With skeleton projects for the microservices created using Spring Initializr
    and successfully built using Gradle, we are ready to add some code to the microservices
    in the next section.
  prefs: []
  type: TYPE_NORMAL
- en: From a DevOps perspective, a multi-project setup might not be preferred. Instead,
    setting up a separate build pipeline for each microservice project would probably
    be preferred. However, for the purposes of this book, we will use the multi-project
    setup to make it easier to build and deploy the whole system landscape with a
    single command.
  prefs: []
  type: TYPE_NORMAL
- en: Adding RESTful APIs
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now that we have projects set up for our microservices, let's add some RESTful
    APIs to our three core microservices!
  prefs: []
  type: TYPE_NORMAL
- en: The final result of this and the remaining topics in this chapter can be found
    in the `$BOOK_HOME/Chapter03/2-basic-rest-services`folder.
  prefs: []
  type: TYPE_NORMAL
- en: First, we will add two projects (`api` and `util`) that will contain code that
    is shared by the microservice projects, and then we will implement the RESTful
    APIs.
  prefs: []
  type: TYPE_NORMAL
- en: Adding an API and a util project
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To add an API, we need to do the following:'
  prefs: []
  type: TYPE_NORMAL
- en: First, we will set up a separate Gradle project where we can place our API definitions.
    We will use Java interfaces in order to describe our RESTful APIs and model classes
    to describe the data that the API uses in its requests and responses. Describing
    a RESTful API in a Java interface instead of directly in the Java class is, to
    me, a good way of separating the API definition from its implementation. We will
    further extend this pattern later in this book when we add more API information
    in the Java interfaces to be exposed in the Swagger/OpenAPI definition. See [Chapter 5](ba24a656-10a1-4a3e-879e-6589621ef125.xhtml),
    *Adding an API Description Using OpenAPI/Swagger*, for more information.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Describing RESTful APIs in Java interfaces wasn't fully supported until Spring
    Framework v5.1.0\. See [https://jira.spring.io/browse/SPR-11055](https://jira.spring.io/browse/SPR-11055)
    for details.
  prefs: []
  type: TYPE_NORMAL
- en: It is debatable whether it is good practice to store API definitions for a group
    of microservices in a common API module. To me, it is a good choice for microservices
    that are part of the same delivery organization, that is, whose releases are governed
    by one and the same organization (compare to a *Bounded Context* in *Domain-Driven
    Design*, where our microservices are placed in one and the same bounded context).
  prefs: []
  type: TYPE_NORMAL
- en: Next, we will create a `util` project that can hold some helper classes that
    are shared by our microservices, for example, for handling errors in a uniform
    way.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Again, from a DevOps perspective, it would be preferable to build all the projects
    in their own build pipeline and have version-controlled dependencies for the `api`
    and `util` projects in the microservice projects; that is, so that each microservice
    can choose what versions of the `api` and `util` projects to use. But to keep
    the build and deployment steps simple in the context of this book, we will make
    the `api` and `util` projects part of the multi-project build.
  prefs: []
  type: TYPE_NORMAL
- en: The api project
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `api` project will be packaged as a library; that is, it won't have its
    own `main` application class. Unfortunately, Spring Initializr doesn't support
    the creation of library projects. Instead, a library project has to be created
    manually from scratch. The source code for the API project is available at `$BOOK_HOME/Chapter03/2-basic-rest-services/api`**.**
  prefs: []
  type: TYPE_NORMAL
- en: 'The structure of a library project is the same as for an application project,
    except that we no longer have the `main` application class, as well as some minor
    differences in the `build.gradle` file. The Gradle `org.springframework.boot`
    and `io.spring.dependency-management` plugins are replaced with a `dependencyManagement`
    section:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: This allows us to retain Spring Boot dependency management while we are replacing
    the construction of a fat JAR in the build step with the creation of normal JAR
    files; that is, they only contain the library project's own class and property
    files.
  prefs: []
  type: TYPE_NORMAL
- en: 'The Java files in the `api` project for our three core microservices are as
    follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: The structure of the Java classes looks very similar for the three core microservices,
    so we will only go through the source code for the `product` service.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, we will look at the `ProductService.java` Java interface, as shown in
    the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s explain the preceding source code in more detail:'
  prefs: []
  type: TYPE_NORMAL
- en: The `product` service only exposes one API method, `getProduct()` (we will extend
    the API later in this book).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: To map the method to an HTTP `GET` request, we use the `@GetMapping` Spring
    annotation, where we specify what URL path the method will be mapped to (`/product/{productId}`)
    and what format the response will be, in this case, JSON.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `{productId}` part of the path maps to a `path` variable named `productId`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `productId` method parameter is annotated with `@PathVariable`, which will
    map the value that's passed in the HTTP request to the parameter. For example,
    an HTTP `GET` request to `/product/123` will result in the `getProduct()` method
    being called with the `productId` parameter set to `123`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The method returns a `Product` object, a plain POJO-based model class with
    the member variables corresponding to attributes for `Product`, as described at
    the start of this chapter. `Product.java` looks as follows (with constructors
    and getter methods excluded):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: This type of POJO class is also known as a **Data Transfer Object** (**DTO**)
    as it is used to transfer data between the API implementation and the caller of
    the API. When we get to [Chapter 6](6c495e97-f473-4cb1-a404-11fd938f5478.xhtml),
    *Adding Persistence*, we will look at another type of POJO that can be used to
    describe how data is stored in the databases, also known as entity objects.
  prefs: []
  type: TYPE_NORMAL
- en: The util project
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The `util` project will be packaged as a library in the same way as the `api`
    project. The source code for the `util` project is available at `$BOOK_HOME/Chapter03/2-basic-rest-services/util`.
    The project contains the following Java files:'
  prefs: []
  type: TYPE_NORMAL
- en: The `InvalidInputException` and `NotFoundException` exception classes
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `GlobalControllerExceptionHandler`, `HttpErrorInfo`, and `ServiceUtil` utility
    classes
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Except for the code in `ServiceUtil.java`, these classes are reusable utility
    classes that we can use to map Java exceptions to proper HTTP status codes, as
    described in the *Adding error handling* section. The main purpose of `ServiceUtil.java`
    is to find out the hostname, IP address, and port used by the microservice. The
    class exposes a method, `getServiceAddress()`, that can be used by the microservices
    to find their hostname, IP address, and port.
  prefs: []
  type: TYPE_NORMAL
- en: Implementing our API
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now we can start to implement our APIs in the core microservices!
  prefs: []
  type: TYPE_NORMAL
- en: 'The implementation looks very similar for the three core microservices, so
    we will only go through the source code for the `product` service. You can find
    the other files in `$BOOK_HOME/Chapter03/2-basic-rest-services/microservices`.
    Let''s see how we go about this:'
  prefs: []
  type: TYPE_NORMAL
- en: 'We need to add the `api` and `util` projects as dependencies in our `build.gradle`
    file, that is, `$BOOK_HOME/Chapter03/2-basic-rest-services/microservices/product-service/build.gradle`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'To enable Spring Boot''s autoconfiguration feature to detect Spring beans in
    the `api` and `util` projects, we also need to add a `@ComponentScan` annotation
    to the `main` application class, which includes the packages of the `api` and
    `util` projects:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, we create our service implementation file, `ProductServiceImpl.java`,
    in order to implement the Java interface, `ProductService`, from the `api` project
    and annotate the class with `@RestController` so that Spring will call the methods
    in this class according to the mappings specified in the `Interface` class:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'To be able to use the `ServiceUtil` class from the `util` project, we will
    inject it into the constructor, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, we can implement the API by overriding the `getProduct()` method from
    the interface in the `api` project:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: Since we aren't currently using a database, we simply return a hardcoded response
    based on the input of `productId`, along with the service address supplied by
    the `ServiceUtil` class.
  prefs: []
  type: TYPE_NORMAL
- en: For the final result, including logging and error handling, see `$BOOK_HOME/Chapter03/2-basic-rest-services/microservices/product-service/src/main/java/se/magnus/microservices/core/product/services/ProductServiceImpl.java`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, we also need to set up some runtime properties – what port to use
    and the desired level of logging. This is added to the `$BOOK_HOME/Chapter03/2-basic-rest-services/microservices/product-service/src/main/resources/application.yml`
    property file:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'We can try out the `product` service on its own. Build and start the microservice
    with the following commands:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'Wait until the following is printed in the Terminal:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/41540310-c226-4100-ae87-35de5d722d65.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Make a test call to the `product` service:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'It should respond with something similar to the following:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/99d66466-5aec-4506-b7ea-c12540ad6ce5.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Finally, stop the `product` service:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: We have now built, run, and tested our first single microservice. In the next
    section, we will implement the composite microservice that will use the three
    core microservices that we've created so far.
  prefs: []
  type: TYPE_NORMAL
- en: Adding a composite microservice
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now, it's time to tie things together by adding the composite service that will
    call the three core services!
  prefs: []
  type: TYPE_NORMAL
- en: 'The implementation of the composite services is divided into two parts: an integration
    component that handles the outgoing HTTP requests to the core services and the
    composite service implementation itself. The main reason for this division of
    responsibility is that it simplifies automated unit and integration testing; that
    is, we can test the service implementation in isolation by replacing the integration
    component with a mock.'
  prefs: []
  type: TYPE_NORMAL
- en: As we will see later on in this book, this division of responsibility will also
    make it easier to introduce a Circuit Breaker!
  prefs: []
  type: TYPE_NORMAL
- en: Before we look into the source code of the two components, we need to take a
    look at the API classes that the composite microservices will use and also learn
    about how runtime properties are used to hold address information for the core
    microservices.
  prefs: []
  type: TYPE_NORMAL
- en: The full implementation of both the integration component and the implementation
    of the composite service can be found in the `$BOOK_HOME/Chapter03/2-basic-rest-services/microservices/product-composite-service/src/main/java/se/magnus/microservices/composite/product/services` folder.
  prefs: []
  type: TYPE_NORMAL
- en: API classes
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this section, we will take a look at the classes that describes the API
    of the composite component. They can be found in `$BOOK_HOME/Chapter03/2-basic-rest-services/api`.
    The following are the API classes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'The Java interface class, `ProductCompositeService.java`, follows the same
    pattern that''s used by the core services and looks as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'The model class, `ProductAggregate.java`, is a bit more complex than the core
    models since it contains fields for lists of recommendations and reviews:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: Properties
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To avoid hardcoding the address information for the core services into the
    source code of the composite microservice, the latter uses a property file where
    information on how to find the core services is stored. The property file can
    be found in `$BOOK_HOME/Chapter03/2-basic-rest-services/microservices/product-composite-service/src/main/resources/application.yml`
    and looks as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: This configuration will, as already noted, be replaced by a service discovery
    mechanism later on in this book.
  prefs: []
  type: TYPE_NORMAL
- en: Integration component
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s look at the integration component, `ProductCompositeIntegration.java`.
    It is declared as a Spring Bean using the `@Component` annotation and implements
    the three core services'' API interfaces:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'The integration component uses a helper class in Spring Framework, `RestTemplate.java`,
    to perform the actual HTTP requests to the core microservices. Before we can inject
    it into the integration component, we need to configure it. We do that in the
    `main` application class, `ProductCompositeServiceApplication.java`, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: '`RestTemplate` is highly configurable, but we leave it with its default values
    for now.'
  prefs: []
  type: TYPE_NORMAL
- en: 'We can now inject `RestTemplate`, along with a JSON mapper that''s used for
    error handling and the configuration values that we set up in the property file
    in the constructor of the integration component. Let''s see how this is done:'
  prefs: []
  type: TYPE_NORMAL
- en: 'The configuration values we use to set up the URLs for the three core services
    are injected into the constructor as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: 'The body of the constructor builds the URLs based on the injected values, as
    follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, the integration component implements the API methods for the three
    core services by using `RestTemplate` to make the actual outgoing calls:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s explain the preceding source code in more detail:'
  prefs: []
  type: TYPE_NORMAL
- en: For the `getProduct()` implementation, the `getForObject()` method can be used
    in `RestTemplate`. The expected response is a `Product` object, and it can be
    expressed in the call to `getForObject()` by specifying the `Product.class` class that
    `RestTemplate` will map the JSON response to.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: For the calls to `getRecommendations()` and `getReviews()`, a more advanced
    method, `exchange()`, has to be used. The reason for this is the automatic mapping
    from a JSON response to a model class that `RestTemplate` performs.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `getRecommendations()` and `getReviews()` methods expect a generic list
    in the responses, that is, `List<Recommendation>` and `List<Review>`. Since generics
    don't hold any type of information at runtime, we can't specify that the methods
    expect a generic list in their responses. Instead, we can use a helper class from
    the Spring Framework, `ParameterizedTypeReference`, that is designed to resolve
    this problem by holding the type information at runtime. This means that `RestTemplate`
    can figure out what class to map the JSON responses to. To utilize this helper
    class, we have to use the more involved `exchange()` method instead of the simpler `getForObject()` method
    on `RestTemplate`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Composite API implementation
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Finally, we will look at the last piece of the implementation of the composite
    microservice: the `ProductCompositeServiceImpl.java`. implementation class. Let''s
    go through it step-by-step:'
  prefs: []
  type: TYPE_NORMAL
- en: 'In the same way that we did for the core services, the composite service implements
    its API interface, `ProductCompositeService`, and is annotated with `@RestController` to
    mark it as a REST service:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: 'The implementation class requires the `ServiceUtil` bean and its own integration
    component, so they are injected in its constructor:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, the API method is implemented as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: The integration component is used to call the three core services, and a helper
    method, `createProductAggregate()`, is used to create a response object of the `ProductAggregate` type
    based on the responses from the calls to the integration component.
  prefs: []
  type: TYPE_NORMAL
- en: The implementation of the helper method, `createProductAggregate()`, is quite
    lengthy and not very important and so has been omitted from this chapter; however,
    it can be found in this book's source code.
  prefs: []
  type: TYPE_NORMAL
- en: The full implementation of both the integration component and the composite
    service can be found in the `$BOOK_HOME/Chapter03/2-basic-rest-services/microservices/product-composite-service/src/main/java/se/magnus/microservices/composite/product/services` folder.
  prefs: []
  type: TYPE_NORMAL
- en: That completes the implementation of the composite microservice from a functional
    point of view. In the next section, we will see how we can add source code so
    that we can handle errors.
  prefs: []
  type: TYPE_NORMAL
- en: Adding error handling
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Handling errors in a structured and well thought-out way is essential in a microservice
    landscape where a large number of microservices communicate with each other using
    synchronous APIs, for example, using HTTP and JSON. It is also important to separate
    protocol-specific handling of errors, such as HTTP status codes, from the business
    logic.
  prefs: []
  type: TYPE_NORMAL
- en: It could be argued that a separate layer for the business logic should be added
    when implementing of the microservices. This should ensure that business logic
    is separated from the protocol-specific code, making it easier both to test and
    reuse. To avoid unnecessary complexity in the examples provided in this book,
    we have left out a separate layer for business logic, that is, the microservices
    implement their business logic directly in the `@RestController` components.
  prefs: []
  type: TYPE_NORMAL
- en: I have created a set of Java exceptions in the `util` project that are used
    by both the API implementations and the API clients, initially `InvalidInputException`
    and `NotFoundException`. See `$BOOK_HOME/Chapter03/2-basic-rest-services/util/src/main/java/se/magnus/util/exceptions`
    for details.
  prefs: []
  type: TYPE_NORMAL
- en: The global REST controller exception handler
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: To separate protocol-specific error handling from the business logic in the
    REST controllers, that is, the API implementations, I have created a utility class,
    `GlobalControllerExceptionHandler.java`, in the `util` project that's annotated
    as `@RestControllerAdvice`.
  prefs: []
  type: TYPE_NORMAL
- en: For each Java exception that the API implementations throws, the utility class
    has an exception handler method that maps the Java exception to a proper HTTP
    response, that is, with a proper HTTP status and HTTP response body.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, if an API implementation class throws `InvalidInputException`,
    the utility class will map it to an HTTP response with the status code set to
    `422` (`UNPROCESSABLE_ENTITY`). The following code shows this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: In the same way, `NotFoundException` is mapped to a `404` (`NOT_FOUND`) HTTP
    status code.
  prefs: []
  type: TYPE_NORMAL
- en: Whenever a REST controller throws any of these exceptions, Spring will use the
    utility class to create an HTTP response.
  prefs: []
  type: TYPE_NORMAL
- en: Note that Spring itself returns the HTTP status code `400` ( `BAD_REQUEST`)
    when it detects an invalid request, for example, if the request contains a non-numeric
    product ID (`productId` is specified as an integer in the API declaration).
  prefs: []
  type: TYPE_NORMAL
- en: For the full source code of the utility class, see `$BOOK_HOME/Chapter03/2-basic-rest-services/util/src/main/java/se/magnus/util/http/GlobalControllerExceptionHandler.java`.
  prefs: []
  type: TYPE_NORMAL
- en: Error-handling in API implementations
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'API implementations use the exceptions in the `util` project to signal errors.
    They will be reported back to the REST client as HTTPS status codes indicating
    what went wrong. For example, the `Product` microservice implementation class, `ProductServiceImpl.java`,
    uses the `InvalidInputException` exception to return an error that indicates invalid
    input, as well as the `NotFoundException` exception to tell us that the product
    that was asked for does not exist. The code looks as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: Since we currently aren't using a database, we have to simulate when to throw `NotFoundException`.
  prefs: []
  type: TYPE_NORMAL
- en: Error-handling in the API client
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The API client, that is, the integration component of the `Composite` microservice,
    does the reverse; that is, it maps the `422` (`UNPROCESSABLE_ENTITY`) HTTP status
    code to `InvalidInputException` and the `404` (`NOT_FOUND`) HTTP status code to `NotFoundException`.
    See the `getProduct()` method in `ProductCompositeIntegration.java` for the implementation
    of this error handling logic. The source code looks as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: The error handling for `getRecommendations()` and `getReviews()` in the integration
    component is a bit more relaxed – classed as best-effort, meaning that, if it
    succeeds in getting product information but fails to get either recommendations
    or reviews, it is still considered to be okay. However, a warning is written to
    the log.
  prefs: []
  type: TYPE_NORMAL
- en: For more details, see `$BOOK_HOME/Chapter03/2-basic-rest-services/microservices/product-composite-service/src/main/java/se/magnus/microservices/composite/product/services/ProductCompositeIntegration.java`.
  prefs: []
  type: TYPE_NORMAL
- en: That completes the implementation of both the code and composite microservices.
    In the next section, we will test the microservices and the API that they expose.
  prefs: []
  type: TYPE_NORMAL
- en: Testing APIs manually
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'That concludes the implementation of our microservices. Let''s try them out
    by performing the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Build and start them up as background processes.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Use `curl` to call the composite API.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Stop them.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'First, build and start-up each microservice as a background process, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: 'Once the build completes, we can launch our microservices as background processes
    to the Terminal process with the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: 'A lot of log messages will be written to the Terminal, but after a few seconds,
    things will calm down and we will find the following messages written to the log:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/7437d6fb-99f1-4fa9-957b-be6257567694.png)'
  prefs: []
  type: TYPE_IMG
- en: 'This means that they all are ready to receive requests. Try this out with the
    following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: 'After some log output, we will get a JSON response that looks something like
    the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/4cf8525d-ea4f-4c59-99f9-a076421e41dd.png)'
  prefs: []
  type: TYPE_IMG
- en: 'To get the JSON response pretty-printed, you can use the `jq` tool:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: 'This results in the following output (some details have been replaced by `...` for
    increased readability):'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/771fc141-de97-432e-af16-a3f1d0f03b70.png)'
  prefs: []
  type: TYPE_IMG
- en: 'If you want to, you can also try out the following commands to verify that
    the error handling works as expected:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, you can shut down the microservices with the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: If you are using either Spring Tool Suite or IntelliJ IDEA Ultimate Edition
    as your IDE, you can use their Spring Boot Dashboard to start and stop your microservices
    with one click.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following screenshot shows the use of Spring Tool Suite:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/5017f9b2-a124-4c5a-95fa-cc52247a15e6.png)'
  prefs: []
  type: TYPE_IMG
- en: 'The following screenshot shows the use of IntelliJ IDEA Ultimate Edition:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/871261b3-dbde-4c1d-afde-61ca65c7bdca.png)'
  prefs: []
  type: TYPE_IMG
- en: In this section, we have learned how to manually start, test, and stop the system
    landscape of cooperating microservices. These types of test are time-consuming,
    so they clearly need to be automated. In the next two sections, we will take our
    first steps toward learning how to automate testing, testing both a single microservice
    in isolation and a whole system landscape of cooperating microservices. Throughout
    this book, we will improve how we test our microservices.
  prefs: []
  type: TYPE_NORMAL
- en: Preventing slow lookup of the localhost hostname
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: With effect from macOS Sierra, looking up the hostname that's used by the localhost
    in a Java program on a macOS can take a very long time, that is, 5 seconds, making
    tests very slow. The problem seems to be fixed when using macOS Mojave, but if
    you are using an older version of macOS, this can easily be fixed.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, you need to verify whether the problem affects you by downloading a
    small tool from GitHub and running it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s say the program responds with something like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/c41f046a-ac2c-4f77-a856-2131fef48987.png)'
  prefs: []
  type: TYPE_IMG
- en: If you have a response time of 5 seconds, then you have a problem!
  prefs: []
  type: TYPE_NORMAL
- en: 'The solution is to edit the `/etc/hosts` file and add your local hostname,
    which is `Magnuss-Mac.local` in the preceding example, after `localhost`; for
    example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: 'Rerun the test. It should respond with a response time of a few milliseconds, for
    example:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/d1ba5f11-22f1-4ce4-a3fd-03e8486b5e13.png)'
  prefs: []
  type: TYPE_IMG
- en: Now lets see how to add automated tests in isolation for microservices.
  prefs: []
  type: TYPE_NORMAL
- en: Adding automated microservice tests in isolation
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Before we wrap up the implementation, we also need to write some automated tests.
  prefs: []
  type: TYPE_NORMAL
- en: We don't have much business logic to test at this time, so we don't need to
    write any unit tests. Instead, we will focus on testing the APIs that our microservices
    expose; that is, we will start them up in integration tests with their embedded
    web server and then use a test client to perform HTTP requests and validate the
    responses. With Spring WebFlux came a new test client, `WebTestClient`, that provides
    a fluent API for making a request and then applying assertions on its result.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following is an example where we test the composite product API by doing
    the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Sending in `productId` for an existing product and asserting that we get back
    200 as an HTTP response code and a JSON response that contains the requested `productId`
    along with one recommendation and one review
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Sending in a missing `productId` and asserting that we get back 404 as an HTTP
    response code and a JSON response that contains relevant error information
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The implementation for these two tests is shown in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s explain the preceding source code in more detail:'
  prefs: []
  type: TYPE_NORMAL
- en: The test uses the fluent `WebTestClient` API to set up the URL to call `"/product-composite/"
    + PRODUCT_ID_OK` and specify the accepted response format, JSON.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: After executing the request using the `exchange()` method, the test verifies
    that the response status is OK (200) and that the response format actually is
    JSON (as requested).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Finally, the test inspects the response body and verifies that it contains the
    expected information in terms of `productId` and the number of recommendations
    and reviews.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The second test looks as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s explain the preceding source code in more detail:'
  prefs: []
  type: TYPE_NORMAL
- en: This negative test is very similar to the preceding test in terms of its structure;
    the main difference is that it verifies that it got an error status code back,
    Not Found (404), and that the response body contains the expected error message.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'To test the composite product API in isolation, we need to mock its dependencies,
    that is, the requests to the other three microservices that were performed by
    the integration component, `ProductCompositeIntegration`. We use Mockito to do
    this, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s explain the preceding source code in more detail:'
  prefs: []
  type: TYPE_NORMAL
- en: First, we declare three constants that are used in the test class: `PRODUCT_ID_OK`,
    `PRODUCT_ID_NOT_FOUND`, and `PRODUCT_ID_INVALID`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If the `getProduct()`, `getRecommendations()`, and `getReviews()` methods are
    called on the integration component, and `productId` is set to `PRODUCT_ID_OK`,
    the mock will return a normal response.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If the `getProduct()` method is called with `productId` set to `PRODUCT_ID_NOT_FOUND`,
    the mock will throw `NotFoundException`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If the `getProduct()` method is called with `productId` set to `PRODUCT_ID_INVALID`,
    the mock will throw `InvalidInputException`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The full source code for the automated integration tests on the composite product
    API can be found in `$BOOK_HOME/Chapter03/2-basic-rest-services/microservices/product-composite-service/src/test/java/se/magnus/microservices/composite/product/ProductCompositeServiceApplicationTests.java`.
  prefs: []
  type: TYPE_NORMAL
- en: The automated integration tests on the API exposed by the three core microservices
    are similar, but simpler since they don't need to mock anything! The source code
    for the tests can be found in each microservice's `test` folder.
  prefs: []
  type: TYPE_NORMAL
- en: 'The tests are run automatically by Gradle when performing a build:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: 'You can, however, specify that you only want to run the tests (and not the
    rest of the build):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: This was an introduction to how to write automated tests for microservices in
    isolation. In the next section, we will learn how to write tests that automatically
    test a microservice landscape. In this chapter, these tests will only be semi-automated.
    In upcoming chapters, the tests will be fully automated, a significant improvement.
  prefs: []
  type: TYPE_NORMAL
- en: Adding semi-automated tests of a microservice landscape
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Being able to automatically test each microservice in isolation is, of course,
    very useful, but insufficient!
  prefs: []
  type: TYPE_NORMAL
- en: We need a way to automatically test all of our microservices to ensure that
    they deliver what we expect!
  prefs: []
  type: TYPE_NORMAL
- en: For this reason, I have written a simple bash script that can perform calls
    to a RESTful API using `curl` and verify its return code and parts of its JSON
    response using `jq`. The script contains two helper functions, `assertCurl()`
    and `assertEqual()`, to make the test code compact and easier to read.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, making a normal request and expecting 200 as the status code,
    as well as asserting that we get back a JSON response that returns the requested
    `productId` along with three recommendations and three reviews, looks like the
    following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: 'Verifying that we get `404 (Not Found)` back as an HTTP response code (when
    we try to look up a product that doesn''t exist) looks as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs: []
  type: TYPE_PRE
- en: The test script implements the manual tests that were described in the *Testing
    APIs manually* section and can be found in `$BOOK_HOME/Chapter03/2-basic-rest-services/test-em-all.bash`.
  prefs: []
  type: TYPE_NORMAL
- en: Trying out the test script
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To try out the test script, perform the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'First, start the microservices, as we did previously:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs: []
  type: TYPE_PRE
- en: 'Once they''ve all started up, run the test script:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE64]'
  prefs: []
  type: TYPE_PRE
- en: 'Expect the output to look similar to the following:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/34c2f31c-8138-4f03-9414-cfb4c0779f29.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Wrap this up by shutting down the microservices with the following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE65]'
  prefs: []
  type: TYPE_PRE
- en: In this section, we have taken the first steps toward automating testing a system
    landscape of cooperating microservices, all of which will be improved in upcoming
    chapters.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We have now built our first few microservices using Spring Boot. After being
    introduced to the microservice landscape, which we will use throughout this book,
    we learned how to use Spring Initializr to create skeleton projects for each microservice.
  prefs: []
  type: TYPE_NORMAL
- en: Next, we learned how to add APIs using Spring WebFlux for the three core services
    and implemented a composite service that uses the three core services APIs to
    create an aggregated view of the information in them. The composite service uses
    the `RestTemplate` class in Spring Framework to perform HTTP requests to APIs
    that are exposed by the core services. After adding logic for error handling in
    the services, we ran some manual tests on the microservice landscape.
  prefs: []
  type: TYPE_NORMAL
- en: We wrapped this chapter up by learning how to add tests for microservices in
    isolation and when they work together as a system landscape. To provide controlled
    isolation for the composite service, we mocked its dependencies to the core services
    using Mockito. Testing the whole system landscape is performed by a bash script
    that uses `curl` to perform calls to the API of the composite service.
  prefs: []
  type: TYPE_NORMAL
- en: With these skills in place, we are ready to take the next step, entering the
    world of Docker and containers, in the next chapter! Among other things, we will
    learn how to use Docker to fully automate testing of a system landscape of cooperating
    microservices.
  prefs: []
  type: TYPE_NORMAL
- en: Questions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: What is the command that lists available dependencies when you create a new
    Spring Boot project using the `spring init` Spring Initializr CLI tool?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How can you set up Gradle to build multiple related projects with one command?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What are the `@PathVariable` and `@RequestParam` annotations used for?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How can you separate protocol-specific error handling from the business logic
    in an API implementation class?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What is Mockito used for?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
