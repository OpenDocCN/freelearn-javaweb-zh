- en: Spring for Microservices
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: I don't know many Java developers who have never touched Spring Framework. Actually,
    it consists of so many projects and can be used with many other frameworks that
    sooner or later you will be forced to try it. Although experiences with Spring
    Boot are rather less common, it has quickly gained a lot of popularity. In comparison
    with Spring Framework, Spring Boot is a relatively new solution. Its actual version
    is 2, instead of 5 for Spring Framework. What was the purpose of its creation?
    What is the difference between a running application with Spring Boot instead
    of the standard Spring Framework way?
  prefs: []
  type: TYPE_NORMAL
- en: 'Topics we will cover in this chapter include:'
  prefs: []
  type: TYPE_NORMAL
- en: Using starters in order to enable additional features for the project
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using Spring Web library for implementing services that expose REST API methods
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Customizing service configuration using properties and YAML files
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Documenting and providing the specification for exposed REST endpoints
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Configuring health checks and monitoring features
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using Spring Boot profiles to adapt the application to run in different modes
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using ORM features for interacting with embedded and remote NoSQL databases
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Introducing Spring Boot
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Spring Boot is dedicated to running standalone Spring applications, the same
    as simple Java applications, with the `java -jar` command. The basic thing that
    makes Spring Boot different than standard Spring configuration is simplicity.
    This simplicity is closely related to the first important term we need to know
    about, which is a starter. A **starter** is an artifact that can be included in
    the project dependencies. It does nothing more than provide a set of dependencies
    to other artifacts that have to be included in your application in order to achieve
    the desired functionality. A package delivered in that way is ready for use, which
    means that we don't have to configure anything to make it work. And that brings
    us to the second important term related to Spring Boot, auto-configuration. All
    artifacts included by the starters have default settings set, which can be easily
    overridden using properties or other types of starters. For example, if you include
    `spring-boot-starter-web` in your application dependencies it embeds a default
    web container and starts it on the default port during application startup. Looking
    forward, the default web container in Spring Boot is Tomcat, which starts on port `8080`.
    We can easily change this port by declaring the specified field in the application
    properties file and even change the web container by including `spring-boot-starter-jetty`
    or `spring-boot-starter-undertow` in our project dependencies.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let me say a few words more about starters. Their official naming pattern is
    `spring-boot-starter-*`, where `*` is the particular type of starter. There are
    plenty of starters available within Spring Boot, but I would like to give you
    a short briefing on the most popular of them, which have also been used in the
    examples provided in the following chapters of this book:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Name** | **Description** |'
  prefs: []
  type: TYPE_TB
- en: '| `spring-boot-starter` | Core starter, including auto-configuration support,
    logging, and YAML. |'
  prefs: []
  type: TYPE_TB
- en: '| `spring-boot-starter-web` | Allows us to build web applications, including
    RESTful and Spring MVC. Uses Tomcat as the default embedded container. |'
  prefs: []
  type: TYPE_TB
- en: '| `spring-boot-starter-jetty` | Includes Jetty in the project and sets it as
    the default embedded servlet container. |'
  prefs: []
  type: TYPE_TB
- en: '| `spring-boot-starter-undertow` | Includes Undertow in the project and sets
    it as the default embedded servlet container. |'
  prefs: []
  type: TYPE_TB
- en: '| `spring-boot-starter-tomcat` | Includes Tomcat as the embedded servlet container.
    The default servlet container starter used by `spring-boot-starter-web`. |'
  prefs: []
  type: TYPE_TB
- en: '| `spring-boot-starter-actuator` | Includes Spring Boot Actuator in the project,
    which provides features for monitoring and managing applications. |'
  prefs: []
  type: TYPE_TB
- en: '| `spring-boot-starter-jdbc` | Includes Spring JBDC with the Tomcat connection
    pool. The driver for the specific database should be provided by yourself. |'
  prefs: []
  type: TYPE_TB
- en: '| `spring-boot-starter-data-jpa` | Includes all artifacts needed for interaction
    with relational databases using JPA/Hibernate. |'
  prefs: []
  type: TYPE_TB
- en: '| `spring-boot-starter-data-mongodb` | Includes all artifacts needed for interaction
    with MongoDB and initializing a client connection to Mongo on localhost.   |'
  prefs: []
  type: TYPE_TB
- en: '| `spring-boot-starter-security` | Includes Spring Security in the project
    and enables basic security for applications by default. |'
  prefs: []
  type: TYPE_TB
- en: '| `spring-boot-starter-test` | Allows the creation of unit tests using such
    libraries as JUnit, Hamcrest, and Mockito. |'
  prefs: []
  type: TYPE_TB
- en: '| `spring-boot-starter-amqp` | Includes Spring AMQP to the project and starts
    RabbitMQ as the default AMQP broker. |'
  prefs: []
  type: TYPE_TB
- en: If you are interested in the full list of available starters, refer to the Spring
    Boot specification. Now, let's get back to the main differences between Spring
    Boot and standard configuration with Spring Framework. Like I mentioned before
    we can include `spring-boot-starter-web`, which embeds a web container into our
    application. With standard Spring configuration, we do not embed a web container
    into the application, but deploy it as a WAR file on the web container. This is
    a key difference and one of the most important reasons that Spring Boot is used
    for creating applications deployed inside microservice architecture. One of the
    main features of microservices is independence from other microservices. In this
    case, it is clear that they should not share common resources, such as databases
    or web containers. Deploying many WAR files on one web container is an anti-pattern
    for microservices. Spring Boot is, therefore, the obvious choice.
  prefs: []
  type: TYPE_NORMAL
- en: 'Personally, I have used Spring Boot while developing many applications, not
    only when working in a microservice environment. If you try it instead of standard
    Spring Framework configuration, you will not want to go back. In support of that
    conclusion you can find an interesting diagram that illustrates the popularity
    of Java frameworks repositories on GitHub: [http://redmonk.com/fryan/files/2017/06/java-tier1-relbar-20170622-logo.png](http://redmonk.com/fryan/files/2017/06/java-tier1-relbar-20170622-logo.png).
    Let''s take a closer look at how to develop applications with Spring Boot.'
  prefs: []
  type: TYPE_NORMAL
- en: Developing applications with Spring Boot
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The recommended way to enable Spring Boot in your project is by using a dependency
    management system. Here, you can see a short snippet of how to include appropriate
    artifacts in your Maven and Gradle projects. Here is a sample fragment from the
    Maven `pom.xml`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'With Gradle, we do not need to define parent dependency. Here''s a fragment
    from `build.gradle`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'When using Maven, it is not necessary to inherit from the `spring-boot-starter-parent`
    POM. Alternatively, we can use the dependency management mechanism:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, all we need is to create the main application class and annotate it with `@SpringBootApplication`,
    which is an equivalent to three other annotations used together—`@Configuration`,
    `@EnableAutoConfiguration`, and `@ComponentScan`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'Once we have the main class declared and `spring-boot-starter-web` included,
    we only need to run our first application. If you use a development IDE, such
    as Eclipse or IntelliJ, you should just run your main class. Otherwise, the application
    has to be built and run like a standard Java application with the `java -jar`
    command. First, we should provide the configuration that is responsible for packaging
    all dependencies into an executable JAR (sometimes called **fat JARs**) during
    application build. This action would be performed by `spring-boot-maven-plugin`
    if it is defined in the Maven `pom.xml`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'The sample application does nothing more than start a Spring context on the
    Tomcat container, which is available on port `8080`. The fat JAR is about 14 MB
    in size. You can easily, using an IDE, check out which libraries are included
    in the project. These are all basic Spring libraries, such as `spring-core`, `spring-aop`, `spring-context`;
    Spring Boot; Tomcat embedded; libraries for logging including Logback, Log4j,
    and Slf4j; and Jackson libraries used for JSON serialization or deserialization.
    A good idea is to set the default Java version for the project. You can easily
    set it up in `pom.xml` by declaring the `java.version` property:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'We can change the default web container just by adding a new dependency, for
    example, to the Jetty server:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: Customizing configuration files
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'It''s one thing to have the ability to create applications quickly and without
    a huge volume of work, but no less important is the ability to easily customize
    and override default settings. Spring Boot comes in handy and provides mechanisms
    that enable configuration management. The simplest way to do that is using configuration
    files, which are appended to the application fat JAR. Spring Boot automatically
    detects configuration files whose name start with the `application` prefix. Supported
    file types are `.properties` and `.yml`. Therefore, we can create configuration
    files, such as `application.properties` or `application.yml`, and even including
    profile-specific files such as, `application-prod.properties` or `application-dev.yml`.
    Moreover, we can use OS environment variables and command-line arguments to externalize
    configuration. When using properties or YAML files, they should be placed in one
    of the following locations:'
  prefs: []
  type: TYPE_NORMAL
- en: A `/config` subdirectory of the current application directory
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The current application directory
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A classpath `/config` package (for example, inside your JAR)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The classpath root
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'If you would like to give a specific name to your configuration file, other
    than application or `application-{profile}`, you need to provide a `spring.config.name`
    environment property during startup. You can also use the `spring.config.location`
    property, which contains a comma-separated list of directory locations or file
    paths:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: Inside configuration files, we can define two types of properties. First, there
    is a group of common, predefined Spring Boot properties consumed by the underlying
    classes mostly from the `spring-boot-autoconfigure` library. We can also define
    our own custom configuration properties, which are then injected into the application
    using the `@Value` or `@ConfigurationProperties` annotations.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s begin with the predefined properties. The full list of supported by
    the Spring Boot project is available in their documentation in *Appendix A**,* in
    the *Common application properties* section. Most of them are specific to certain
    Spring modules, such as databases, web servers, security, and some other solutions,
    but there is also a group of core properties. Personally, I prefer using YAML
    instead of properties files because it is easily readable by humans, but the decision
    is yours. Most commonly, I override such properties as application name, which
    is used for service discovery and distributed configuration management; web server
    port; logging; or database connection settings. Usually, `application.yml` file
    is placed in the `src/main/resources` directory, which is then located in the
    JAR root directory after the Maven build. Here''s a sample configuration file,
    which overrides default server port, application name, and logging properties:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: The one really cool thing here is that you don't have to define any other external
    configuration files, for example, `log4j.xml` or `logback.xml`, for logging configuration.
    In the previous fragment, you can see that I changed the default log level for
    `org.springframework.web` to `DEBUG` and log patterns, and created a log file, `app.log`,
    placed in the current application directory. Now, the default application name
    is `first-service` and the default HTTP port is `2222`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Our custom configuration settings should also be placed in the same properties
    or YAML files. Here''s a sample `application.yml` with custom properties:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'A simple property can be injected using the `@Value` annotation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'There is also the ability to inject more complex configuration properties using
    the `@ConfigurationProperties` annotation. The list of values defined in the `my.servers`
    property inside the YAML file was injected to the target bean of type `java.util.List`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'So far, we have managed to create a simple application that does nothing more
    than start Spring on a web container such as Tomcat or Jetty. In this part of
    the chapter, I wanted to show you how simple it is to start application development
    using Spring Boot. Apart from that, I have described how to customize configuration
    using YAML or properties files. For those people who prefer clicking to typing,
    I recommend the Spring Initializr website ([https://start.spring.io/](https://start.spring.io/)),
    where you can generate the project stub based on options you choose. In the simple
    site view, you can choose build tools (Maven/Gradle), language (Java/Kotlin/Groovy),
    and Spring Boot version. Then, you should provide all necessary dependencies using
    the search engine following the Search for dependencies label. I included `spring-boot-starter-web`,
    which is just labeled as `Web` on Spring Initializr as you see in the following
    screenshot. After clicking on Generate project, the ZIP file with the generated
    source code gets downloaded onto your computer. You might also be interested in
    knowing that by clicking Switch to the full version, you are able to see almost
    all available Spring Boot and Spring Cloud libraries, which can be included in
    the generated project:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/557eaa38-1948-4896-88cf-48587b8e60d8.png)'
  prefs: []
  type: TYPE_IMG
- en: I think that, since we have been going over the basics about building projects
    using Spring Boot, this is the right time to add some new features to our sample
    application.
  prefs: []
  type: TYPE_NORMAL
- en: Creating RESTful Web Services
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'As a first step, let''s create RESTful Web Services exposing some data to the
    calling clients. As mentioned before, the Jackson library, which is responsible
    for the serialization and deserialization of JSON messages, is automatically included
    in our classpath together with `spring-boot-starter-web`. Thanks to that, we don''t
    have to do anything more than declare a model class, which is then returned or
    taken as a parameter by REST methods. Here''s our sample model class, `Person`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'Spring Web provides some annotations for creating RESTful Web Services. The
    first of them is the `@RestController` annotation, which should be set on your
    controller bean class that is responsible for handling incoming HTTP requests.
    There is also the `@RequestMapping` annotation, which is usually used for mapping
    controller methods to HTTP. As you see in the following code fragment, it can
    be used on the whole controller class to set the request path for all methods
    inside it. We can use more specific annotations for the concrete HTTP methods
    such as `@GetMapping` or `@PostMapping`.  `@GetMapping` is the same as `@RequestMapping`
    with the parameter `method=RequestMethod.GET`. Two other commonly used annotations
    are `@RequestParam` and `@RequestBody`. The first binds path and query params
    to objects; the second maps input JSON to objects using the Jackson library:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'To be compatible with REST API standards, we should handle `PUT` and `DELETE`
    methods. After their implementation, our service performs all CRUD operations:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Method** | **Path** | **Description** |'
  prefs: []
  type: TYPE_TB
- en: '| `GET` | `/person` | Returns all existing persons |'
  prefs: []
  type: TYPE_TB
- en: '| `GET` | `/person/{id}` | Returns person with the given *id* |'
  prefs: []
  type: TYPE_TB
- en: '| `POST` | `/person` | Adds new person |'
  prefs: []
  type: TYPE_TB
- en: '| `PUT` | `/person` | Updates existing person |'
  prefs: []
  type: TYPE_TB
- en: '| `DELETE` | `/person/{id}` | Removes person from list using given *id* |'
  prefs: []
  type: TYPE_TB
- en: 'Here''s a fragment of a sample `@RestController` implementation with the `DELETE`
    and `PUT` methods:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: The controller code is really simple. It stores all data in the local `java.util.List`,
    which is obviously not a good programming practice. However, treat that as a simplification
    adopted for the purposes of the basic example. In the section *Integrating application
    with database*, in this chapter, I'll cover more advanced sample application that
    integrates with the NoSQL database.
  prefs: []
  type: TYPE_NORMAL
- en: Probably some of you have experience with SOAP Web Services. If we had created
    a similar service using SOAP instead of REST, we would provide a WSDL file for
    the client with all service definitions described. Unfortunately, REST doesn't
    support such standard notation as WSDL. In the initial stage of RESTful Web Services,
    it was said that **Web Application Description Language** (**WADL**) would perform
    that role. But the reality is that many providers, including Spring Web, do not
    generate WADL files after application startup. Why am I mentioning this? Well,
    we have already finished our first microservice, which exposes some REST operations
    over HTTP. You have probably run this microservice from your IDE or using the `java
    -jar` command after building the fat JAR. If you didn't change the configuration
    properties inside the `application.yml` file, or did not set the `-Dport` option
    while running the application, it is available under `http://localhost:2222`.
    In order to enable others to call our API, we have two choices. We can share a
    document describing its usage or mechanisms for automatic API client generation.
    Or both of them. That's where Swagger comes in.
  prefs: []
  type: TYPE_NORMAL
- en: API Documentation
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Swagger is the most popular tool for designing, building, and documenting RESTful
    APIs. It has been created by SmartBear, the designers of a very popular tool for
    SOAP Web Services, SoapUI. I think that might be sufficient recommendation for
    those who have long experience with SOAP. Anyway, with Swagger, we can design
    APIs using notation and then generate source code from it, or the other way around,
    where we start with the source code and then generate a Swagger file. With Spring
    Boot, we use the second option.
  prefs: []
  type: TYPE_NORMAL
- en: Using Swagger 2 together with Spring Boot
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The integration between Spring Boot and Swagger 2 is realized by the Springfox
    project. It examines application at runtime to infer API semantics based on Spring
    configurations, class structure, and Java annotations. To use Swagger in conjunction
    with Spring, we need to add the following two dependencies to the Maven `pom.xml` and
    annotate the main application class with `@EnableSwagger2`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'The API documentation will be automatically generated from the source code
    by the Swagger library during application startup. The process is controlled by
    the `Docket` bean, which is also declared in the main class. A nice idea might
    be to get the API version from the Maven `pom.xml` file. We can get it by including
    the `maven-model` library in the classpath and using the `MavenXpp3Reader` class.
    We also set some other properties, such as title, author, and description using
    the `apiInfo` method. By default, Swagger generates documentation for all REST
    services, including those created by Spring Boot. We would like to limit this
    documentation only to our `@RestController` located inside the `pl.piomin.services.boot.controller`
    package:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: Testing API with Swagger UI
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'An API documentation dashboard is available at `http://localhost:2222/swagger-ui.html`
    after application startup. This is a more user-friendly version of the Swagger
    JSON definition file, which is also automatically generated and available at `http://localhost:2222/v2/api-docs`.
    That file can be imported by any other REST tools, for example, SoapUI:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/596d9d1a-0019-43dd-b4c8-62222a248ba9.png)'
  prefs: []
  type: TYPE_IMG
- en: 'If you prefer SoapUI instead of Swagger UI, you can easily import the Swagger
    definition file by selecting Project | Import Swagger. Then, you need to provide
    a file address, as you can see in this screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/8cc43aa0-54b2-4fe5-b60f-3ac8f70ef909.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Personally, I prefer Swagger UI. You can expand every API method to see their
    details. Every operation can be tested by providing the required parameters or
    JSON input, and clicking the Try it out! button. Here''s a screenshot illustrating
    sending a `POST /person` test request:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/05eff4f3-d1c5-46ab-86b2-5d61833a77c6.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Here''s the response screen:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/edd90841-af55-443e-b42c-53ed834daf17.png)'
  prefs: []
  type: TYPE_IMG
- en: Spring Boot Actuator features
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Just creating the working application and sharing standardized API documentation
    is not everything, especially if we are talking about microservices, where there
    are plenty of independent entities structuring one managed environment. The next
    important thing that needs to be mentioned is monitoring and gathering metrics
    from applications. In that aspect, Spring Boot also comes through. Project Spring
    Boot Actuator provides a number of built-in endpoints, which allow us to monitor
    and interact with the application. To enable it in our project, we should include
    `spring-boot-starter-actuator` in the dependencies. Here''s a list of the most
    important Actuator endpoints:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Path** | **Description** |'
  prefs: []
  type: TYPE_TB
- en: '| `/beans` | Displays a full list of all the Spring beans initialized in the
    application. |'
  prefs: []
  type: TYPE_TB
- en: '| `/env` | Exposes properties from Spring’s Configurable Environment, which
    means, for example, OS environment variables and properties from configuration
    files. |'
  prefs: []
  type: TYPE_TB
- en: '| `/health` | Shows application health information. |'
  prefs: []
  type: TYPE_TB
- en: '| `/info` | Displays arbitrary application information. It can be taken, for
    example, from the `build-info.properties` or `git.properties` files. |'
  prefs: []
  type: TYPE_TB
- en: '| `/loggers` | Shows and modifies the configuration of loggers in the application.
    |'
  prefs: []
  type: TYPE_TB
- en: '| `/metrics` | Shows metrics information for the current application, such
    as memory usage, number of running threads, or REST method response time. |'
  prefs: []
  type: TYPE_TB
- en: '| `/trace` | Displays trace information (by default the last 100 HTTP requests).
    |'
  prefs: []
  type: TYPE_TB
- en: 'Endpoints can be easily customized using Spring configuration properties. For
    example, we can disable one of the enabled by default endpoints. By default, all
    endpoints except for `shutdown` are enabled. Most of these endpoints are secured.
    If you would like to call them from your web browser, you should provide security
    credentials in the request header or disable security for the whole project. To
    do the latter, you have to include the following statement in your `application.yml`
    file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: Application information
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The full list of endpoints available for the project is visible in application
    logs during startup. After disabling security, you can test all of them in your
    web browser. It''s interesting that the `/info` endpoint does not provide any
    information by default. If you would like to change this, you might use one of
    the three available auto-configured `InfoContributor` beans or write your own.
    The first of them, `EnvironmentInfoContributor`, exposes environment keys in the
    endpoint. The second, `GitInfoContributor`, detects the `git.properties` file
    in the classpath and then displays all necessary information about commits, such
    as branch name or commit ID. The last one, named `BuildInfoContributor`, gathers
    information from the `META-INF/build-info.properties` file and also displays it
    in the endpoint. These two properties files for Git and build information can
    be automatically generated during application build. To achieve this, you should
    include `git-commit-id-plugin` in your `pom.xml` and customize `spring-boot-maven-plugin`
    to generate `build-info.properties` in the way visible in this code fragment:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'With the `build-info.properties` file available, your `/info` would be a little
    different than before:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: Health information
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'As with the `/info` endpoint, there are also some auto-configured indicators
    for the `/health` endpoint. We can monitor the status of disk usage, mail service,
    JMS, data sources, and NoSQL databases, such as MongoDB or Cassandra. If you check
    out that endpoint from our sample application, you only get the information about
    disk usage. Let''s add MongoDB to the project to test one of the available health
    indicators, `MongoHealthIndicator`. MongoDB is not a random selection. It will
    be useful for us in the future for a more advanced example of the `Person` microservice.
    To enable MongoDB use, we need to add the following dependencies to `pom.xml`.
    The `de.flapdoodle.embed.mongo` artifact is responsible for starting the embedded
    database instance during application startup:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, the `/health` endpoint returns information about disk usage and MongoDB
    status:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: In this example, we can see the power of Spring Boot auto-configuration. We
    didn't have to do anything more than include two dependencies to the project to
    enable embedded MongoDB. Its status has been automatically added to the `/health`
    endpoint. It also has a ready-to-use client connection to Mongo, which can be
    further used by the repository bean.
  prefs: []
  type: TYPE_NORMAL
- en: Metrics
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'As we usually say, there is no such thing as a free lunch. Development is fast
    and easy, but after including some additional libraries in the project, the fat
    JAR file now has about 30 MB. Using one of the auto-configured actuator endpoints, `/metrics`,
    we can easily check out our microservice heap and non-heap memory usage. After
    sending some test requests, heap usage was about 140 MB and non-heap was 65 MB.
    Total memory usage for the application was about 320 MB. Of course, these values
    can be reduced a little even just by using the `-Xmx` parameter during startup
    with the `java -jar` command. However, we should not reduce this limit too much
    if we care about reliable working in production mode. Apart from memory usage,
    the `/metrics` endpoint displays information about the number of loaded classes,
    the number of active threads, the average duration of each API method, and a lot
    more. Here''s a fragment of the endpoint response for our sample microservice:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'There is the possibility to create our own custom metrics. Spring Boot Actuator
    provides two classes in case we would like to do that—`CounterService` and `GaugeService`.
    `CounterService`, as its name indicates, exposes methods for value incrementation,
    decrementation, and reset. By contrast, `GaugeService` is intended to just submit
    the current value. Default metrics for the API method calling statistics are a
    little imperfect because they are based only on the invoking path. There is no
    distinguishing between method types if they are available  on the same path. In
    our sample endpoint, this applies to `GET /person`, `POST /person`, and `PUT /person`.
    Anyway, I created the `PersonCounterService` bean, which counts the number of
    `add` and `delete` method calls:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'This bean needs to be injected into our REST controller bean, and the methods
    incrementing the counter value can be invoked when a person is added or removed:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, if you display application metrics again, you will see the following two
    new fields in the JSON response:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: All metrics generated by the Spring Boot application may be exported from the
    in-memory buffers to a place where they can be analyzed and displayed. We can
    store them, for example, in Redis, Open TSDB, Statsd, or even InfluxDB.
  prefs: []
  type: TYPE_NORMAL
- en: I think that's about all the details about built-in monitor endpoints I wanted
    to give you. I had designated a relatively large amount of space to such topics
    as documentation, metrics, and health checks, but in my opinion, these are the
    important aspects of microservice development and maintenance. Developers often
    do not care if these mechanisms are well implemented, but others often see our
    application just through the prism of those metrics, health checks and application's
    logs quality. Spring Boot provides such an implementation out of the box, and
    therefore developers do not have to spend much time enabling them.
  prefs: []
  type: TYPE_NORMAL
- en: Developer tools
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Spring Boot offers some other useful tools for developers. The really cool
    thing for me is that the application is automatically restarted whenever files
    on the project classpath change. If you use Eclipse as your IDE, the only thing
    you have to do to enable it is to add the `spring-boot-devtools` dependency to
    the Maven `pom.xml`. Then, try to change something in one of your classes and
    save it. The application automatically restarts, and it takes much less than stopping
    and starting in the standard way. When I start our sample application, it takes
    about 9 seconds, and automatic restart takes only 3 seconds:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'We can exclude some resources if there is no need to trigger a restart when
    they are changed. By default, any file available on the classpath that points
    to a folder will be monitored for changes, even static assets or view templates,
    which do not need restarting. For example, if they are placed in the static folder,
    you can exclude them by adding the following property to the `application.yml`
    configuration file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: Integrating application with database
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: You can find more interesting features described in the Spring Boot specification.
    I would like to spend more time describing other cool functionalities provided
    by that framework, but we should not go too far away from the main topic—Spring
    for microservices. As you may recall, through including embedded MongoDB in the
    project, I promised you a more advanced microservice example. Before starting
    to work on it, let's go back for a moment to the current version of our application.
    Its source code is available on my public GitHub account. Clone the following
    Git repository to your local machine: [https://github.com/piomin/sample-spring-boot-web.git](https://github.com/piomin/sample-spring-boot-web.git).
  prefs: []
  type: TYPE_NORMAL
- en: Building a sample application
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The basic example is available in the `master` branch. The more advanced sample,
    with embedded MongoDB, is committed to the `mongo` branch. In case you would like
    to try running more advanced sample, you need to switch to that branch using `git
    checkout mongo`. Now, we need to perform some changes in the model class to enable
    object mapping to MongoDB. The model class has to be annotated with `@Document`
    and the primary key field with `@Id`. I also changed the ID field type from `Long`
    to `String` because MongoDB generates primary keys in UUID format, for example, `59d63385206b6d14b854a45c`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'The next step is to create a repository interface that extends `MongoRepository`.
    MongoRepository provides basic methods for searching and storing data, such as `findAll`,
    `findOne`, `save`, and `delete`. Spring Data has a very smart mechanism for performing
    queries using repository objects. We don''t have to implement queries by ourselves,
    but only define an interface method with the right name. The method name should
    have the prefix `findBy` and then the searched field name. It may end with a standard
    search keyword suffix, such as `GreaterThan`, `LassThan`, `Between`, `Like`, and
    many more. A MongoDB query is automatically generated by Spring Data classes based
    on the full method name. The same keywords may be used in conjunction with `delete…By`
    or `remove…By` to create remove queries. In the `PersonRepository` interface,
    I decided to define two find methods. The first of them, `findByLastName`, selects
    all `Person` entities with the given `lastName` value. The second, `findByAgeGreaterThan`,
    is designed to retrieve all `Person` entities with an age greater than a given
    value:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'The repository should be injected into the REST controller class. Then, we
    can finally call all the required CRUD methods provided by `PersonRepository`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'We have also added two API methods for custom find operations from the `PersonRepository`
    bean:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: That's all that had to be done. Our microservice that exposes basic API methods
    implementing CRUD operations on an embedded Mongo database is ready to launch.
    You have probably noticed that it didn't require us to create a lot of source
    code. Implementation of any interaction with databases, whether relational or
    NoSQL, using Spring Data is fast and relatively easy. Anyway, there is still one
    more challenge facing us. An embedded database is a good choice, but only in development
    mode or for unit testing, not in production. If you have to run your microservice
    in production mode, you would probably launch one standalone instance or some
    instances of Mongo deployed as a sharded cluster, and connect the application
    to them. For our example purposes, I'll run a single instance of MongoDB using
    Docker.
  prefs: []
  type: TYPE_NORMAL
- en: If you are not familiar with Docker, you can always just install Mongo on your
    local or remote machine. For more information about Docker, you can also refer
    to [Chapter 14](0756243e-39c9-4696-8d79-4175e7cf4c48.xhtml), *Docker Support*
    where I will give you a short briefing about it. There, you will find all you
    need to begin, for example, how to install it on Windows and use basic commands.
    I will also use Docker in the examples implemented for the purposes of the next
    chapters and topics, so I think it would be useful if you have basic knowledge
    about it.
  prefs: []
  type: TYPE_NORMAL
- en: Running the application
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s start MongoDB using the Docker `run` command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'Something that may be useful for us is the Mongo database client. Using this,
    it is possible to create a new database and add some users with credentials. If
    you have Docker installed on Windows, the default virtual machine address is `192.168.99.100`.
    The Mongo container has port `27017` exposed as a result of setting the `-p` parameter
    inside the `run` command. Well, in fact, we do not have to create the database
    because, when we provide the name while defining the client connection, it will
    automatically be created if it doesn''t exist:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/6028efdc-ae01-4769-87ff-30e34816bae8.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Next, we should create a user for the application with sufficient authority:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/37885b34-9466-4902-89cd-0d23223f6eef.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Finally, we should set the Mongo database connection settings and credentials
    in the `application.yml` configuration file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'Spring Boot has good support for multi-profile configuration. A YAML file can
    be separated into a sequence of documents using `*---*` lines, and each section
    of the document is parsed independently to a flattened map. The preceding example
    does exactly the same as a separated configuration file with `application-production.yml`.
    If you run the application without any additional options, it uses the default
    settings, which have no profile name set. If you would like to run it using production
    properties, you should set the VM argument `spring.profiles.active`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'That''s not all. Now, the application with the active production profile failed
    to start because it tried to initialize the `embeddedMongoServer` bean. As you
    might already know, almost all of the additional solutions have auto configuration
    set in Spring Boot. It is no different in this case. We need to exclude the `EmbeddedMongoAutoConfiguration` class from
    auto configuration in the production profile:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'We might as well use the configuration class to exclude that artifact:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'Of course, we could have used a more elegant solution, such as Maven profiles,
    and excluded the whole `de.flapdoodle.embed.mongo` artifact from the target build
    package. The presented solution is just one of several possibilities to solve
    the problem, but it shows the auto configuration and profile mechanisms in Spring
    Boot. Now, you can run our sample application and perform some tests using, for
    example, Swagger UI. You can also connect to the database using the Mongo client
    and check out the changes in the database. Here''s our sample project''s final
    file structure:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: The example application is complete. These are all Spring Boot features I would
    like to show you in this chapter. I have focused on those that are especially
    useful for creating REST-based services.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: I have guided you through the process of single-microservice development, from
    a really basic example to a more advanced, production-ready Spring Boot application.
    I have described how to use starters to enable additional features for the project; use
    the Spring Web library to implement services that expose REST API methods; and
    then we moved on to customizing the service configuration using properties and
    YAML files. We also saw how to document and provide specifications for exposed
    REST endpoints. Next, we configured health checks and monitoring features. We
    used Spring Boot profiles to adapt the application to run in different modes and,
    finally, we used ORM features for interacting with embedded and remote NoSQL databases.
  prefs: []
  type: TYPE_NORMAL
- en: It's not an accident that I have not mentioned anything about Spring Cloud in
    this chapter. You just can't start using Spring Cloud projects without basic knowledge
    and experience in working with Spring Boot. Spring Cloud provides many different
    features that allow you to place your service inside a full microservice-based
    ecosystem. We will be discussing these functionalities one by one in the following
    chapters.
  prefs: []
  type: TYPE_NORMAL
