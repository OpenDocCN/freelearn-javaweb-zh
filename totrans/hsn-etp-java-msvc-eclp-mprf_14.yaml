- en: Reactive Programming and Future Developments
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Event-driven architectures have been around for a long time, and asynchronous
    method invocations, message-driven beans, event control logic, and so on are constructs
    that developers are familiar with. However, with the popularity and adoption of
    cloud resources and on-demand scalability, organizations have a renewed interest
    in reactive programming approaches that can exploit serverless and function as
    service-type environments. Eclipse MicroProfile also includes specifications related
    to reactive programming in projects that currently live outside the Eclipse MicroProfile
    umbrella/platform release.
  prefs: []
  type: TYPE_NORMAL
- en: 'In addition to these, there are also projects in the Eclipse MicroProfile sandbox
    that the community is currently discussing, implementing, and evaluating to decide
    whether or not they should be promoted to official MicroProfile projects. This
    chapter will help you learn about the current MicroProfile specifications related
    to reactive programming as well as give you a glimpse into what is already in
    motion and what is upcoming in relation to the projects that sit outside the umbrella/platform
    release and in the MicroProfile sandbox. The following topics will be covered
    in this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: An overview of what reactive messaging is
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: An explanation of the reactive messaging architecture within Eclipse MicroProfile
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A description of the Eclipse MicroProfile specifications related to reactive
    programming
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Examples of how to use the reactive message specification of Eclipse MicroProfile
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: An overview of MicroProfile projects/specifications that sit outside the umbrella
    or platform release
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A description of projects that sit within the Eclipse MicroProfile sandbox
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: An insight into the current relationship between Eclipse MicroProfile and Jakarta
    EE and an analysis of their possible futures
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Reactive programming work in Eclipse MicroProfile
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: At the time of writing, the reactive-related specifications that are part of
    Eclipse MicroProfile are Reactive Streams Operators, Reactive Messaging, and Context
    Propagation. Reactive work within the MicroProfile community continues to evolve,
    and new specifications may surface in the future as well as newer releases of
    existing reactive-related ones.
  prefs: []
  type: TYPE_NORMAL
- en: An overview of Reactive Messaging
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The [Reactive Manifesto](https://www.reactivemanifesto.org/) defines the characteristics
    of reactive systems to including an asynchronous messaging core that is used to
    build elastic, resilient systems. This is typically illustrated via a diagram
    such as the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/a5e7920f-3372-4247-a4d6-a9e52c974d3f.png)'
  prefs: []
  type: TYPE_IMG
- en: The idea is that interaction via asynchronous messages promotes resilience,
    elasticity, and, in turn, responsiveness.
  prefs: []
  type: TYPE_NORMAL
- en: The **MicroProfile Reactive Messaging** (**MP-RM**) specification aims to enable
    microservice-based applications with the characteristics of reactive systems via
    event-driven microservices. The specification focuses on versatility and is suitable
    for building different types of architecture and applications.
  prefs: []
  type: TYPE_NORMAL
- en: Asynchronous interactions with different services and resources can be implemented
    using reactive messaging. Typically, asynchronous database drivers can be used
    in conjunction with reactive messaging to read and write into a data store in
    a non-blocking and asynchronous manner.
  prefs: []
  type: TYPE_NORMAL
- en: When building microservices, **Command Query Responsibility Segregation** (**CQRS**)
    and event-sourcing patterns provide an answer to data sharing between microservices
    ([https://martinfowler.com/bliki/CQRS.html](https://martinfowler.com/bliki/CQRS.html)).
    Reactive messaging can also be used as the foundation for CQRS and the event-sourcing
    mechanism, as these patterns embrace message-passing as a core communication pattern.
  prefs: []
  type: TYPE_NORMAL
- en: MicroProfile reactive messaging architecture
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'An application using reactive messaging is composed of CDI beans that consume,
    produce, and process messages. The messages can be internal to the application,
    or can be sent and received via external message brokers, as illustrated in the
    following diagram:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/8aec63b4-925c-414e-97b0-409c29421e65.png)'
  prefs: []
  type: TYPE_IMG
- en: This figure shows a Kafka topic publishing messages to a first bean, which does
    some processing and publishes it to a second bean, which does its own processing/filtering,
    and finally publishes the message as an AMQP topic.
  prefs: []
  type: TYPE_NORMAL
- en: As we will see when we look into MP-RM examples, application beans contain methods
    annotated with `@Incoming` and/or `@Outgoing ...`
  prefs: []
  type: TYPE_NORMAL
- en: Message shapes
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The MP-RM specification defines a number of supported signature types that
    beans can use to define publish and subscriber behaviors. These signatures depend
    on a few key types that are outlined in the following list:'
  prefs: []
  type: TYPE_NORMAL
- en: '`org.reactivestreams.Publisher`: A Reactive Streams `Publisher<T>` is a provider
    of a potentially unlimited number of sequenced elements, publishing them according
    to the demand received from its link subscriber(s).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`org.reactivestreams.Subscriber`: A Reactive Stream `Subscriber<T>` interface
    that is used to signal demand to `Publisher`. It provides events for subscription
    information, zero or more data events, and error and completion events.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`org.reactivestreams.Processor`: This Reactive Stream `Processor<T,R>` interface
    simply extends both `Subscriber<T>` and `Publisher<R>`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`org.eclipse.microprofile.reactive.streams.operators.PublisherBuilder`: The
    MP Reactive Streams Operators `PublisherBuilder` interface allows you to build
    up a Reactive Streams `Publisher` from various sources and apply operations to
    transform/filter ultimately published messages.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`org.eclipse.microprofile.reactive.streams.operators.ProcessorBuilder`: The MP
    Reactive Streams Operators `ProcessorBuilder` interface allows you to build up
    a Reactive Streams `Processor` from various sources and apply operations to transform/filter
    ultimately published messages.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`org.eclipse.microprofile.reactive.streams.operators.SubscriberBuilder`: The MP
    Reactive Streams Operators `ProcessorBuilder` interface allows you to build up
    a Reactive Streams `Subscriber` from various sources and apply operations to transform/filter
    ultimately published messages.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`java.util.concurrent.CompletionStage`: This JDK concurrent `util` package
    interface defines a stage of computation that is typically asynchronous, and computes
    an action or value. `CompletionStage` can be combined so that a graph of stages
    may be executed to produce the final result.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`org.eclipse.microprofile.reactive.messaging.Message<T>`: An MP-RM interface
    that provides a wrapper around the payload of type `T` and an `ack` method to
    acknowledge receipt of the message.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'With these types defined, we can look at the various types of method that produce
    data by pushing messages onto outgoing channels that MP-RM supports. The publisher
    method types of methods all have an `@Outgoing("channel-name")` annotation and
    support signatures as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '`Publisher<Message<T>> method()`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Publisher<T> method()`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`PublisherBuilder<Message<T>> method()`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`PublisherBuilder<T> method()`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`T method()`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`CompletionStage<T> method()`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Consumer methods all have an `@Incoming("channel-name")` annotation and support
    signatures as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '`Subscriber<Message<T>> method()`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Subscriber<T> method()`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`SubscriberBuilder<Message<T>>`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`SubscriberBuilder<T>`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`void method(Message<T> payload)`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`void method(T payload)`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`CompletionStage<?> method(Message<T> payload)`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`CompletionStage<?> method(T payload)`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Methods that both consume and produce data are known as processors, and will
    have both an `@Incoming("channel-in")` and `@Outgoing("channel-out")` annotation.
    Supported signatures are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '`Processor<Message<I>, Message<O>> method()`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Processor<I, O> method();`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`ProcessorBuilder<Message<I>, Message<O>>method()`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`ProcessorBuilder<I, O> method();`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Publisher<Message<O>> method(Message<I> msg)`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Publisher<O> method(I payload)`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`PublisherBuilder<Message<O>> method(Message<I> msg)`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`PublisherBuilder<O> method(I payload)`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Message<O> method(Message<I> msg)`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`O method(I payload)`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`CompletionStage<Message<O>> method(Message<I> msg)`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`CompletionStage<O> method(I payload)`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Publisher<Message<O>> method(Publisher<Message<I>> pub)`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`PublisherBuilder<Message<O>> method(PublisherBuilder<Message<I>> pub)`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Publisher<O> method(Publisher<I> pub)`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`PublisherBuilder<O> method(PublisherBuilder<I> pub)`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Now, we will look at some examples of using beans with these signatures to build
    up message processing chains.
  prefs: []
  type: TYPE_NORMAL
- en: MicroProfile Reactive Streams operators
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Reactive Streams requires more than just plumbing publishers to subscribers.
    Typically, a stream needs to be manipulated in some way, such as applying operations
    including `map`, `filter`, and `flatMap`. Neither Reactive Streams nor the JDK
    provide an API for performing these manipulations. Since users are not meant to
    implement Reactive Streams themselves, this means the only way to do these manipulations
    currently is to depend on a third-party library providing operators, such as Akka
    Streams, RxJava, or Reactor.
  prefs: []
  type: TYPE_NORMAL
- en: The MicroProfile Reactive Streams Operators API seeks to fill that gap so that
    MicroProfile application developers can manipulate Reactive Streams without bringing
    in a third-party dependency. ...
  prefs: []
  type: TYPE_NORMAL
- en: MicroProfile Context Propagation
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This specification, which sits outside the MicroProfile umbrella of platform
    release, is still in the proposed or draft state. We will discuss this specification
    in more detail in the *MicroProfile Future Developments* section later in this
    chapter, but we would like to give you a high-level introduction here.
  prefs: []
  type: TYPE_NORMAL
- en: The MicroProfile Context Propagation specification introduces APIs for propagating
    contexts across units of work that are thread-agnostic. It makes it possible to
    propagate context that was traditionally associated with the current thread across
    various types of units of work, such as `CompletionStage`, `CompletableFuture`,
    `Function`, and `Runnable`, regardless of which particular thread ends up executing
    them.
  prefs: []
  type: TYPE_NORMAL
- en: MicroProfile reactive messaging examples
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section, we will cover some examples of using MP-RM to create CDI beans
    that produce and consume messages.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s say you want a CDI bean to act as a source of a `Message<String>` such
    that whenever its `publishMessage(String)` method is called, an MP-RM message
    is posted to some MP-RM channel. To do this, we need to define a connector that
    bridges between the CDI bean and the MP-RM layer. An example of an incoming message
    connector that does this is shown in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: MicroProfile future developments
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As mentioned in [Chapter 2](0f9d569f-1ffb-4662-8cea-c8b230a4d627.xhtml), *Governance
    and Contributions*, new ideas brought to the Eclipse MicroProfile project are
    first tried in the MicroProfile sandbox following an implementation-first approach
    to innovation. The sandbox exercise gives the opportunity for the implementor
    and the community to discuss, analyze, and evaluate how this new idea fits in
    with the MicroProfile project. If, at the end of the sandbox exercise, the community
    deems that this new idea is worth adding to the project, a specific MicroProfile
    sub-project is created for it. The sub-project must issue at least one release
    before it can be considered for addition to a MicroProfile umbrella/platform release.
    At a very high-level, this is the process that new ideas and future developments
    follow under the MicroProfile project.
  prefs: []
  type: TYPE_NORMAL
- en: In the next sections, we will discuss two types of projects those globally that
    are currently MicroProfile sub-projects that presebtly sit outside the MicroProfile
    umbrella/platform release (think of these as projects that have already graduated
    out of the MicroProfile sandbox), and the ones that are still in the MicroProfile
    sandbox. Lastly, we will discuss the current relationship between Eclipse MicroProfile
    and Jakarta EE and how their roadmaps may or may not meet.
  prefs: []
  type: TYPE_NORMAL
- en: Projects outside the umbrella
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this section, we will cover projects that sit outside the Eclipse MicroProfile
    umbrella release, at the time of writing, of course. These are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Reactive Streams Operators
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Reactive Messaging
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Long Running Actions
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Context Propagation
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: GraphQL
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Reactive Streams Operators and Reactive Messaging projects were already discussed
    in the previous sections of this chapter, so in this section we will cover only
    Long Running Actions, Context Propagation, and GraphQL.
  prefs: []
  type: TYPE_NORMAL
- en: Long Running Actions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In a loosely-coupled service environment, the motivation behind the **Long
    Running Actions** (**LRA**) specification is to provide consistent outcomes by
    business processes comprised of calls to many microservices without the need to
    lock data. One way to think about LRA is as *transactions for microservices*.
    Examples of situations when you need LRA include the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Ordering a book online will require the retirement of a book from the inventory,
    the processing of a payment, and finally shipping of the book. All these tasks
    need to happen atomically, in other words, they need to be processed all together,
    in that, if any of the tasks fail, then all tasks must be undone.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Making a flight reservation will require the removal of a seat from the airplane's
    list of available seats, the selection and assignment of a specific seat to the
    traveler, processing the payment, and the creation of a record locator. Again,
    all these tasks have to happen within the same long running action.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Not only do the preceding examples have to happen atomically, but they also
    have to generate a result where the data is consistent, even if any of their intermediate
    steps failed.
  prefs: []
  type: TYPE_NORMAL
- en: The current proposed solution for MicroProfile LRA has taken its inspiration
    from the *OASIS Web Services Composite Application Framework Technical Committee* ([https://www.oasis-open.org/committees/tc_home.php?wg_abbrev=ws-caf](https://www.oasis-open.org/committees/tc_home.php?wg_abbrev=ws-caf)),
    namely, the *Web Services **Long Running Action transaction model* ([https://www.oasis-open.org/committees/document.php?document_id=12794](https://www.oasis-open.org/committees/document.php?document_id=12794)),
    but has been updated to be more suited for use in microservice-based architectures.
  prefs: []
  type: TYPE_NORMAL
- en: For further information on the MicroProfile LRA specification, refer to [https://github.com/eclipse/microprofile-lra/blob/master/spec/src/main/asciidoc/microprofile-lra-spec.adoc](https://github.com/eclipse/microprofile-lra/blob/master/spec/src/main/asciidoc/microprofile-lra-spec.adoc).
  prefs: []
  type: TYPE_NORMAL
- en: 'The MicroProfile Long Running Actions specification model includes three main entities:
    compensators, a logical coordinator, and a client. A client can explicitly start
    a new LRA in two different ways:'
  prefs: []
  type: TYPE_NORMAL
- en: Via an annotation, or
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Via an API call
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Either one creates a new LRA. If a service does something that may need to be
    later undone, then the client needs to register a compensator with the LRA. If
    the client chooses to close or cancel the LRA, the compensator will undo the work
    the service performed within the scope of the LRA or compensate for any uncompleted
    work.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following are globally some of the main LRA annotations:'
  prefs: []
  type: TYPE_NORMAL
- en: '`@LRA` controls the life cycle of an LRA.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`@Compensate` indicates that the method should be invoked if the LRA is canceled.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`@Complete` indicates that the method should be invoked if the LRA is closed.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`@Forget` indicates that the method may release any resources that were allocated
    for this LRA.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`@Leave` indicates that this class is no longer interested in this LRA.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`@Status` reports the status when the annotated method is invoked.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You can use these annotations with JAX-RS and non-JAX-RS methods. In addition,
    this specification supports asynchronous and reactive features of JAX-RS, LRA
    nesting, and timeouts. Finally, it is worth mentioning that the LRA specification
    ensures atomicity and eventual consistency by placing certain requirements on
    the entities that participate in the protocol. As a MicroProfile project, the
    MicroProfile LRA specification, at the time of writing, is in a proposed or draft
    state.
  prefs: []
  type: TYPE_NORMAL
- en: Context Propagation
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The goal of the MicroProfile Context Propagation specification is to propagate
    context across units of work that are thread-agnostic. In a reactive model, the
    execution of logic is split into units of work that are chained together to assemble
    a reactive pipeline. Each unit of work executes within a context, which is often
    unpredictable and depends on the particular reactive engine being used. Some units
    might run with the context of a thread awaiting completion, or the context of
    a previous unit that completed and triggered the dependent unit, or with no context
    at all. The MicroProfile Context Propagation specification makes it possible for
    thread context propagation to easily be done in a type-safe manner, keeping boilerplate
    ...
  prefs: []
  type: TYPE_NORMAL
- en: GraphQL
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: GraphQL is an open source data query and manipulation language for APIs, and
    a runtime for fulfilling queries with existing data. It interprets strings from
    the client and returns data in an understandable, predictable, and predefined
    manner. GraphQL is an alternative to REST, though not necessarily a replacement. The
    goal of the MicroProfile GraphQL specification is to provide a set of APIs to
    enable users to quickly develop portable GraphQL-based applications in Java. As
    a MicroProfile project, the MicroProfile GraphQL specification is currently, at
    the time of writing, in a proposed or draft state.
  prefs: []
  type: TYPE_NORMAL
- en: GraphQL is based on a Facebook specification. For more information on this, please
    refer to `https://graphql.github.io/graphql-spec`. A more general overview of
    GraphQL can be found on [https://graphql.org/](https://graphql.org/).
  prefs: []
  type: TYPE_NORMAL
- en: GraphQL and REST have many similarities and are both widely used in modern microservice-based applications.
  prefs: []
  type: TYPE_NORMAL
- en: Differences between GraphQL and REST
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Here are the main differentiating features of GraphQL when compared to REST:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Schema-driven**: The schema acts as a contract between the server and its
    clients.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Single HTTP endpoint**: A single endpoint and access to data and operations
    are achieved through the query language.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Flexible data retrieval**: Enables the client to select data in the response
    with a fine level of granularity, thereby avoiding over- or under-fetching data.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Reduction of server requests**: The language allows the client to aggregate
    the expected data into a single request.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Easier version management**: Enables the creation of new data while deprecating
    old ones.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Partial results**: A result is made up of data and errors. Clients are responsible
    ...'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: GraphQL and databases
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: GraphQL is not a database technology. Instead, it is a data query and manipulation
    tool for APIs and is agnostic to any database or storage technologies. However,
    it can be used in front of any backend and is capable of aggregating data from
    multiple backend data sources with a single API.
  prefs: []
  type: TYPE_NORMAL
- en: Projects in the sandbox
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The MicroProfile Project sandbox is where the community can come up with ideas
    by trying out an implementation of features and capabilities to elicit feedback,
    discussion, and evaluation from members within the community with the goal of
    deciding whether or not the idea should become a new API/specification for the
    MicroProfile project.
  prefs: []
  type: TYPE_NORMAL
- en: The MicroProfile sandbox is located at [https://github.com/eclipse/microprofile-sandbox](https://github.com/eclipse/microprofile-sandbox).
  prefs: []
  type: TYPE_NORMAL
- en: Past project proposals that graduated from the sandbox into official MicroProfile
    projects were GraphQL and Reactive Streams Operators. At the time of writing,
    there is only one proposal project in the sandbox, Boost.
  prefs: []
  type: TYPE_NORMAL
- en: MicroProfile Boost
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: At the time of writing, the MicroProfile Boost is under community evaluation
    in the MicroProfile sandbox. Boost is a Maven plugin that enhances builds for
    your MicroProfile applications.
  prefs: []
  type: TYPE_NORMAL
- en: For more information on Boost, go to [https://github.com/eclipse/microprofile-sandbox/tree/master/proposals/boost](https://github.com/eclipse/microprofile-sandbox/tree/master/proposals/boost).
  prefs: []
  type: TYPE_NORMAL
- en: Boost defines Maven dependencies, known as **boosters**, for MicroProfile APIs,
    for example `mpConfig` for MicroProfile Config, as well as for Java EE APIs. In
    addition, it defines dependencies for the runtimes that implement the different
    MicroProfile APIs, for example `openliberty`. One more Boost-defined maven dependency
    specified as a BOM (Bill-of-Material) indicates the version of the MicroProfile
    umbrella project to use for the maven build with respect to the MicroProfile APIs.
    The BOM contents are managed by the plugin. As a user of Boost, you include these
    dependencies in your `pom.xml` file to ease the build process of your MicroProfile
    application.
  prefs: []
  type: TYPE_NORMAL
- en: Eclipse MicroProfile and Jakarta EE
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'What is the relationship between the Eclipse Jakarta Enterprise Java project
    and the Eclipse MicroProfile project? Short answer: it remains to be seen. Long
    answer: let''s begin.'
  prefs: []
  type: TYPE_NORMAL
- en: The Eclipse MicroProfile project was initiated to address a lack of progress
    in the Java EE specifications under the **Java Community Process** (**JCP**).
  prefs: []
  type: TYPE_NORMAL
- en: For more information on the Java Community Process, please visit `https://jcp.org/en/home/index`.
  prefs: []
  type: TYPE_NORMAL
- en: It has been over two years since the MicroProfile project moved to the Eclipse
    Foundation. Approximately one year later, Oracle announced its intention to move
    Java EE over to the Eclipse Foundation and rename it Jakarta EE. The move to Jakarta
    has been a long drawn-out process that is still ...
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this chapter, we learned about future developments in the MicroProfile specification
    with the Long Running Actions, Context Propagation, and GraphQL projects outside
    the umbrella release, and the Boost project that''s still in the MicroProfile
    sandbox. In addition, you learned about reactive messaging concepts, the MicroProfile
    reactive messaging architecture, and how to implement reactive microservices using
    Eclipse MicroProfile reactive constructs via code examples. You also gained some
    knowledge of the background of each of these projects, their capabilities, annotations,
    and code examples when applicable, as well as their current state. Lastly, we
    presented the relationship between two similar but different projects: Eclipse
    MicroProfile and Jakarta EE, and discussed how their possible relationship could
    evolve in the future.'
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will learn about Eclipse MicroProfile in multi-cloud
    environments and deployments.
  prefs: []
  type: TYPE_NORMAL
- en: Questions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: If I have a source of messages, how do I integrate this into my MicroProfile
    applications?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Which of the existing MicroProfile specifications will MicroProfile Context
    Propagation best support?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What are the current MicroProfile specifications that support reactive programming?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What are the MicroProfile specifications that currently sit outside the umbrella/platform
    MicroProfile release?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What is the purpose of having a MicroProfile sandbox?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What are the projects that currently sit in the MicroProfile sandbox?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What is the current relationship between Eclipse MicroProfile and Jakarta EE?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What will the future relationship between Eclipse MicroProfile and Jakarta EE
    look like?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Further reading
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: For MicroProfile reactive messaging, the [http://reactivex.io/](http://reactivex.io/)
    site provides motivation, tutorials, language bindings, and more.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A good starting point for GraphQL is the [https://graphql.org/](https://graphql.org/)
    site, which provides more background on the motivation behind it, as well as many
    resources for exploring how to put it to use.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
