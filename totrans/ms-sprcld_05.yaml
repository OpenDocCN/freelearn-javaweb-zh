- en: Distributed Configuration with Spring Cloud Config
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: It is the right time to introduce a new element in our architecture, a distributed
    configuration server. Similar to service discovery, this is one of the key concepts
    around microservices. In the previous chapter, we discussed in detail how to prepare
    discovery, both on the server and client sides. But so far, we have always provided
    a configuration for the application using properties placed inside a fat JAR file.
    That approach has one big disadvantage, it requires a recompilation and a redeployment
    of the microservice's instance. Another approach supported by Spring Boot assumes
    the use of an explicit configuration stored in a filesystem outside of the fat
    JAR. It can be easily configured for an application during startup with the `spring.config.location`
    property. That approach does not require a redeployment, but it is also not free
    from drawbacks. With a lot of microservices, a configuration management based
    on explicit files placed in a filesystem may be really troublesome. In addition,
    let’s imagine that there are many instances of every microservice and each of
    them has a specific configuration. Well, with that approach it is better not to
    imagine it.
  prefs: []
  type: TYPE_NORMAL
- en: Anyway, a distributed configuration is a very popular standard in a cloud-native
    environment. Spring Cloud Config provides server-side and client-side support
    for externalized configuration in a distributed system. With that solution, we
    have one central place where we can manage external properties for applications
    across all environments. The concept is really simple and easy to implement. A
    server does nothing more than expose HTTP and resource-based API interfaces, which
    returns `property` files in JSON, YAML, or properties formats. Additionally, it
    performs decryption and encryption operations for returned property values. A
    client needs to fetch configuration settings from a server, and also decrypt them
    if such a feature has been enabled on the server side.
  prefs: []
  type: TYPE_NORMAL
- en: Configuration data may be stored in different repositories. The default implementation
    of `EnvironmentRepository` uses a Git backend. It is also possible to set up other
    VCS systems such as SVN. If you don't want to take advantage of features provided
    by VCS as a backend, you may use the filesystem or Vault. Vault is a tool for
    managing secrets, which stores and controls access to such resources as tokens,
    passwords, certificates, and API keys.
  prefs: []
  type: TYPE_NORMAL
- en: 'The topics we will cover in this chapter are:'
  prefs: []
  type: TYPE_NORMAL
- en: HTTP API exposed by Spring Cloud Config Server
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Different types of repository backend on the server side
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Integrating with service discovery
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Reloading the configuration automatically with Spring Cloud Bus and message
    broker
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Introduction to HTTP API resources
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The Config Server provides the HTTP API, which may be invoked in various ways.
    The following endpoints are available:'
  prefs: []
  type: TYPE_NORMAL
- en: '`/{application}/{profile}[/{label}]`: This returns data in a JSON format; the
    label parameter is optional'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`/{application}-{profile}.yml`: This returns the YAML format'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`/{label}/{application}-{profile}.yml`: A variant of the previous endpoint,
    where we can pass an optional label parameter'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`/{application}-{profile}.properties`: This returns the simple key/value format
    used by properties files'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`/{label}/{application}-{profile}.properties`: A variant of the previous endpoint,
    where we can pass an optional label parameter'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: From a client point of view, the application parameter is the name of the application,
    which is taken from the `spring.application.name` or `spring.config.name` property,
    and profile is an active profile or comma-separated list of active profiles. The
    last available parameter `label` is an optional property, important only while
    working with Git as a backend store. It sets the name of the Git branch for configuration
    and defaults to `master`.
  prefs: []
  type: TYPE_NORMAL
- en: Native profile support
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let’s begin with the simplest example, based on a filesystem backend. By default,
    Spring Cloud Config Server tries to fetch configuration data from a Git repository.
    To enable the native profile, we should launch the server with the `spring.profiles.active` option set
    to `native`. It searches for files stored in the following locations, `classpath:/`,
    `classpath:/config`, `file:./`, `file:./config`. It means that properties or YAML
    files may be also placed inside a JAR file. For test purposes, I created a config
    folder inside `src/main/resources`. Our configuration files will be stored in
    that location. Now, we need to go back for a moment to the example from the previous
    chapter. As you probably remember, I introduced the configuration for a clustered
    discovery environment, where each client service instance was launched in a different
    zone. There were three available zones and three client instances, each of them
    has its own profile in the `application.yml` file. The source code for that example
    is available in the `config` branch. Here''s the link:'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://github.com/piomin/sample-spring-cloud-netflix/tree/config](https://github.com/piomin/sample-spring-cloud-netflix/tree/config)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Our current task is to migrate that configuration to the Spring Cloud Config
    Server. Let''s remind ourselves the properties set for that example. Here are
    the profile settings used for the first instance of the client application. According
    to the selected profile, there are a changing instance running port, a default
    discovery server URL and a zone name:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'In the described example I placed all of the profiles settings in a single
    `application.yml` file for simplicity. That file might as well be divided into
    three different files with the names including the profiles, `application-zone1.yml`,
    `application-zone2.yml`, and `application-zone3.yml`. Of course, such names are
    unique to a single application, so if we decided to move the files into a remote
    configuration server, we should take care of their names. The client application
    name is injected from `spring.application.name` and in this case, it is `client-service`.
    So, to conclude, I created three configuration files with the name `client-service-zone[n].yml`
    in the `src/main/resources/config` catalog, where [`n`] is an instance''s number.
    Now, when you call the `http://localhost:8888/client-service/zone1` endpoint, you
    will receive the following response in JSON format:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'We can also call `http://localhost:8888/client-service-zone2.properties` for
    the second instance, which returns the following response as a list of properties:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'The last available version of the HTTP API endpoint, `http://localhost:8889/client-service-zone3.yml`,
    returns data identical to the input file. Here''s the result for the third instance:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: Building a server-side application
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We have started by discussing HTTP, a resource-based API provided by the Spring
    Cloud Config Server, and the way of creating and storing properties there. But
    now let''s move back to the basics. The same as a discovery server, a Config Server
    may be run as a Spring Boot application. To enable it on the server side, we should
    include `spring-cloud-config-server` in our dependencies in the `pom.xml` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'In addition to this, we should enable the Config Server on the main application
    class. It would be a good idea to change the server port to `8888`, because it
    is the default value of the `spring.cloud.config.uri` property on the client side.
    For example, it is auto configured on the client side. To switch the server to
    a different port, you should set the `server.port` property on `8888` or launch
    it with the `spring.config.name=configserver` property. There is a `configserver.yml`
    embedded in the `spring-cloud-config-server` library:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: Building a client-side application
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'If you set port `8888` as the default for the server, the configuration on
    the client side is really simple. All you need to do is to provide the `bootstrap.yml`
    file with the application name and include the following dependency in your `pom.xml`.
    Of course, that rule is applicable only on localhost, because the auto-configured
    Config Server address for a client is `http://localhost:8888`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'If you set a port different than `8888` for the server, or it is running on
    a different machine than the client application, you should also set its current
    address in `bootstrap.yml`. Here are the bootstrap context settings, which allow
    you to fetch properties for `client-service` from the server available on port 
    `8889`. When running the application with the `--spring.profiles.active=zone1` argument, it
    automatically fetches the properties set for the `zone1` profile in the configuration
    server:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: Adding a Eureka Server
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As you have probably noticed, there is the discovery service network location
    address in the client's properties. So, before launching the client service we
    should have a Eureka Server running. Of course, Eureka also has its own configuration,
    which has been stored in the `application.yml` file for the example from the previous
    chapter. That configuration, similar to `client-service`, has been divided into
    three profiles, where each of them differ from the others in such properties as
    the number of the server's HTTP port and the list of discovery peers to communicate
    with.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, we place those `property` files on the configuration server. Eureka fetches
    all of the settings assigned to the selected profile on startup. File naming is
    consistent with the already described standard, which means `discovery-service-zone[n].yml`.
    Before running the Eureka Server, we should include `spring-cloud-starter-config`
    in the dependencies to enable Spring Cloud Config Client, and replace `application.yml`
    with `bootstrap.yml`, which is shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, we may run three instances of the Eureka Server in peer-to-peer communication
    mode by setting a different profile name in the `--spring.profiles.active` property.
    After launching three instances of `client-service`, our architecture looks like
    the following diagram. In comparison to the example from the previous chapter,
    both client and discovery services fetch the configuration from the Spring Cloud
    Config Server, instead of keeping it as a YML file inside a fat JAR:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/9423cf78-f43e-4e95-89a7-fe1beeae4cff.png)'
  prefs: []
  type: TYPE_IMG
- en: Client-side bootstrap approaches
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the example solution described previously, all of the applications must hold
    the network location of the configuration server. The network location of service
    discovery is stored there as a property. At this point, we are confronted with
    an interesting problem to discuss. We could ask whether our microservices should
    be aware of the Config Server's network address. In previous discussions, we have
    agreed that the main place all the service’s network locations should be kept
    is the service discovery server. The configuration server is also a Spring Boot
    application like other microservices, so logically it should register itself with
    Eureka to enable the automated discovery mechanism for other services that have
    to fetch data from the Spring Cloud Config Server. This in turn requires placing
    the service discovery connection settings in `bootstrap.yml` instead of the `spring.cloud.config.uri`
    property.
  prefs: []
  type: TYPE_NORMAL
- en: Choosing between these two different approaches is one of the decisions you
    need to make while designing your system architecture. It's not that one solution
    is better than the other. The default behavior for any application that uses the `spring-cloud-config-client`
    artifact is called **Config First Bootstrap** in Spring Cloud nomenclature. When
    a config client starts up, it binds to the server and initializes the context
    with remote property sources. That approach has been presented in the first example
    in this chapter. In the second solution, the Config Server registers with the
    service discovery and all of the applications may use `DiscoveryClient` to locate
    it. That approach is called **Discovery First Bootstrap**. Let's implement an
    example that illustrates that concept.
  prefs: []
  type: TYPE_NORMAL
- en: Config Server discovery
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To access that example on GitHub, you need to switch to the `config_with_discovery` branch.
    Here''s the link:'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://github.com/piomin/sample-spring-cloud-netflix/tree/config_with_discovery](https://github.com/piomin/sample-spring-cloud-netflix/tree/config_with_discovery).'
  prefs: []
  type: TYPE_NORMAL
- en: 'The first change is related to the `sample-service-discovery` module. We don’t
    need the `spring-cloud-starter-config` dependency there. The simple configuration
    is not fetched from remote property sources, but set in `bootstrap.yml`. In contrast
    to the previous example, we launch a single standalone Eureka instance in order
    to simplify the exercise:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'By contrast, we should include the `spring-cloud-starter-eureka` dependency
    for the Config Server. Now, the full list of dependencies is shown in the following
    code. Moreover, a discovery client has to be enabled by declaring the `@EnableDiscoveryClient`
    annotation on the main class, and the Eureka Server address should be provided
    by setting the `eureka.client.serviceUrl.defaultZone` property to `http://localhost:8761/eureka/`
    in the `application.yml` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'On the client application side, it is no longer needed to hold the address
    of the configuration server. The only thing that has to be set is the service
    ID, in case it is different than the Config Server. In accordance with the naming
    convention used for the services in the presented examples, that ID is `config-server`.
    It should be overridden with the `spring.cloud.config.discovery.serviceId` property.
    In order to allow discovery mechanism enable the discovery mechanism to fetch
    remote property sources from the configuration server, we should set `spring.cloud.config.discovery.enabled=true`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'Here''s the screen with the Eureka dashboard, with one instance of the Config
    Server and three instances of `client-service` registered. Every instance of the
    client''s Spring Boot application is the same as for the previous example and
    was launched with the `--spring.profiles.active=zone[n]` parameter, where `n`
    is the number of the zone. The only difference is that all of the client''s service
    configuration files served by the Spring Cloud Config Server have the same connection
    address as the Eureka Server:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/11dbf317-7acc-465c-8714-af1143dd5297.png)'
  prefs: []
  type: TYPE_IMG
- en: Repository backend types
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: All of the previous examples in this chapter have used the filesystem backend,
    which means that the config files were loaded from the local filesystem or classpath.
    This type of backend is very good for tutorial purposes or for testing. If you
    would like to use Spring Cloud Config in production, it is worth considering the
    other options. The first of them is a repository backend based on Git, which is
    also enabled by default. It is not the only one **version control system** (**VCS**)
    that can be used as a repository for configuration sources. The other option is
    SVN, or we can even decide to create a composite environment, which may consist of
    both Git and SVN repositories. The next supported backend type is based on a tool
    provided by HashiCorp, Vault. It is especially useful when managing security properties
    such as passwords or certificates. Let's take a closer look at each of the solutions
    listed here.
  prefs: []
  type: TYPE_NORMAL
- en: Filesystem backend
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: I won't write a lot about this topic, because it has already been discussed
    in the previous examples. All of them have shown how to store property sources
    in the classpath. There is also the ability to load them from disk. By default,
    the Spring Cloud Config Server tries to locate files inside an application's working
    directory or the config subdirectory at this location. We can override the default
    location with the `spring.cloud.config.server.native.searchLocations` property.
    The search location path may contain placeholders for `application`, `profile`,
    and `label`. If you don't use any placeholders in the location path, the repository
    automatically appends the label parameter as a suffix.
  prefs: []
  type: TYPE_NORMAL
- en: As a consequence, the configuration files are loaded from each search location
    and a subdirectory with the same name as the label. For example, `file:/home/example/config`
    is the same as `file:/home/example/config,file:/home/example/config/{label}`.
    This behavior may be disabled by setting `spring.cloud.config.server.native.addLabelLocations`
    to `false`.
  prefs: []
  type: TYPE_NORMAL
- en: As I have already mentioned, a filesystem backend is not a good choice for a
    production deployment. If you place property sources in a classpath inside a JAR
    file, every change requires a recompilation of the application. On the other hand,
    using a filesystem outside of a JAR does not need recompilation, but this approach
    may be troublesome if you have more than one instance of a config service working
    in a high availability mode. In that case, share the filesystem across all of
    the instances or hold a copy of all of the property sources per running instance.
    The Git backend is free from such disadvantages, and that's why it is recommended
    for production use.
  prefs: []
  type: TYPE_NORMAL
- en: Git backend
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The Git version control system has some features that make it very useful as
    a repository for property sources. It allows you to easily manage and audit changes.
    By using well-known VCS mechanisms such as commit, revert, and branching, we can
    perform important operations a lot easier than in a filesystem approach. This
    type of backend also has another two key advantages. It forces a separation between
    the Config Server source code and the `property` files repository. If you take
    a look one more time at the previous examples, you will see that the `property`
    files were stored together with the application source code. Probably some of
    you would say that even if we used a filesystem backend, we can store the whole
    configuration as a separate project on Git and upload it to a remote server on
    demand. Of course, you would be right. But when using a Git backend with the Spring
    Cloud Config, you have those mechanisms available out of the box. In addition,
    it resolves the problems related to running multiple instances of the server.
    If you use a remote Git server, the changes may be easily shared across all of
    the running instances.
  prefs: []
  type: TYPE_NORMAL
- en: Different protocols
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: To set the location of the Git repository for the application, we should use
    the `spring.cloud.config.server.git.uri` property in `application.yml`. If you
    are familiar with Git, you well know that cloning may be realized using file,
    http/https, and ssh protocols. The local repository access allows you to get started
    quickly without a remote server. It is configured with file, prefix, for example,
    `spring.cloud.config.server.git.uri=file:/home/git/config-repo`. For more advanced
    usage when running Config Server in the high availability mode, you should use
    the remote protocols SSH or HTTPS. In this case, Spring Cloud Config clones a
    remote repository and then bases it on the local working copy as a cache.
  prefs: []
  type: TYPE_NORMAL
- en: Using placeholders in URIs
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: All the recently listed placeholders, `application`, `profile`, and `label`,
    are also supported here. We can create a single repository per application using
    a placeholder as in `https://github.com/piomin/{application}`, or even per profile, `https://github.com/piomin/{profile}`.
    This type of backend implementation maps the label parameter of the HTTP resource
    to a Git label, which may refer to commit ID, branch, or tag name. The most appropriate
    way to discover interesting features for us is obviously through an example. Let's
    begin by creating a Git repository dedicated to storing the application's property
    sources.
  prefs: []
  type: TYPE_NORMAL
- en: Building a server application
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'I created an example configuration repository, which is available on GitHub
    here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://github.com/piomin/sample-spring-cloud-config-repo.git](https://github.com/piomin/sample-spring-cloud-config-repo.git).'
  prefs: []
  type: TYPE_NORMAL
- en: 'I placed all of the property sources used in the first example in this chapter,
    which illustrated native profile support for client applications running in different
    discovery zones. Now, our repository holds the files visible in this list:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/d2b06957-1a0d-4f84-ade1-8637cdc7d591.png)'
  prefs: []
  type: TYPE_IMG
- en: 'The Spring Cloud Config Server by default tries to clone a repository after
    the first HTTP resource call. If you would like to force cloning it after startup,
    you should set the `cloneOnStart` property to `true`. Beyond this, it is required
    to set the repository connection settings and the account authentication credentials:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: After running the server, we can call the endpoints known from the previous
    exercises, for example, `http://localhost:8889/client-service/zone1` or `http://localhost:8889/client-service-zone2.yml`.
    The result would be the same as for the earlier tests; the only difference is
    in the data source. Now, let's perform another exercise. As you probably remember,
    we had to change the client's properties a little when we created the example
    with discovery first bootstrap with the `native` profile enabled. Because right
    now we are using a Git backend, we can develop a smarter solution for that case.
    In the current approach, we would create `discovery` branch ([https://github.com/piomin/sample-spring-cloud-config-repo/tree/discovery](https://github.com/piomin/sample-spring-cloud-config-repo/tree/discovery))
    at our configuration repository on GitHub, and we would place the files dedicated
    to the application illustrating the discovery first bootstrap mechanism. If you
    call the Config Server endpoints with the `label` parameter set to `discovery`,
    you will fetch data from our new branch. Try to call `http://localhost:8889/client-service/zone1/discovery`
    and/or `http://localhost:8889/discovery/client-service-zone2.yml` and check the
    result*. *
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s consider another situation. I changed the server port for the third
    instance of `client-service`, but for some reason I would like to move back to
    the previous value. Do I have to change and commit `client-service-zone3.yml`
    with the previous port value? No, all I have to do is to pass the commit ID as
    a `label` parameter while calling the HTTP API resource. The change performed is
    illustrated in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/b6069696-66ed-4ace-bfda-741529faf834.png)'
  prefs: []
  type: TYPE_IMG
- en: 'If I invoke the API endpoint with the parent commit ID instead of branch name,
    the older port number would be returned as a response. Here''s the result of calling `http://localhost:8889/e546dd6/client-service-zone3.yml`,
    where `e546dd6` is the previous commit ID:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: Client-side configuration
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'While building the server side with a Git backend, I have only shown you examples
    of HTTP resource calls.  Here''s the example configuration for the client''s application.
    Instead of setting the `profile` property inside `bootstrap.yml`, we may also
    pass it in the `spring.profiles.active` running parameter. This configuration
    makes the client fetch properties from the `discovery` branch. We may also decide
    to switch to a certain commit ID by setting it in the `label` property, as I have
    already mentioned:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: Multiple repositories
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Sometimes, you may need to configure multiple repositories for a single Config
    Server. I can imagine the situation that you would have to separate the business
    configuration from a typical technical configuration. This is absolutely possible:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: Vault backend
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'I have already mentioned Vault as a tool for securely accessing secrets through
    a unified interface. In order to enable the Config Server to use that type of
    backend, you must run it with the Vault profile `--spring.profiles.active=vault`.
    Of course, before running the Config Server you need to install and launch the
    Vault instance. I suggest you use Docker for this. I know that this is our first
    contact with Docker in this book, and not everyone has knowledge of that tool.
    I have provided a short introduction to Docker, its basic commands, and use cases
    in [Chapter 14](0756243e-39c9-4696-8d79-4175e7cf4c48.xhtml)*, Docker Support*.
    So, if this is your first contact with that technology, please first take a look
    at that introduction. For those of you who are familiar with Docker, here''s the
    command for running a Vault container in development mode. We may override the
    default listen address with the `VAULT_DEV_LISTEN_ADDRESS` parameter or the ID
    of the initial generated root token with the `VAULT_DEV_ROOT_TOKEN_ID` parameter:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: Getting started with Vault
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Vault provides a command line interface, which may be used for adding new values
    to the server and reading them from the server. Examples of calling those commands
    are shown here. However, we have run Vault as a Docker container, so the most
    convenient way to manage the secrets is through the HTTP API:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'The HTTP API is available for our instance of Vault under the `http://192.168.99.100:8200/v1/secret` address.
    When calling every method of that API, you need to pass a token as the request
    header `X-Vault-Token`. Because we set that value in the `VAULT_DEV_ROOT_TOKEN_ID`
    environment parameter while launching a Docker container, it is equal to `client`.
    Otherwise, it would be automatically generated during startup and may be read
    from logs by invoking the command `docker logs vault`. To start working with Vault,
    we in fact need to be aware of two HTTP methods—`POST` and `GET`. When calling
    the `POST` method, we may define the list of secrets that should be added to the
    server. The parameters passed in the `curl` command shown here are created using
    the kv backend, which acts like a key/value store:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'The newly added values may be read from the server by using the `GET` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: Integration with Spring Cloud Config
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'As I have mentioned before, we have to run the Spring Cloud Config Server with
    the `--spring.profiles.active=vault` parameter to enable Vault as a backend store.
    To override the default auto configured settings, we should define the properties
    under the `spring.cloud.config.server.vault.*` key. The current configuration
    for our example application is shown here. An example application is available
    on GitHub; you need to switch to the `config_vault` branch ([https://github.com/piomin/sample-spring-cloud-netflix/tree/config_vault](https://github.com/piomin/sample-spring-cloud-netflix/tree/config_vault))
    to access it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, you may call the endpoint exposed by the Config Server. You have to pass
    the token in the request header, but this time its name is `X-Config-Token`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'The response should be the same as what is shown next. These properties are
    the default for all of the profiles of the client application. You may also add
    specific settings for the selected profile by calling the Vault HTTP `API` method
    with the profile name after a comma character, like this, `http://192.168.99.100:8200/v1/secret/client-service,zone1`. If
    such a profile name is included in the calling path, the properties for both the
    `default` and `zone1` profiles are returned in the response:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: Client-side configuration
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'When using Vault as a backend to your Config Server, the client will need to
    pass a token for the server to be able to retrieve values from Vault. This token
    should be provided in the client configuration settings with the `spring.cloud.config.token`
    property in the `bootstrap.yml` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: Additional features
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Let's take a look at some other useful features of the Spring Cloud Config.
  prefs: []
  type: TYPE_NORMAL
- en: Fail on start and retry
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Sometimes it doesn't make any sense to launch the application if the Config
    Server is unavailable. In this case, we would like to halt a client with an exception.
    To achieve this, we have to set the bootstrap configuration property `spring.cloud.config.failFast`
    to `true`. Such a radical solution is not always the desired behavior. If a Config
    Server is unreachable only occasionally, the better approach would be to keep
    trying to reconnect until it succeeds. The `spring.cloud.config.failFast` property still
    has to be equal to `true`, but we would also need to add the `spring-retry` library
    and `spring-boot-starter-aop` to the application classpath. The default behavior
    assumes to retry six times with an initial backoff interval of 1000 milliseconds. You
    may override these settings by using the `spring.cloud.config.retry.*` configuration
    properties.
  prefs: []
  type: TYPE_NORMAL
- en: Secure client
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The same as for the service discovery, we may secure the Config Server with
    basic authentication. It can be easily enabled on the server side with Spring
    Security. In that case, all the client needs to set is the username and password
    in the `bootstrap.yml` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: Reload configuration automatically
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We have already discussed the most important features of Spring Cloud Config.
    At that point, we implemented examples illustrating how to use different backend
    storage as a repository. But no matter whether we decided to choose filesystem,
    Git, or Vault, our client-side application needed to restart to be able to fetch
    the newest configuration from the server. However, sometimes this is not an optimal
    solution, especially if we have many microservices running and some of them use
    the same generic configuration.
  prefs: []
  type: TYPE_NORMAL
- en: Solution architecture
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Even if we created a dedicated `property` file per single application, an opportunity
    to dynamically reload it without restart could be very helpful. As you may have
    deduced, such a solution is available for Spring Boot and therefore for Spring
    Cloud. In [Chapter 4](b016b615-1eed-457a-9b9c-66ba07c9ce9e.xhtml), *Service Discovery*
    while describing deregistration from the service discovery server, I introduced
    an endpoint, `/shutdown`, which may be used for gracefully shutting down. There
    is also an endpoint available for Spring context restart, which works in a similar
    way to that for shutdown.
  prefs: []
  type: TYPE_NORMAL
- en: 'An endpoint on the client side is just one component of the much larger system
    that needs to be included to enable push notifications for the Spring Cloud Config. The
    most popular source code repository providers, such as GitHub, GitLab, and Bitbucket,
    are able to send notifications about changes in a repository by providing a WebHook
    mechanism. We may configure the WebHook using the provider''s web dashboard as
    a URL and a list of selected event types. Such a provider will call the `POST`
    method defined in the WebHook with a body containing a list of commits. It is
    required to include a Spring Cloud Bus dependency in the project to enable the
    monitor endpoint on the Config Server side. When this endpoint is invoked as a
    result of the WebHook activation, a Config Server prepares and sends an event
    with a list of property sources that has been modified by the last commit. That
    event is sent to a message broker. The Spring Cloud Bus provides implementations
    for RabbitMQ and Apache Kafka. The first may be enabled for the project by including
    the `spring-cloud-starter-bus-amqp` dependency, and the second by including the `spring-cloud-starter-bus-kafka`
    dependency. Those dependencies should also be declared for a client application
    to enable receiving messages from a message broker. We should also enable the
    dynamic refresh mechanism on the client side by annotating the selected configuration
    class with `@RefreshScope`. An architecture of this solution is shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/f0318c08-6af4-40fc-a44a-e1b8885e6a01.png)'
  prefs: []
  type: TYPE_IMG
- en: Reload configuration with @RefreshScope
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'This time we will start unusually from the client side. The example application
    is available on GitHub ([https://github.com/piomin/sample-spring-cloud-config-bus.git](https://github.com/piomin/sample-spring-cloud-config-bus.git)).
    The same as the previous examples, it uses a Git repository as backend storage,
    which is also created on GitHub ([https://github.com/piomin/sample-spring-cloud-config-repo](https://github.com/piomin/sample-spring-cloud-config-repo)).
    I added some new properties to the client''s configuration file and committed
    changes to the repository. Here''s the current version of the client''s configuration:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'I disabled security for Spring Boot Actuator endpoints by setting `management.security.enabled`
    to `false`. It is required to be able to call those endpoints without passing
    security credentials. I also added two test parameters, `sample.string.property`
    and `sample.int.property`, to demonstrate bean refresh mechanisms based on their
    values in the example. Spring Cloud provides some additional HTTP management endpoints
    for the Spring Boot Actuator. One of them is `/refresh`, which is responsible
    for reloading the bootstrap context and refreshing beans annotated with `@RefreshScope`.
    This is an HTTP `POST` method, which may be called on our client''s instance at `http://localhost:8081/refresh`.
    Before testing that functionality, we need to have the discovery and Config Servers
    running. The client application should be launched with the `--spring.profiles.active=zone1 `parameter.
    Here''s the class where the test properties `sample.string.property` and `sample.int.property`
    are injected into the fields:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'That bean is injected into the `ClientController` class and invoked inside
    the `ping` method, which is exposed at `http://localhost:8081/ping`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, let''s change the values for test properties in `client-service-zone1.yml`
    and commit them. If you call the Config Server HTTP endpoint `/client-service/zone1`,
    you''ll see the newest values returned as a response. But when you call the `/ping`
    method exposed on the client application, you will still see older values visible
    on the left side of the following screen. Why? Although the Config Server automatically
    detects repository changes, the client application is not able to automatically
    refresh without any trigger. It requires a restart to read the newest settings,
    or we may force a configuration reload by invoking the previously described `/refresh`
    method:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/49a8d206-7a6b-4477-8b85-40b5427c13f9.png)'
  prefs: []
  type: TYPE_IMG
- en: 'After calling the `/refresh` endpoint on the client application, you will see
    in the log files that the configuration has been reloaded. Now, if you invoke
    `/ping` one more time, the newest property values are returned in the response.
    That example illustrates how a hot reload works for a Spring Cloud application,
    but it is obviously not our target solution. The next step is to enable communication
    with the message broker:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/7c79dd98-0c3d-45ae-a736-678d2cec1cb1.png)'
  prefs: []
  type: TYPE_IMG
- en: Consuming events from a message broker
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: I have already mentioned that we may choose between two message brokers that
    are integrated with the Spring Cloud Bus. In this example, I'm going to show you
    how to run and use RabbitMQ. Let me just say a few words about that solution,
    because we are dealing with it for the first time in the book. RabbitMQ has grown
    into the most popular message broker software. It is written in Erlang and implements
    **Advanced Message Queueing Protocol** (**AMQP**). It is easy to use and configure,
    even if we are talking about such mechanisms as clustering or high availability.
  prefs: []
  type: TYPE_NORMAL
- en: 'The most convenient way to run RabbitMQ on your machine is through a Docker
    container. Two ports have been exposed outside the container. The first of them
    is used for client connections (`5672`) and the second is dedicated to the management
    dashboard (`15672`). I also ran the image with the management tag to enable the
    UI dashboard, which is not available in the default version:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'To enable support for the RabbitMQ broker for our example client application,
    we should include the following dependency in `pom.xml`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'That library contains auto-configuration settings. Because I run Docker on
    Windows, I need to override some default properties. The full service configuration
    is stored inside a Git repository, so the changes affect only remote files. We
    should add the following parameters to the previously used version of the client''s
    property source:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'If you run the client application, an exchange and a queue would be automatically
    created in RabbitMQ. You can easily check this out by logging in to the management
    dashboard available at `http://192.168.99.100:15672`. The default username and
    password are `guest/guest`. Here''s the screen from my RabbitMQ instance. There
    is one exchange with the name `SpringCloudBus` created, with two bindings to the
    client queue and Config Server queue (I have already run it with the changes described
    in the next section). At this stage, I wouldn''t like to go into the detail about
    RabbitMQ and its architecture. A good place for such a discussion would be in
    the [Chapter 11](554c4049-1dc9-430d-8fe7-19f3b9ac99a3.xhtml), *Message-Driven
    Microservices* on the Spring Cloud Stream project:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/c29e1292-6fa9-412f-812f-c60bb2ab2033.png)'
  prefs: []
  type: TYPE_IMG
- en: Monitoring repository changes on a Config Server
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Spring Cloud Config Server has to perform two tasks in the previously described
    process. First of all, it has to detect changes in a `property` file stored in
    a Git repository. This may be achieved by exposing a special endpoint, which would
    be called through a WebHook by the repository provider. The second step is to
    prepare and send a `RefreshRemoteApplicationEvent` targeted at the applications
    that might have been changed.  This in turn requires us to establish connection
    with a message broker. The `spring-cloud-config-monitor` library is responsible
    for enabling the `/monitor` endpoint. To enable support for the RabbitMQ broker,
    we should include the same starter artifact as for the client application:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'That''s not all. The configuration monitor should also be activated in `application.yml`.
    Because each repository provider has a dedicated implementation in Spring Cloud,
    it is necessary to select which of them should be enabled:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'The change detection mechanism may be customized. By default, it detects changes
    in files that match the application name. To override that behavior, you need
    to provide a custom implementation of `PropertyPathNotificationExtractor`. It
    accepts the request headers and body parameters, and returns a list of file paths
    that have been changed. To support notifications from GitHub, we may use `GithubPropertyPathNotificationExtractor`
    provided by `spring-cloud-config-monitor`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: Simulating change events manually
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'A monitor endpoint can be invoked by a WebHook configured on a Git repository
    provider such as GitHub, Bitbucket, or GitLab. Testing such a feature with the
    application running on localhost is troublesome. It turns out that we may easily
    simulate such a WebHook activation by calling `POST /monitor` manually. For example,
    the `Github` command should have the header `X-Github-Event` included in the request.
    The JSON body with changes in the `property` files should look as shown in this
    cURL request:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: Now, let's change and commit a value of one property in the `client-service-zone1.yml`
    file, for example, `sample.int.property`. Then, we may call the `POST /monitor`
    method with the parameters shown in the previous example command. If you configured
    everything according to my descriptions, you should  see the following log line
    on your client application side, `Received remote refresh request. Keys refreshed
    [sample.int.property]`. If you call the `/ping` endpoint exposed by the client
    microservice, it should return the newest value of the changed property.
  prefs: []
  type: TYPE_NORMAL
- en: Testing locally with a GitLab instance
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'For those who do not prefer simulating events, I''m proposing a more practical
    exercise. However, I would point out that it requires not only development skills
    from you, but also a basic knowledge of Continuous Integration tools. We will
    start by running a GitLab instance locally using its Docker image. GitLab is an
    open sourced web-based Git repository manager with wiki and issue tracking features.
    It is very similar to such tools as GitHub or Bitbucket, but may be easily deployed
    on your local machine:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'A web dashboard is available at `http://192.168.99.100:10080`. The first step
    is to create an admin user and then log in using the credentials provided. I won''t
    go into the details of GitLab. It has a user-friendly and intuitive GUI interface,
    so I''m pretty sure you will able to handle it without too much effort. Anyway,
    going forward, I created a project in GitLab with the name `sample-spring-cloud-config-repo`.
    It may be cloned from `http://192.168.99.100:10080/root/sample-spring-cloud-config-repo.git`.
    I committed there the same set of configuration files, which is available in our
    example repository on GitHub.  The next step is to define a WebHook that invokes
    the Config Server''s `/monitor` endpoint with a push notification. To add a new
    WebHook for the project, you need to go to the Settings | Integration section
    and then fill in the URL field with the server address (use your hostname instead
    of localhost). Leave the Push events checkbox selected:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/d7c24aea-9d7a-45ed-b69f-b6aa818239d7.png)'
  prefs: []
  type: TYPE_IMG
- en: 'In comparison with the Config Server implementation with GitHub as a backend
    repository provider, we need to change the enabled monitor type in `application.yml`
    and of course provide a different address:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'We should also register another bean implementing `PropertyPathNotificationExtractor`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: Finally, you may make and push some changes in the configuration files. The
    WebHook should be activated and the client application's configuration should
    be refreshed. That is the last example in this chapter; we may proceed to the
    conclusion.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, I have described the most important features of a Spring Cloud
    Config project. The same as for service discovery, we started from the basics,
    a simple use case on the client and server sides. We discussed the different backend
    repository types for a Config Server. I implemented the examples illustrating
    how to use filesystem, Git, and even third-party tools such as Vault as a repository
    for your `property` files. I put particular focus on interoperability with other
    components, such as service discovery or multiple instances of microservices within
    a larger system. Finally, I showed you how to reload an application's configuration
    without restart, based on WebHooks and a message broker. To conclude, after reading
    this chapter you should be able to use Spring Cloud Config as one element of your
    microservice-based architecture and take an advantage of its main features.
  prefs: []
  type: TYPE_NORMAL
- en: After we have discussed an implemetation of service discovery and configuration
    server with Spring Cloud, we may proceed to an inter-service communication. In
    the next two chapters we will analyze basic and some more advanced samples that
    illustrate synchronous communication between a few microservices.
  prefs: []
  type: TYPE_NORMAL
