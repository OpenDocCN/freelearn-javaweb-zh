- en: Introduction to Kubernetes
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we will start to learn about Kubernetes, the most popular and
    widely used container orchestrator at the time of writing this book. Since the
    subjects on container orchestrators in general and Kubernetes itself are too big
    to be covered in one chapter, I will focus on introducing the areas that I have
    found to be the most important when I used Kubernetes over the last few years.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following topics will be covered in this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: Introducing Kubernetes concepts
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Introducing Kubernetes API objects
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Introducing Kubernetes runtime components
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating a local Kubernetes cluster
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Trying out a sample deployment and getting used to the `kubectl` Kubernetes
    CLI tool
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Managing a Kubernetes cluster
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To work with Kubernetes locally, we will use Minikube running on VirtualBox.
    We will also use the Kubernetes CLI tool known as `kubectl` a lot. `kubectl` comes
    with Docker for macOS, but unfortunately with a version that''s too old (at least
    as of when this chapter was written). Therefore, we need to install a newer version.
    In total, we need the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Minikube version 1.2 or later
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: kubectl version 1.15 or later
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: VirtualBox version 6.0 or later
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'These tools can be installed using Homebrew with the following commands:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'After installing `kubectl`, run the following command to ensure that the newer
    version of `kubectl` is used:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'The installation of VirtualBox will ask you to rely on the system extensions
    that come with VirtualBox:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/d6ccf0f8-41b0-4145-8956-2f97719b5556.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Click on the OK button and then on the Allow button in the next dialog window:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/23dd883f-5cb1-4078-be74-65f77336496c.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Conclude the tool''s installation by verifying the versions of the installed
    tools with the following commands:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'Expect a response such as the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/860bf0d5-1a10-4dc4-9a58-95c7651f5921.png)'
  prefs: []
  type: TYPE_IMG
- en: The source code for this chapter can be found in this book's GitHub repository: [https://github.com/PacktPublishing/Hands-On-Microservices-with-Spring-Boot-and-Spring-Cloud/tree/master/Chapter15](https://github.com/PacktPublishing/Hands-On-Microservices-with-Spring-Boot-and-Spring-Cloud/tree/master/Chapter15).
  prefs: []
  type: TYPE_NORMAL
- en: 'To be able to run the commands that are described in this book, you need to
    download the source code to a folder and set up an environment variable, `$BOOK_HOME`,
    that points to that folder. Some sample commands are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: All the source code examples in this chapter come from the source code in `$BOOK_HOME/Chapter15`
    and have been tested using Kubernetes 1.15.
  prefs: []
  type: TYPE_NORMAL
- en: Introducing Kubernetes concepts
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: At a high level, as a container orchestrator, Kubernetes makes a cluster of
    servers (physical or virtual) that run containers appear as one big logical server
    running containers. As an operator, we declare a desired state to the Kubernetes
    cluster by creating objects using the Kubernetes API. Kubernetes continuously
    compares the desired state with the current state. If it detects differences,
    it takes actions to ensure that the current state is the same as the desired state.
  prefs: []
  type: TYPE_NORMAL
- en: One of the main purposes of a Kubernetes cluster is to deploy and run containers,
    but also to support zero-downtime rolling upgrades using techniques such as green/blue
    and canary deployments. Kubernetes can schedule containers, that is, **pods** that
    contain one or more co-located containers, to the available nodes in the cluster.
    To be able to monitor the health of running containers, Kubernetes assumes that
    containers implement a **liveness** **probe**. If a liveness probe reports an
    unhealthy container, Kubernetes will restart the container. Containers can be
    scaled in the cluster manually or automatically using a horizontal autoscaler.
    To optimize the use of the available hardware resources in a cluster, for example,
    memory and CPU, containers can be configured with **quotas** that specify how
    much resources a container needs. On the other hand, limits regarding how much
    a group of containers is allowed to consume can be specified on a **namespace**
    level. Namespaces will be introduced as we proceed through this chapter. This
    is of extra importance if several teams share a common Kubernetes cluster.
  prefs: []
  type: TYPE_NORMAL
- en: Another main purpose of Kubernetes is to provide service discovery of the running
    pods and its containers. Kubernetes `Service` objects can be defined for services
    discovery and will also load balance incoming requests over the available pods.
    `Service` objects can be exposed externally of a Kubernetes cluster. However,
    as we will see, an Ingress object is, in many cases, better suited to handling
    externally incoming traffic to a group of services. To help Kubernetes find out
    whether a container is ready to accept incoming requests, a container can implement
    a **readiness probe**.
  prefs: []
  type: TYPE_NORMAL
- en: Internally, a Kubernetes cluster provides one big flat IP network where each
    pod gets its own IP address and can reach all the other pods, independent of what
    node they run on. To support multiple network vendors, Kubernetes allows the use
    of network plugins that comply with the **Container Network Interface** (**CNI**) specification
    ([https://github.com/containernetworking/cni](https://github.com/containernetworking/cni)).
    Pods are not isolated by default, that is, they accept all incoming requests.
    CNI plugins that support the use of network policy definitions can be used to
    lock down access to pods, for example, only allowing traffic from pods in the
    same namespace.
  prefs: []
  type: TYPE_NORMAL
- en: To allow multiple teams to work on the same Kubernetes cluster in a safe way, **Role-Based
    Access Control** (**RBAC**, [https://kubernetes.io/docs/reference/access-authn-authz/rbac](https://kubernetes.io/docs/reference/access-authn-authz/rbac)/)
    can be applied. For example, administrators can be authorized to access resources
    on a cluster level, while the access of team members can be locked down to resources
    that are created in a namespace owned by the teams.
  prefs: []
  type: TYPE_NORMAL
- en: In total, these concepts provide a platform for running containers that is scalable,
    secure, highly available, and resilient.
  prefs: []
  type: TYPE_NORMAL
- en: Let's look a bit more into API objects that are available in Kubernetes and
    after that, what runtime components make up a Kubernetes cluster.
  prefs: []
  type: TYPE_NORMAL
- en: Introducing Kubernetes API objects
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Kubernetes defines an API that is used to manage different types of *objects* or
    *resources*, as they are also known as. Some of the most commonly used types, or *kinds*, as
    they are referred to in the API, are as follows in my experience:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Node:** A node represents a server, virtual or physical, in the cluster.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Pod:** A pod represents the smallest possible deployable component in Kubernetes,
    consisting of one or more co-located containers. Typically, a pod consists of
    one container, but there are use cases for extending the functionality of the
    main container by running the second container in a pod. In [Chapter 18](422649a4-94bc-48ae-b92b-e3894c014962.xhtml),
    *Using a Service Mesh to Improve Observability and Management*, a second container
    will be used in the pods, running a sidecar that makes the main container join
    the service mesh.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Deployment**: Deployment is used to deploy and upgrade pods. The deployment
    objects hand over the responsibility of creating and monitoring the pods to a
    ReplicaSet. When creating a deployment for the first time, the work performed
    by the deployment object is no much more than creating the ReplicaSet object.
    When performing a rolling upgrade of deployment, the role of the deployment object
    is more involved.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**ReplicaSet**: A ReplicaSet is used to ensure that a specified number of pods
    are running at all times. If a pod is deleted, it will be replaced with a new
    pod by the ReplicaSet.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Service**: A service is a stable network endpoint that you can use to connect
    to one or multiple pods. A service is assigned an IP address and a DNS name in
    the internal network of the Kubernetes cluster. The IP address of the service
    will stay the same for the lifetime of the service. Requests that are sent to
    a service will be forwarded to one of the available pods using round-robin-based
    load balancing. By default, a service is only exposed inside the cluster using
    a cluster IP address. It is also possible to expose a service outside the cluster,
    either on a dedicated port on each node in the cluster or – even better – through
    an external load balancer that is aware of Kubernetes, that is, it can automatically
    provision a public IP address and/or DNS name for the service. Cloud providers
    that offer Kubernetes as a service, in general, support this type of load balancer.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Ingress*:*** Ingress can manage external access to services in a Kubernetes
    cluster, typically using HTTP. For example, it can route traffic to the underlying
    services based on URL paths or HTTP headers such as the hostname. Instead of exposing
    a number of services externally, either using node ports or through load balancers,
    it is, in general, more convenient to set up an Ingress in front of the services.
    To handle the actual communication defined by the Ingress objects, an Ingress
    controller must be running in the cluster. We will see an example of an Ingress
    controller as we proceed.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Namespace**: A namespace is used to group and, on some levels, isolate resources
    in a Kubernetes cluster. The names of resources must be unique in their namespaces,
    but not between namespaces.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**ConfigMap**: ConfigMap is used to store configuration that''s used by containers.
    ConfigMaps can be mapped into a running container as environment variables or
    files.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Secret: **This is used to store sensitive data used by containers, such as
    credentials. Secrets can be made available to containers in the same way as ConfigMaps.
    Anyone with full access to the API server can access the values of created secrets,
    so they are not as safe as the name might imply.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**DaemonSet**: This ensures that one pod is running on each node in a set of
    nodes in the cluster. In [Chapter 19](7a733f89-e54e-48d2-9a03-d7d2f72157ac.xhtml),
    *Centralized Logging with the EFK Stack*, we will see an example of a log collector,
    Fluentd, that will run on each worker node.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: For a full list of resource objects that the Kubernetes API covers in v1.15,
    see [https://kubernetes.io/docs/reference/generated/kubernetes-api/v1.15/](https://kubernetes.io/docs/reference/generated/kubernetes-api/v1.15/).
  prefs: []
  type: TYPE_NORMAL
- en: 'The following diagram summarizes the Kubernetes resources that are involved
    in handling incoming requests:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/cdf2a486-253b-4f11-abc7-2ee25e3694e6.png)'
  prefs: []
  type: TYPE_IMG
- en: 'In the preceding diagram, we can see the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Two deployments, **Deployment A** and **Deployment B**, have been deployed to
    a cluster with two nodes, **Node 1** and **Node ****2**.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Deployment A** contains two pods, **Pod A1** and **Pod** **A2**.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Deployment B** contains one **Pod** **B1**.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Pod A1** is scheduled to **Node 1**.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Pod A2** and **Pod B1** are scheduled to **Node 2**.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Each deployment has a corresponding service deployed, **Service A** and **Service B**,
    and they are available on all nodes.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: An Ingress is defined to route incoming requests to the two services.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A client typically sends requests to the cluster via an external load balancer.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: These objects are not, by themselves, running components; instead, they are
    definitions of different types of desired states. To reflect the desired state
    in the cluster's current state, Kubernetes comes with an architecture consisting
    of a number of runtime components, as described in the next section.
  prefs: []
  type: TYPE_NORMAL
- en: Introducing Kubernetes runtime components
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'A Kubernetes cluster contains two types of nodes: master nodes and worker nodes.
    Master nodes manage the cluster, while the main purpose of worker nodes is to
    run the actual workload, for example, the containers we deploy in the cluster.
    Kubernetes is built up by a number of runtime components. The most important components
    are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: 'There are components that run on master nodes, constituting the control plane:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`api-server`, the entry point to the control plane. This exposes a RESTful
    API, which, for example, the Kubernetes CLI tool known as `kubectl` uses.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`etcd`, a highly available and distributed key/value store, used as a database
    for all cluster data.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: A controller manager, which contains a number of controllers that continuously evaluate
    the desired state versus the current state for the objects defined in the `etcd`
    database.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Whenever the desired or the current state changes, a controller that's responsible
    for that type of state takes actions to move the current state to the desired
    state. For example, a replication controller that's responsible for managing pods
    will react if a new pod is added through the API server or a running pod dies
    and ensures that new pods are started. Another example of a controller is the
    node controller. It is responsible for acting if a node becomes unavailable, ensuring
    that pods running on a failing node are rescheduled on other nodes in the cluster.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: A **Scheduler**, which is responsible for assigning newly created pods to a
    node with available capacity, for example, in terms of memory and CPU. Affinity
    rules can be used to control how pods are assigned to nodes. For example, pods
    that perform a lot of disks I/O can be assigned to a group of worker nodes that
    have fast SSD disks. Anti-affinity rules can be defined to separate pods, for
    example, to avoid scheduling pods from the same deployment to the same worker
    node.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Components that run on all the nodes that constitute the data plane are as
    follows:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`kubelet`, a node agent that executes as a process directly in the nodes operating
    system and not as a container. It is responsible for that the containers that
    are up and running in the pods being assigned to the node where `kubelet` runs.
    It acts as a conduit between the `api-server` and the container runtime on its
    node.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`kube-proxy`, a network proxy that enables the service concept in Kubernetes
    and is capable of forwarding requests to the appropriate pods, typically in a
    round-robin fashion if more than one pod is available for the specific service. `kube-proxy`
    is deployed as a DaemonSet.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Con****tainer** **runtime**, which is the software that runs containers on
    the node. Typically, this is Docker, but any implementation of the Kubernetes **Container
    Runtime Interface** (**CRI**) can be used, for example, `cri-o` ([https://cri-o.io](https://cri-o.io)), `containerd` ([https://containerd.io/](https://containerd.io/)),
    or `rktlet` ([https://github.com/kubernetes-incubator/rktlet](https://github.com/kubernetes-incubator/rktlet)).'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Kubernetes DNS**, which is a DNS server that''s used in the cluster''s internal
    network. Services and pods are assigned a DNS name, and pods are configured to
    use this DNS server to resolve the internal DNS names. The DNS server is deployed
    as a deployment object and a service object.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The following diagram summarizes the Kubernetes runtime components:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/6d8bfda7-c2b2-4b85-b4d7-5f30250bc9b9.png)'
  prefs: []
  type: TYPE_IMG
- en: Now that we understand the Kubernetes runtime components and what they support
    and run on, let's move on to creating a Kubernetes cluster with Minikube.
  prefs: []
  type: TYPE_NORMAL
- en: Creating a Kubernetes cluster using Minikube
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now, we are ready to create a Kubernetes cluster! We will use Minikube to create
    a local single-node cluster running on VirtualBox.
  prefs: []
  type: TYPE_NORMAL
- en: Before creating the Kubernetes cluster, we need to learn a bit about Minikube
    profiles, the Kubernetes CLI tool known as `kubectl`, and its use of contexts.
  prefs: []
  type: TYPE_NORMAL
- en: Working with Minikube profiles
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In order to run multiple Kubernetes clusters locally, Minikube comes with the
    concept of profiles. For example, if you want to work with multiple versions of
    Kubernetes, you can create multiple Kubernetes clusters using Minikube. Each cluster
    will be assigned a separate Minikube profile. Most of the Minikube commands accept
    a `--profile` flag (or `-p` for short) that can be used to specify which of the Kubernetes
    clusters the command shall be applied to. If you plan to work with one specific
    profile for a while, a more convenient alternative exists, where you specify the
    current profile with the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: The preceding command will set the `my-profile` profile as the current profile.
  prefs: []
  type: TYPE_NORMAL
- en: 'To get the current profile, run the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: If no profile is specified, neither using the `minikube profile` command nor
    the `--profile` switch, a default profile named `minikube` will be used.
  prefs: []
  type: TYPE_NORMAL
- en: Information regarding existing profiles can be found in the `~/.minikube/profiles` folder.
  prefs: []
  type: TYPE_NORMAL
- en: Working with Kubernetes CLI, kubectl
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '`kubectl` is the Kubernetes CLI tool. Once a cluster has been set up, this
    is usually the only tool you need to manage the cluster!'
  prefs: []
  type: TYPE_NORMAL
- en: For managing the API objects we described earlier in this chapter, the `kubectl
    apply` command is the only command you need to know about. It is a declarative
    command; that is, as an operator, we ask Kubernetes to apply the object definition
    we give to the command. It is then up to Kubernetes to figure out what actually
    needs to be done.
  prefs: []
  type: TYPE_NORMAL
- en: Another example of a declarative command that's hopefully familiar to many readers
    of this book is a `SQL SELECT` statement that joins information from several database
    tables. We only declare the expected result in the SQL query, and it is up to
    the database query optimizer to figure out in what order the tables shall be accessed
    and what indexes to use to retrieve the data in the most efficient way.
  prefs: []
  type: TYPE_NORMAL
- en: In some cases, imperative statements that explicitly tell Kubernetes what to
    do are preferred. One example is the `kubectl delete` command, where we explicitly
    tell Kubernetes to delete some API objects. Creating a namespace object can also
    be conveniently done with an explicit `kubectl create namespace` command.
  prefs: []
  type: TYPE_NORMAL
- en: Repetitive usage of the imperative statements will make them fail, for example,
    deleting the same API object twice using `kubectl delete` or creating the same
    namespace twice using `kubectl create`. A declarative command, that is, using
    `kubectl apply`, will not fail on repetitive usage—it will simply state that there
    is no change and exit without taking any action.
  prefs: []
  type: TYPE_NORMAL
- en: 'Some commonly used commands for retrieving information about a Kubernetes cluster
    are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '`kubectl get` shows information about the specified API object.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`kubectl describe` gives more detail about the specified API object.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`kubectl logs` display log output from containers.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We will see a lot of examples of these and other `kubectl` commands in this
    and the upcoming chapters!
  prefs: []
  type: TYPE_NORMAL
- en: If in doubt about how to use the `kubectl` tool, the `kubectl help` and `kubectl
    <command> --help` commands are always available and provide very useful information
    on how to use the `kubectl` tool.
  prefs: []
  type: TYPE_NORMAL
- en: Working with kubectl contexts
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To be able to work with more than one Kubernetes cluster, using either Minikube
    locally or Kubernetes clusters set up on-premises servers or in the cloud, `kubectl`
    comes with the concept of contexts. A context is a combination of the following:'
  prefs: []
  type: TYPE_NORMAL
- en: A Kubernetes cluster
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Authentication information for a user
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A default namespace
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: By default, contexts are saved in the `~/.kube/config` file, but the file can
    be changed using the `KUBECONFIG` environment variable. In this book, we will
    use the default location, so we will unset `KUBECONFIG` using the `unset KUBECONFIG` command.
  prefs: []
  type: TYPE_NORMAL
- en: When a Kubernetes cluster is created in Minikube, a context is created with
    the same name as the Minikube profile and is then set as the current context.
    So, `kubectl` commands that are issued after the cluster is created in Minikube
    will be sent to that cluster.
  prefs: []
  type: TYPE_NORMAL
- en: 'To list the available contexts, run the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'The following is a sample response:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/9f432d73-d57a-4227-bdf6-880fe1b7a39a.png)'
  prefs: []
  type: TYPE_IMG
- en: The wildcard, `*`, in the first column, mark the current context.
  prefs: []
  type: TYPE_NORMAL
- en: You will only see the `handson-spring-boot-cloud` context in the preceding response
    once the cluster has been created, which we will describe here.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you want to switch the current context to another context, that is, work
    with another Kubernetes cluster, run the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding example, the current context will be changed to `my-cluster`.
  prefs: []
  type: TYPE_NORMAL
- en: To update a context, for example, switching the default namespace used by `kubectl`,
    use the `kubectl config set-context` command.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, to change the default namespace of the current context to `my-namespace`,
    use the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding command, `kubectl config current-context` is used to get the
    name of the current context.
  prefs: []
  type: TYPE_NORMAL
- en: Creating a Kubernetes cluster
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To create a Kubernetes cluster using Minikube, we need to run a few commands:'
  prefs: []
  type: TYPE_NORMAL
- en: Unset the `KUBECONFIG` environment variable to ensure that the `kubectl` context
    is created in the default config file, `~/.kube/config`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Specify the Minikube profile to be used for the cluster. We will use `handson-spring-boot-cloud` as
    the profile name.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Create the cluster using the `minikube start` command, where we can also specify
    how much hardware resources we want to allocate to the cluster. To be able to
    complete the examples in the remaining chapters of this book, allocate at least
    10 GB of memory, that is, 10,240 MB, to the cluster.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: After the cluster has been created, we will use the add-on manager in Minikube
    to enable an Ingress controller and a metrics server that comes out of the box
    with Minikube. The Ingress controller and the metrics will be used in the next
    two chapters.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Before you create a Kubernetes cluster using Minikube, it might be a good idea
    to shut down Docker for macOS to avoid running out of memory.
  prefs: []
  type: TYPE_NORMAL
- en: 'Run the following commands to create the Kubernetes cluster:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'After the preceding commands complete, you should be able to communicate with
    the cluster. Try the `kubectl get nodes` command. It should respond with something
    that looks similar to the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/da7ecf41-9129-4e4a-8eb1-c37936e83aa6.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Once created, the cluster will initialize itself in the background, starting
    up a number of system pods in the `kube-system` namespace. We can monitor its
    progress by issuing the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'Once the startup is complete, the preceding command should report the status
    for all pods as `Running` and the READY count should be `1/1`, meaning that a
    single container in each pod is up and running:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/91deb3a4-1969-4c58-a0bf-6c7bab49fd86.png)'
  prefs: []
  type: TYPE_IMG
- en: We are now ready for some action!
  prefs: []
  type: TYPE_NORMAL
- en: Trying out a sample deployment
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s see how we can do the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Deploy a simple web server based on NGINX in our Kubernetes cluster.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Apply some changes to the deployment:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Delete a pod and verify that the ReplicaSet creates a new one.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Scale the web server to three pods to verify that the ReplicaSet fills the gap.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Route external traffic to it using a service with a node port.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'First, create a namespace, `first-attempts`, and update the `kubectl` context
    to use this namespace by default:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'We can now create a deployment of NGINX in the namespace using the `kubernetes/first-attempts/nginx-deployment.yaml` file.
    This file looks as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s explain the preceding source code in more detail:'
  prefs: []
  type: TYPE_NORMAL
- en: The `kind` and `apiVersion` attributes are used to specify that we are declaring
    a deployment object.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `metadata` section is used to describe the deployment object, for example,
    when we give it a name of `nginx-deploy`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Next comes a `spec` section that defines our desired state of the deployment
    object:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`replicas: 1` specifies we want to have one pod up and running.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: A `selector` section that specifies how the deployment will find the pods it
    manages. In this case, the deployment will look for pods that have the `app` label
    set to `nginx-app`.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The `template` section is used to specify how pods shall be created:'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The `metadata` section specifies the `label`, `app: nginx-app`, which is used
    to identify the pods, thereby matching the selector.'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: The `spec` section specifies details for the creation of the single container
    in the pod, that is, `name` and `image` and what `ports` it uses.
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Create the deployment with the following commands:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s see what we got with the `kubectl get all` command:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/b598f9f8-8904-434f-8927-9e2ff0860e89.png)'
  prefs: []
  type: TYPE_IMG
- en: As expected, we got a deployment, ReplicaSet, and pod object. After a short
    while, which mainly depends on the time it takes to download the NGINX Docker
    image, the pod will be up and running, and the desired state will be equal to
    the current state!
  prefs: []
  type: TYPE_NORMAL
- en: 'Change the current state by deleting the pod with the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: Since the pod has a random name (`nginx-deploy-59b8c5f7cd-mt6pg` in the preceding
    example), the pod is selected based on the `app` label, which is set to `nginx-app` in
    the pod.
  prefs: []
  type: TYPE_NORMAL
- en: Running a subsequent `kubectl get all` command will reveal that the difference
    between the desired and current state was detected and handled by the ReplicaSet
    in just a few seconds, that is, a new pod was launched almost immediately.
  prefs: []
  type: TYPE_NORMAL
- en: Change the desired state by setting the number of desired pods to three replicas
    in the `kubernetes/first-attempts/nginx-deployment.yaml` deployment file. Apply
    the change in the desired state by simply repeating the `kubectl apply` command,
    as we mentioned previously.
  prefs: []
  type: TYPE_NORMAL
- en: 'Quickly run the `kubectl get all` command a couple of times to monitor how
    Kubernetes takes action to ensure that the current state meets the new desired
    state. After a few seconds, two new NGINX pods will be up and running. The desired
    state is, again, equal to the current state with three running NGINX pods. Expect
    a response that looks similar to the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/45d803cd-745b-4d3f-9d25-79df6eadfeb1.png)'
  prefs: []
  type: TYPE_IMG
- en: 'To enable external communication with the web servers, create a service using
    the `kubernetes/first-attempts/nginx-service.yaml` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s explain the preceding source code in more detail:'
  prefs: []
  type: TYPE_NORMAL
- en: The `kind` and `apiVersion` attributes are used to specify that we are declaring
    a `Service` object.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `metadata` section is used to describe the `Service` object, for example,
    to give it a name: `nginx-service`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Next comes a `spec` section, which defines the desired state of the `Service` object:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: With the `type` field, we specify that we want `NodePort`, that is, something
    that's accessible externally on a dedicated port on each node in the cluster. This
    means that an external caller can reach the pods using this port on any of the
    nodes in the cluster, independent of which nodes the pods actually run on.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The selector is used by the service to find available pods, which, in our case,
    is pods labeled with `app: nginx-app`.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Finally, `ports` are declared as follows:'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`port: 80` specifies on which port the services will be accessible on, that
    is, internally in the cluster.'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`nodePort: 30080` specifies on what port the service will be externally accessible
    on using any of the nodes in the cluster. By default, a node port must be in the
    range of `30000` to `32767`.'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`targetPort: 80` specifies the port in the pod where the requests shall be
    forwarded to.'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: This port range is used to minimize the risk of colliding with other ports in
    use. In a production system, a load balancer is typically placed in front of the
    Kubernetes cluster, shielding the external users both from the knowledge of these
    ports and the IP numbers of the nodes in the Kubernetes cluster. See [Chapter
    18](422649a4-94bc-48ae-b92b-e3894c014962.xhtml), *Using a Service Mesh to Improve
    Observability and Management*, the *Setting up port forwarding required by Istio*
    section, for more on the usage of a `LoadBalanced` Kubernetes service.
  prefs: []
  type: TYPE_NORMAL
- en: 'Create the service with the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'To see what we got, run the `kubectl get svc` command. Expect a response such
    as the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/987abb3e-e317-4cb1-8169-63a163c2ac1c.png)'
  prefs: []
  type: TYPE_IMG
- en: '`kubectl` supports short names for many of the API objects as an alternative
    to their full name. For example, `svc` was used in the preceding command instead
    of the full name, `service`.'
  prefs: []
  type: TYPE_NORMAL
- en: 'To try this out, we need to know the IP address of the single node in our cluster.
    We can get that by issuing the `minikube ip` command. In my case, it is `192.168.99.116`.
    With this IP address and the node port `30080`, we can direct our web browser
    to the deployed web server. In my case, the address is `http://192.168.99.116:30080`.
    Expect a response such as the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/2f710472-8b21-4b04-ba91-1496388ec643.png)'
  prefs: []
  type: TYPE_IMG
- en: Great! But what about the internal cluster IP address and port?
  prefs: []
  type: TYPE_NORMAL
- en: One way to verify this is to launch a small pod inside the cluster that we can
    use to run `curl` from the inside, that is, we are able to use the internal cluster
    IP address and port. We don't need to use the IP address; instead, we can use
    a DNS name that is created for the service in the internal DNS server. The short
    name of the DNS name is the same as the name of the service, that is, `nginx-service`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Run the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding command looks a bit complex, but it will only do the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Create a pod with a small container based on the `tutum/curl:alpine` Docker
    image, which contains the `curl` command.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Run the `curl -s 'http://nginx-service:80'` command inside the container and
    redirect the output to the Terminal using the `-i` option.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Delete the pod using the `--rm` option.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Expect the output from the preceding command to contain the following information
    (we are only showing parts of the response here):'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/da13fcf8-bed7-49e3-ac2a-5013a5d3621f.png)'
  prefs: []
  type: TYPE_IMG
- en: This means that the web server is also accessible internally in the cluster!
  prefs: []
  type: TYPE_NORMAL
- en: This is basically all we need to know to be able to deploy our system landscape.
  prefs: []
  type: TYPE_NORMAL
- en: 'Wrap this up by removing the namespace containing the `nginx` deployment:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: Before we end this introductory chapter on Kubernetes, we need to learn how
    to manage our Kubernetes cluster.
  prefs: []
  type: TYPE_NORMAL
- en: Managing a Kubernetes cluster
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A running Kubernetes cluster consumes a lot of resources, mostly memory. So,
    when we are done working with a Kubernetes cluster in Minikube, we must be able
    to hibernate it in order to release the resources allocated to it. We also need
    to know how to resume the cluster when we want to continue working with it. Eventually,
    we must also be able to permanently remove the cluster when we don't want to keep
    it on disk anymore.
  prefs: []
  type: TYPE_NORMAL
- en: Minikube comes with a `stop` command that can be used to hibernate a Kubernetes
    cluster. The `start` command we used to initially create the Kubernetes cluster
    can also be used to resume the cluster from its hibernated state. To permanently
    remove a cluster, we can use the `delete` command from Minikube.
  prefs: []
  type: TYPE_NORMAL
- en: Hibernating and resuming a Kubernetes cluster
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Run the following command to hibernate (that is, `stop`) the Kubernetes cluster:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'Run the following command to resume (that is, `start`) the Kubernetes cluster
    again:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: When resuming an already existing cluster, the `start` command ignores switches
    that were used when you were creating the cluster.
  prefs: []
  type: TYPE_NORMAL
- en: 'After resuming the Kubernetes cluster, the `kubectl` context will be updated
    to use this cluster with the currently used namespace set to `default`. If you
    are working with another namespace, for example, the `hands-on` namespace that
    we will use in the upcoming chapter, that is, [Chapter 16](ebeb41b4-eea4-4d73-89ba-6788e2e68bac.xhtml), *Deploying
    Our Microservices to Kubernetes*, you can update the `kubectl` context with the
    following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: Subsequent `kubectl` commands will be applied to the `hands-on` namespace when
    applicable.
  prefs: []
  type: TYPE_NORMAL
- en: Terminating a Kubernetes cluster
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Run the following command to terminate a Kubernetes cluster:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: You can actually run the `delete` command without specifying the profile, but
    I find it safer to be explicit regarding the profile when it comes to the `delete`
    command. Otherwise, you may accidentally delete the wrong Kubernetes cluster!
  prefs: []
  type: TYPE_NORMAL
- en: 'Neither the Minikube profile definition under `~/.minikube/profiles/` nor the
    `kubectl` context in `~/.kube/config` is deleted by this command. If they are
    no longer required, they can be deleted with the following commands:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: The `kubectl config delete-context` command will warn you about deleting the
    active context, but that's okay.
  prefs: []
  type: TYPE_NORMAL
- en: We've successfully learned how to manage a Kubernetes cluster that runs in Minikube.
    We now know how to suspend and resume a cluster and, when no longer needed, we
    know how to permanently remove it.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we have been introduced to Kubernetes as a container orchestrator.
    Kubernetes makes a cluster of servers that run containers appear as one big logical
    server. As an operator, we declare a desired state to the cluster and Kubernetes
    continuously compares the desired state with the current state. If it detects
    differences, it takes actions to ensure that the current state is the same as
    the desired state.
  prefs: []
  type: TYPE_NORMAL
- en: The desired state is declared by creating resources using the Kubernetes API
    server. The controller manager in Kubernetes and its controllers react to the
    various resources that were created by the API server and takes actions to ensure
    that the current state meets the new desired state. The scheduler assigns nodes
    to newly created containers, that is, pods that contain one or more containers.
    On each node, an agent, `kubelet`, runs and ensures that the pods that were scheduled
    to its node are up and running. `kube-proxy` acts as a network proxy, enabling
    a service abstraction by forwarding requests that are sent to the service to available
    pods in the cluster. External requests can be handled either by a service that
    specifies a node port that's available on all of the nodes in the cluster or through
    a dedicated Ingress resource.
  prefs: []
  type: TYPE_NORMAL
- en: We have also tried out Kubernetes by creating a local single-node cluster using
    Minikube and VirtualBox. Using the Kubernetes CLI tool known as `kubectl`, we
    deployed a simple web server based on NGINX. We tried out resilience capabilities
    by deleting the web server, and we observed it being recreated automatically and
    scaled it by requesting three pods running on the web server. Finally, we created
    a service with a node port and verified that we could access it both externally
    and from the inside of the cluster.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, we learned how to manage a Kubernetes cluster running in Minikube on
    VirtualBox in terms of how to hibernate, resume, and terminate a Kubernetes cluster.
  prefs: []
  type: TYPE_NORMAL
- en: We are now ready to deploy our system landscape from the earlier chapters in
    Kubernetes. Head over to the next chapter to find out how to do this!
  prefs: []
  type: TYPE_NORMAL
- en: Questions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: What happens if you run the same `kubectl create` command twice?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What happens if you run the same `kubectl apply` command twice?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In terms of questions *1* and *2*, why do they act differently the second time
    they are run?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What is the purpose of a ReplicaSet, and what other resource creates a ReplicaSet?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What is the purpose of `etcd` in a Kubernetes cluster?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How can a container find out the IP address of another container that runs in
    the same pod?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What happens if you create two deployments with the same name but in different
    namespaces?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What can you make the creation of two services with the same name fail if they
    are created in two different namespaces?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
