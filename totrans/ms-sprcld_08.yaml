- en: Routing and Filtering with API Gateway
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we will discuss the next important element of microservice-based
    architecture, an API gateway. It is not our first encounter with that element
    in practice. We have already implemented a simple gateway pattern in [Chapter
    4](b016b615-1eed-457a-9b9c-66ba07c9ce9e.xhtml), *Service Discovery*, for the purpose
    of presenting how a zoning mechanism works for service discovery with Eureka.
    We used Netflix's Zuul library, which is a JVM-based router and server-side load
    balancer. Netflix designed Zuul to provide features such as authentication, stress
    and canary testing, dynamic routing, and active/active multiregional traffic management. Although
    this is not explicitly stated, it also acts as a gateway in microservice architecture
    and its main task is to hide the complexity of your system from an external client.
  prefs: []
  type: TYPE_NORMAL
- en: Until now, Zuul, in fact, didn't have any competition when it came to API gateway
    pattern implementation inside the Spring Cloud framework. However, the situation
    is changing dynamically with the progressive development of a new project called
    Spring Cloud Gateway. It is built on the base of Spring Framework 5, Project Reactor,
    and Spring Boot 2.0\. The last stable version of that library is 1.0.0, but there
    are many crucial changes in the version currently being developed, 2.0.0, which
    is still at the milestone stage. Spring Cloud Gateway aims to provide a simple,
    effective way to route to APIs and provide cross-cutting concerns related to them
    such as security, monitoring/metrics, and resiliency. Although the solution is
    relatively new, it is definitely worthy of attention.
  prefs: []
  type: TYPE_NORMAL
- en: 'The topics we will cover in this chapter include:'
  prefs: []
  type: TYPE_NORMAL
- en: Static routing and load balancing based on URLs
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Integrating Zuul and Spring Cloud Gateway with service discovery
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating custom filters with Zuul
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Customizing route configuration with Zuul
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Providing Hystrix fallback in case of route failure
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Description of the main components included in Spring Cloud Gateway—predicators
    and gateway filters
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using Spring Cloud Netflix Zuul
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Spring Cloud has implemented an embedded Zuul proxy to allow frontend application's
    proxy calls to backend services. This feature is useful for external clients,
    because it hides system complexity and helps to avoid the need to manage CORS
    and authentication concerns independently for all microservices. To enable it,
    you should annotate a Spring Boot main class with `@EnableZuulProxy`, and this
    forwards incoming requests to the target service. Of course, Zuul is integrated
    with the Ribbon load balancer, Hystrix circuit breaker, and service discovery,
    for example with Eureka.
  prefs: []
  type: TYPE_NORMAL
- en: Building a gateway application
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s go back to the example from the previous chapter to append the last
    element in the microservice-based architecture, API Gateway. What we haven''t
    considered yet is how the external client would call our services. First, we would
    not want to expose the network addresses of all microservices running inside the
    system. We may also perform some operations such as request authentication or
    setting tracing headers in just one place. The solution is to share only a single
    edge network address, which proxies all the incoming requests to the appropriate
    service. The current example''s system architecture is illustrated in the following
    diagram:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/f535ba1e-68e6-4411-9d7d-d75bf828c6bf.png)'
  prefs: []
  type: TYPE_IMG
- en: 'For the needs of our current sample, let me go back for a moment to the project
    already discussed in the previous chapter. It is available in GitHub ([https://github.com/piomin/sample-spring-cloud-comm.git](https://github.com/piomin/sample-spring-cloud-comm.git))
    in `master` branch. Now, we will add a new module called `gateway-service` to
    that project. The first step is to include Zuul with the Maven dependencies. We
    have to use the `spring-cloud-starter-zuul` starter:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'After annotating a Spring Boot main class with `@EnableZuulProxy`, we may proceed
    to route configuration, which is provided in the `application.yml` file. By default,
    the Zuul starter artifact does not include the service discovery client. The routes
    are configured statically with the `url` property set to the network address of
    the service. Now, if you launch all the microservices and the gateway application,
    you may try to call them via the gateway. Each service is available under the
    path set in the configuration property `path` for every single route, for example, `http://localhost:8080/account/1`
    would be forwarded to `http://localhost:8091/1`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: Integration with service discovery
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The static route configuration presented in the previous example is not enough
    for a microservice-based system. The main requirement for an API gateway is a
    built-in integration with service discovery. To enable service discovery with
    Eureka for Zuul, we have to include the `spring-cloud-starter-eureka` starter
    in the project dependencies and enable the client by annotating the application''s
    main class with `@EnableDiscoveryClient`. In fact, it does not make sense to let
    the gateway register itself in discovery server, it must only fetch the current
    list of registered services. So we would disable that registration by setting
    the `eureka.client.registerWithEureka` property to `false`. The route''s definition
    in the `application.yml` file is really simple. Each route''s name is mapped to
    the application service name in Eureka:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: Customizing route configuration
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: There are several configuration settings, which allow us to customize the behavior
    of the Zuul proxy. Some of them are strictly related to the service discovery
    integration.
  prefs: []
  type: TYPE_NORMAL
- en: Ignoring registered services
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Spring Cloud Zuul by default exposes all the services registered in Eureka
    server. If you would like to skip the automatic addition of every service, you
    have to set the `zuul.ignored-services` property with a pattern matched to all
    the ignored service names from a discovery server. How does it work in practice?
    Even if you do not provide any configuration with `zuul.routes.*` properties,
    Zuul would fetch the list of services from Eureka and automatically bind them
    to the path with the service name. For example, `account-service` would be available
    under the gateway address `http://localhost:8080/account-service/**`. Now, if
    you set the following configuration in  your `application.yml` file, it would
    ignore `account-service` and respond with an HTTP 404 status:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'You may also ignore all registered services by setting `zuul.ignored-services` to `''*''`. If
    a service matches a pattern that is ignored, but also included in the routes map
    configuration, then it will be included by Zuul. In that case, only `customer-service`
    would be processed:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: Explicity set service name
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The service name from a discovery server may also be set in configuration using
    the `serviceId` property. It gives you fine-grained control over a route, because
    you can specify the path and the `serviceId` independently. Here''s the equivalent
    configuration of the routes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: Route definition with the Ribbon client
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'There is another approach to configuring routes. We may disable Eureka discovery
    in order to rely solely on a list of network addresses provided with the `listOfServers`
    property of the Ribbon client. All incoming requests to the gateway are load balanced
    by default between all instances of the service through a Ribbon client. This
    rule is true even if you enable or disable service discovery, as in the following
    example code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: Adding a prefix to the path
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Sometimes it is necessary to set a different path for services invoked via a
    gateway rather than allow them being available directly. In that case, Zuul provides
    the ability to add prefixes to all the defined mappings. This may be easily configured
    with the `zuul.prefix` property. By default, Zuul cuts that prefix before forwarding
    requests to the services. However, that behavior can also be disabled by setting
    the `zuul.stripPrefix` property to `false`. A `stripPrefix` property may be configured
    not only globally for all defined routes, but also per single route.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here''s an example that adds the `/api` prefix to all the forwarded requests.
    Now, for example, if you would like to call the `GET /{id}` endpoint from `account-service`*,*
    you should use the address `http://localhost:8080/api/account/1`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'What would happen if we have provided the configuration with `stripPrefix`
    set to `false`? Zuul would try to look for endpoints in the target services under
    the context paths `/api/account` and `/api/customer`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: Connection settings and timeouts
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The main task of Spring Cloud Netflix Zuul is to route incoming requests to
    downstream services. Therefore, it has to use an HTTP client implementation to
    communicate with those services. The default HTTP client used by Zuul is now backed
    by the Apache HTTP Client instead of the deprecated Ribbon `RestClient`. If you
    would like to use Ribbon, you should set the `ribbon.restclient.enabled` property to
    `true`. You may also try `OkHttpClient` by setting the `ribbon.okhttp.enabled` property to
    `true`.
  prefs: []
  type: TYPE_NORMAL
- en: We may configure the basic settings for HTTP clients such as the connect or
    read timeout, and the maximum number of connections. There are two available options
    for such configurations depending on whether we are using service discovery or
    not. If you have defined Zuul routes with a specified network address through
    the `url` property, then you should set `zuul.host.connect-timeout-millis` and
    `zuul.host.socket-timeout-millis`. For the purpose of controlling the maximum
    number of connections, you should override the default value of the `zuul.host.maxTotalConnections`
    property, which is by default set to `200`. It is also possible to define the maximum
    number of connections per single route by setting the `zuul.host.maxPerRouteConnections`
    property, which is by default `20`.
  prefs: []
  type: TYPE_NORMAL
- en: If Zuul is configured to fetch a list of services from the discovery server,
    you need to configure the same timeouts as before with the Ribbon client properties `ribbon.ReadTimeout`
    and `ribbon.SocketTimeout`. The maximum number of connections can be customized
    with `ribbon.MaxTotalConnections` and `ribbon.MaxConnectionsPerHost`.
  prefs: []
  type: TYPE_NORMAL
- en: Secure headers
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'You may be a little surprised if you set, for example, the `Authorization`
    HTTP header in the request and it isn''t forwarded to the downstream service.
    This is because Zuul defines a default list of sensitive headers, which are removed
    during the routing process. These are the headers `Cookie`, `Set-Cookie`, and
    `Authorization`. This feature has been designed with a view to communicate with external
    servers. While there is no objection to sharing headers between services in the
    same system, it is not recommended to share them with external servers for security
    reasons. This approach may be customized by overriding default values for the `sensitiveHeaders`
    property. It may be set globally for all routes or just for a single route. The
    `sensitiveHeaders` are a not an empty blacklist, so to make Zuul forward all headers,
    you should explicitly set it to the empty list:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: Management endpoints
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Spring Cloud Netflix Zuul exposes two additional management endpoints for monitoring:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Routes**: Prints a list of defined routes'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Filters**: Prints a list of implemented filters (available from version `1.4.0.RELEASE`
    of Spring Cloud Netflix)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'To enable the managements endpoints feature, we have to include (as always) `spring-boot-starter-actuator`
    in the project dependencies. It''s a good idea to disable endpoint security for
    test purposes by setting the `management.security.enabled` property to `false`.
    Now, you may just call the `GET /routes` method and it would print the following
    JSON response for our example system:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'For more detailed information, you have to add the `?format=details` query
    string to the `/routes` path. That option is also available from version 1.4.0
    of Spring Cloud (Edgware Release Train). There is also a `POST /route` method
    that would force a refresh of the currently existing routes. Additionally, you
    can disable the whole endpoint by setting `endpoints.routes.enabled` to `false`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'The response result of the `/filters` endpoint is pretty interesting. You may
    see how many and what types of filters are available by default on the Zuul gateway.
    Here''s the fragment of a response with one selected filter. It contains a full
    class name, the order of calling, and status. For more information about filters,
    you can refer to the section, *Zuul filters*:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: Providing Hystrix fallback
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We may provide a fallback response for every single route defined in Zuul's
    configuration, in case a circuit is opened. To do that, we should create a bean
    of type `ZuulFallbackProvider` (which is currently deprecated) or `FallbackProvider`.
    Inside that implementation, we have to specify the route ID pattern to match all
    the routes that should be handled by the fallback bean. The second step is to
    return the implementation of the `ClientHttpResponse` interface as a response
    in the `fallbackResponse` method.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here''s a simple fallback bean that maps every exception to the HTTP status
    `200 OK` and sets the `errorCode` and `errorMessage` in the JSON response. Fallback
    is only executed for the `account-service` route:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: Zuul filters
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As I have already mentioned, Spring Cloud Zuul by default provides a couple
    of beans, which are the implementations of the `ZuulFilter` interface. Every built-in
    filter may be disabled by setting the `zuul.<SimpleClassName>.<filterType>.disable` property to
    `true`. For example, to disable `org.springframework.cloud.netflix.zuul.filters.post.SendResponseFilter`,
    you have to set `zuul.SendResponseFilter.post.disable=true`.
  prefs: []
  type: TYPE_NORMAL
- en: 'The HTTP filtering mechanism is probably well known to you. A filter dynamically
    intercepts requests and responses to transform, or just use, the information taken
    from the HTTP message. It may be triggered before or after an incoming request
    or outgoing response. We may identify a couple of types of filter provided by
    Zuul for Spring Cloud:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Pre filter**: It is used to prepare initial data in the `RequestContext`
    for use in filters downstream. The main responsibility is to set information required
    for route filters.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Route filter**: It is called after the pre filter and is responsible for
    creating requests to other services. The main reason for using it is a need to
    adapt a request or response to the model required by the client.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Post filter**: Most commonly, it manipulates the response. It may even transform
    the response body.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Error filter**: It is executed only if an exception is thrown by other filters.
    There is only one built-in implementation of an error filter. `SendErrorFilter`
    is executed if `RequestContext.getThrowable()` is not null.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Predefined filters
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'If you annotate the main class with `@EnableZuulProxy`, Spring Cloud Zuul loads
    the filter beans used by both `SimpleRouteLocator` and `DiscoveryClientRouteLocator`.
    This is a list of the most important implementations installed as normal Spring
    Beans:'
  prefs: []
  type: TYPE_NORMAL
- en: '`ServletDetectionFilter`: This is a pre filter. It checks whether the request
    is coming through the Spring Dispatcher. Sets a Boolean with the key `FilterConstants.IS_DISPATCHER_SERVLET_REQUEST_KEY`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`FormBodyWrapperFilter`: This is a pre filter. It parses form data and re-encodes
    it for downstream requests.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`PreDecorationFilter`: This is a pre filter. It determines where and how to
    route based on the supplied `RouteLocator`. It is also responsible for setting
    headers related to the proxy.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`SendForwardFilter`: This is a route filter. It forwards requests using `RequestDispatcher`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`RibbonRoutingFilter`: This is a route filter. It uses Ribbon, Hystrix, and
    external HTTP clients such as Apache `HttpClient`, `OkHttpClient`, or Ribbon HTTP
    client to send requests. Service IDs are taken from the request context.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`SimpleHostRoutingFilter`: This is a route filter. It sends requests to URLs
    via an Apache HTTP client. URLs are found in the request context.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`SendResponseFilter`: This is a post filter. It writes responses from proxied
    requests to the current response.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Custom implementations
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In addition to the filters installed by default, we may create our custom implementations. 
    Each of them has to implement the `ZuulFilter` interface and its four methods.
    These methods are responsible for setting the type of filter (`filterType`), determining
    the order of filter execution between other filtering with the same type (`filterOrder`),
    enabling or disabling the filter (`shouldFilter`) and finally the filter logic
    implementation (`run`). Here''s an example implementation that adds the `X-Response-ID` header to
    the response:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'That''s not all that has to be done. The custom filter implementation should
    also be declared as an `@Bean` in the main class or Spring configuration class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: Using Spring Cloud Gateway
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'There are three basic concepts around Spring Cloud Gateway:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Route**: That is the basic building block of the gateway. It consists of
    a unique ID for identifying a route, a destination URI, a list of predicates,
    and a list of filters. A route is matched only if all the predicates have been
    fulfilled.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Predicates**: These are the logic that is executed before processing each
    request. It is responsible for detecting whether the different attributes of the
    HTTP request, such as headers and parameters, match the defined criteria. The
    implementation is based on the Java 8 interface `java.util.function.Predicate<T>`.
    The input type is in turn based on Spring''s `org.springframework.web.server.ServerWebExchange`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Filters**: They allow the modification of the incoming HTTP request or outgoing
    HTTP response. They may be modified before or after sending the downstream request.
    Route filters are scoped to a particular route. They implement Spring''s `org.springframework.web.server.GatewayFilter`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Enable Spring Cloud Gateway for a project
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Spring Cloud Gateway is built on top of the Netty web container and Reactor
    framework. The Reactor project and Spring Web Flux may be used together with version 2.0
    of Spring Boot. Until now, we have used version 1.5, so there is a different declaration
    of parent project version. Currently, Spring Boot 2.0 is still at the milestone
    stage. Here's the fragment from Maven `pom.xml` that inherits from the `spring-boot-starter-parent`
    project.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'We also need to change the release train of Spring Cloud in comparison with
    the previous examples. The newest available milestone version is `Finchley.M5`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'After setting the right versions of Spring Boot and Spring Cloud, we may finally
    include the `spring-cloud-starter-gateway` starter in the project dependencies:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: Built-in predicates and filters
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Spring Cloud Gateway includes many built-in route predicates and gateway filter
    factories. Every route may be defined using configuration properties in the `application.yml`
    file or programmatically with the Fluent Java Routes API. The list of available
    predicate factories is provided in the following table. Multiple factories may
    be combined for a single route definition with a logical `and` relation. The collection
    of filters may be configured in the `application.yml` file under the `spring.cloud.gateway.routes` property for
    each defined route under the `predicates` property:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Name** | **Description** | **Example** |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `After` Route | It takes a date-time parameter and matches requests that
    happen after it | `After=2017-11-20T...` |'
  prefs: []
  type: TYPE_TB
- en: '| `Before` Route | It takes a date-time parameter and matches requests that
    happen before it | `Before=2017-11-20T...` |'
  prefs: []
  type: TYPE_TB
- en: '| `Between` Route | It takes two date-time parameters and matches requests
    that happen between those dates | `Between=2017-11-20T..., 2017-11-21T...` |'
  prefs: []
  type: TYPE_TB
- en: '| `Cookie` Route | It takes a cookie name and regular expression parameters,
    finds the cookie in the HTTP request''s header, and matches its value with the
    provided expression  | `Cookie=SessionID, abc.` |'
  prefs: []
  type: TYPE_TB
- en: '| `Header` Route | It takes the header name and regular expression parameters,
    finds a specific header in the HTTP request''s header, and matches its value with
    the provided expression  | `Header=X-Request-Id, \d+` |'
  prefs: []
  type: TYPE_TB
- en: '| `Host` Route | It takes a hostname ANT style pattern with the `.` separator
    as a parameter and matches it with the `Host` header | `Host=**.example.org` |'
  prefs: []
  type: TYPE_TB
- en: '| `Method` Route | It takes an HTTP method to match as a parameter | `Method=GET`
    |'
  prefs: []
  type: TYPE_TB
- en: '| `Path` Route | It takes a pattern of request context path as a parameter
    | `Path=/account/{id}` |'
  prefs: []
  type: TYPE_TB
- en: '| `Query` Route | It takes two parameters—a required param and an optional
    regexp and matches them with query parameters | `Query=accountId, 1.` |'
  prefs: []
  type: TYPE_TB
- en: '| `RemoteAddr` Route | It takes a list of IP addresses in CIDR notation, like `192.168.0.1/16`,
    and matches it with the remote address of a request  | `RemoteAddr=192.168.0.1/16`
    |'
  prefs: []
  type: TYPE_TB
- en: 'There are a few more built-in implementations of the gateway filter pattern.
    The list of available factories is also provided in the following table. The collection
    of filters may be configured in the `application.yml` file under the `spring.cloud.gateway.routes`
    property for each route defined under the `filters` property:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Name** | **Description** | **Example** |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `AddRequestHeader` | Adds a header to an HTTP request with name and value
    provided in parameters | `AddRequestHeader=X-Response-ID, 123` |'
  prefs: []
  type: TYPE_TB
- en: '| `AddRequestParameter` | Adds a query parameter to an HTTP request with name
    and value provided in parameters | `AddRequestParameter=id, 123` |'
  prefs: []
  type: TYPE_TB
- en: '| `AddResponseHeader` | Adds a header to an HTTP response with name and value
    provided in parameters | `AddResponseHeader=X-Response-ID, 123` |'
  prefs: []
  type: TYPE_TB
- en: '| `Hystrix` |  It takes a parameter, which is the name of the HystrixCommand
    | `Hystrix=account-service` |'
  prefs: []
  type: TYPE_TB
- en: '| `PrefixPath` | Adds a prefix to the HTTP request path defined in the parameter
    | `PrefixPath=/api` |'
  prefs: []
  type: TYPE_TB
- en: '| `RequestRateLimiter` | It limits the number of processing requests per single
    user based on three input parameters including a maximum number of requests per
    second, burst capacity, and a bean that returns the user key | `RequestRateLimiter=10,
    20, #{@userKeyResolver}` |'
  prefs: []
  type: TYPE_TB
- en: '| `RedirectTo` | It takes an HTTP status and a redirect URL as parameters and
    puts it to the `Location` HTTP header in order to perform a redirect | `RedirectTo=302,
    http://localhost:8092` |'
  prefs: []
  type: TYPE_TB
- en: '| `RemoveNonProxyHeaders` | It removes some hop-by-hop headers from forwarded
    requests, such as Keep-Alive, Proxy-Authenticate, or Proxy-Authorization | - |'
  prefs: []
  type: TYPE_TB
- en: '| `RemoveRequestHeader` | It takes the name of the header as a parameter and
    removes it from the HTTP request | `RemoveRequestHeader=X-Request-Foo` |'
  prefs: []
  type: TYPE_TB
- en: '| `RemoveResponseHeader` | It takes the name of the header as a parameter and
    removes it from the HTTP response | `RemoveResponseHeader=X-Response-ID` |'
  prefs: []
  type: TYPE_TB
- en: '| `RewritePath` | It takes a path regexp parameter and a replacement parameter
    and then rewrites the request path | `RewritePath=/account/(?<path>.*), /$\{path}`
    |'
  prefs: []
  type: TYPE_TB
- en: '| `SecureHeaders` | It adds some secure headers to the response | - |'
  prefs: []
  type: TYPE_TB
- en: '| `SetPath` | It takes a single parameter with a path template parameter and
    changes a request path | `SetPath=/{segment}` |'
  prefs: []
  type: TYPE_TB
- en: '| `SetResponseHeader` | It takes name and value parameters to set a header
    on the HTTP response | `SetResponseHeader=X-Response-ID, 123` |'
  prefs: []
  type: TYPE_TB
- en: '| `SetStatus` | It takes a single status parameter, which must be a valid HTTP
    status, and sets it on a response | `SetStatus=401` |'
  prefs: []
  type: TYPE_TB
- en: 'Here''s a simple example with two predicates and two filters set. Each `GET
    /account/{id}` request coming in to the gateway is forwarded to `http://localhost:8080/api/account/{id}`
    with the new HTTP header, `X-Request-ID`, included:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'The same configuration may be provided using a fluent API defined in the `Route`
    class. This style gives us more flexibility. While configuration with YAML may
    combine predicates using logical `and`, the fluent Java API allows you to use
    `and()`, `or()`, and `negate()` operators on the `Predicate` class. Here''s the
    alternative route implemented using the fluent API:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: Gateway for microservices
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s get back to our example microservice-based system. We have already discussed
    this example in the section on API gateway configuration based on Spring Cloud
    Netflix Zuul. We would like to prepare the same static route definition as was
    already prepared for the application based on a Zuul proxy. Each service would
    then be available under the gateway address and specific path, for example, `http://localhost:8080/account/**`.
    The most suitable way to declare such a configuration with Spring Cloud Gateway is
    through Path Route Predicate Factory and RewritePath GatewayFilter Factory. A
    rewrite path mechanism changes the request path by taking part of it or adding
    some pattern. In our case, every incoming request path is rewritten from, for
    example, `account/123` to `/123`. Here''s the gateway''s `application.yml` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'Surprisingly, this is all that has to be done. We don''t have to provide any
    additional annotation compared to what we have been doing when working with other
    Spring Cloud components such as Eureka or Config Server. So, the main class of
    our gateway''s application is visible in the following code fragment. You have
    to build the project using `mvn clean install` and launch it with `java -jar`,
    or just run the main class from your IDE. The example application source code
    is available on GitHub ([https://github.com/piomin/sample-spring-cloud-gateway.git](https://github.com/piomin/sample-spring-cloud-gateway.git)):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: Integration with service discovery
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The gateway may be configured to create routes based on the list of services
    registered in service discovery. It can integrate with those solutions that have
    a `DiscoveryClient` compatible service registry, such as Netflix Eureka, Consul,
    or Zookeeper. To enable `DiscoveryClient` Route Definition Locator, you should
    set the `spring.cloud.gateway.discovery.locator.enabled` property to `true` and
    provide a `DiscoveryClient` implementation on the classpath. We use Eureka client
    and server for discovery. Notice that with the newest milestone version, `Finchley.M5`, of
    Spring Cloud all the Netflix''s artifact''s names have been changed and now it
    is, for example, `spring-cloud-starter-netflix-eureka-client` instead of `spring-cloud-starter-eureka`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'The main class should be the same for the Eureka client application, annotated
    with `@DiscoveryClient`. Here''s the `application.yml` file with routing configuration.
    The only change in comparison with the previous example is in the `uri` property
    for every defined route. Instead of providing their network address we may use
    its name taken from discovery server with an `lb` prefix, for example, `lb://order-service`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: With an API gateway, we have finished the discussion about the implementation
    of the core elements of a microservice-based architecture in Spring Cloud. After
    reading that part of the book, you should be able to customize and use tools such
    as Eureka, Spring Cloud Config, Ribbon, Feign, Hystrix, and finally a gateway
    based on Zuul and Spring Cloud Gateway together.
  prefs: []
  type: TYPE_NORMAL
- en: Treat this chapter as a comparison between two available solutions—the older
    Netflix Zuul and the newest one, Spring Cloud Gateway. The second of them is changing
    dynamically. Its current version, 2.0, may be used only with Spring 5 and is still
    not available in release version. The first of them, Netflix Zuul, is stable,
    but it does not support asynchronous, non-blocking connections. It is still based
    on Netflix Zuul 1.0, although there is a new version of Zuul that supports asynchronous
    communication. Regardless of the differences between them, I have described how
    to provide a simple and a more advanced configuration using both of these solutions.
    I have also presented, based on the examples from the previous chapters, an integration
    with a service discovery, client-side load balancer, and circuit breaker.
  prefs: []
  type: TYPE_NORMAL
