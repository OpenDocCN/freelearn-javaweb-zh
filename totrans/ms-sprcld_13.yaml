- en: Testing Java Microservices
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: While developing a new application, we should never forget about automated tests.
    These are especially important if we are thinking about microservices-based architecture.
    Testing microservices requires a different approach than the tests created for
    monolithic applications. As far as monoliths are concerned, the main focus is
    on unit testing and  integration tests, together with the database layer. In the
    case of microservices, the most important thing is to provide coverage for each
    of the communications at the finest possible granularity. Although each microservice
    is independently developed and released, a change in one of them can affect all
    of the others that are interacting with that service. The communication between
    them is realized through messages. Usually, these are messages that are sent via
    REST or AMQP protocols.
  prefs: []
  type: TYPE_NORMAL
- en: 'Topics we will cover in this chapter include the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Spring support for automated testing
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Differences between a component and integration testing for Spring Boot microservices
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Implementing contract tests using Pact
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Implementing contract tests using Spring Cloud Contract
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Implementing performance tests using Gatling
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Testing strategies
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'There are five different microservices testing strategies. The first three
    of them are the same as for monolithic applications:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Unit tests**: With unit tests, we test the smallest pieces of code, for example,
    a single method or component, and mock every call of other methods and components.
    There are many popular frameworks that support unit tests in Java, such as JUnit,
    TestNG, and Mockito (for mocking). The main task of this type of testing is to
    confirm that the implementation meets requirements. Unit testing can be a powerful
    tool, especially when combined with test-driven development.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Integration tests**: Using only unit testing doesn''t guarantee that you
    will verify the behavior of the whole system. Integration tests take the modules
    and try to test them together. This approach gives you an opportunity to exercise
    communication paths within the subsystem. We are testing the interaction and communication
    between components based on their interfaces with external services mocked-up.
    In a microservices-based system, integration tests can be used in order to include
    other microservices, data sources, or caches.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**End-to-end tests**: End-to-end tests are also known as **functional tests**.
    The main goal of these tests is to verify whether the system meets the external
    requirements. It means that we should design test scenarios that test all the
    microservices taking part in that process. The design of a good end-to-end test
    is not a trivial task. Since we need to test the whole system, it is very important
    to place a particular emphasis on the test''s scenario design.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Contract tests**: Contract tests are used to ensure that the explicit and
    implicit contract of a microservice work as expected. A contract is always formed
    when a consumer integrates with the interface of a component in order to use it.
    Usually, in microservice-based systems, there are many consumers of a single component.
    Each of them usually requires a different contract that meets its demands. Following
    these assumptions, every consumer is responsible for a source component''s interface
    behavior.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Component tests**: After we have completed unit testing of all the objects
    and methods within a microservice, we should test the whole microservice in isolation.
    In order to run the tests in isolation, we need to mock or stub the calls of the
    other microservices. An external data store should be replaced with an equivalent
    in-memory data store, which also provides significant test performance improvements.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The differences between contract and component tests are obvious. The following
    diagram illustrates those differences in our sample `order-service` microservice:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/ce6b981a-9c68-4f29-926f-f51f4ca22502.png)'
  prefs: []
  type: TYPE_IMG
- en: Now, there is a question of whether we really need two additional strategies
    for testing a microservices-based system. Through the proper unit and integration
    tests, we may be confident in the correctness of the implementation of the individual
    components that form part of the microservice. However, without more specific
    test strategies for microservices, we cannot be sure how they work together in
    order to meet our business requirements. Therefore, component and contract tests
    have been added. This is a really important change in order to help us understand
    the differences between component, contract, and integration tests. Since component
    tests are performed in isolation from the outside world, integration tests are
    responsible for verifying interactions with that world. That's why we should provide
    stubs for an integration test in contrast with a components test. Contract tests,
    much like integration tests, emphasize interactions between microservices, but
    they treat them as a black box and verify only the format of the responses.
  prefs: []
  type: TYPE_NORMAL
- en: 'Once you provide functional tests for your microservices, you should also think
    about performance testing. We can distinguish the following strategies of performance
    testing:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Load tests**: These are used to determine a system''s behavior under the
    normal and anticipated load conditions. The main idea here is to identify some
    weaknesses, such as response time latencies, aberrant outages, or too many retries
    if network timeouts are not set properly.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Stress tests**: These check the upper limits of your system to examine how
    it behaves under an extremely heavy load. In addition to load testing, it also
    checks out memory leaks, security issues, and data corruption. It may be using
    the same tools as for load testing.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The following diagram illustrates the logical order of performing all of the
    test strategies on your system. We are starting from the simplest unit testing,
    which verifies small pieces of software, and going through the next stages to
    finally finish with stress testing that pushes the whole system to the limit:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/79c6864e-6185-4be3-8573-fe3fdcd8330e.png)'
  prefs: []
  type: TYPE_IMG
- en: Testing Spring Boot applications
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'As you might have read in the previous section, there are some different strategies
    and approaches to the tests in your application. I have briefly mentioned all
    of them, so now we may proceed to the practical aspects. Spring Boot provides
    a set of utilities that help in the implementation of automated tests. In order
    to enable these features in the project, you have to include the `spring-boot-starter-test`
    starter to the dependencies. It imports not only the `spring-test` and `spring-boot-test`
    artifacts, but also some other useful test libraries, such as JUnit, Mockito,
    and AssertJ:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: Building the sample application
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Before we start to work on automated tests, we need to prepare a sample business
    logic for testing purposes. We may use the same example system from the previous
    chapters, but it has to be modified a little. Until now, we have never used an
    external data source for storing and collecting test data. In this chapter, it
    would be helpful to do this in order to illustrate how the different strategies
    approach the issue of persistence testing. Now, each service has its own database
    although, generally, it doesn''t really matter which database is chosen. There
    is a large choice of solutions supported by Spring Boot, including both relational
    and NoSQL databases. I have decided to use Mongo. Let us remind ourselves of the
    architecture of the sample system. The current model shown in the following diagram
    takes into account the assumptions described previously regarding dedicated databases
    per service:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/2b538768-b0e9-4e90-bc9e-df506778371a.png)'
  prefs: []
  type: TYPE_IMG
- en: Integration with the database
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In order to enable Mongo support for our Spring Boot application, include the
    `spring-boot-starter-data-mongo` starter to the dependencies. This project provides
    some interesting features to simplify integration with MongoDB. Among these features,
    it is worth mentioning particular rich object mapping, `MongoTemplate`, and of
    course support for the repository writing style, well-known from other Spring
    Data projects. Here''s the required dependency declaration in `pom.xml`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'The instance of MongoDB may be easily started using its Docker image. Run the
    following command to launch the Docker container that exposes the Mongo database
    on port `27017`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'In order to connect the application with a previously started data source,
    we should override some `auto-configured` settings in `application.yml`. This
    can be achieved with the `spring.data.mongodb.*` properties:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'I have already mentioned the object mapping feature. Spring Data Mongo provides
    some annotations that may be used for this. Every object stored in the database
    should be annotated with `@Document`. The primary key of the target collection
    is a 12 byte string, which should be indicated in every mapped class with Spring
    Data `@Id`. Here''s the fragment of `Account` object implementation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: Unit tests
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: I have taken a lot of time to describe integration with MongoDB. However, testing
    persistence is one of the key points of automated tests, so it is very important
    to configure it properly. Now, we may proceed to the test's implementation. Spring
    Test provides support for the most typical testing scenarios, such as integration
    with other services through a REST client or integration with databases. We have
    a set of libraries available that allows us to easily mock interactions with external
    services, which is especially important for unit tests.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following test class is a typical unit test implementation for a Spring
    Boot application. We have used the JUnit framework, which is the de facto standard
    for Java. The Mockito library is used here for replacing the real repository and
    controller with their stubs. Such an approach allows us to easily verify the correctness
    of every method implemented by the `@Controller` class. The test is performed
    in isolation from the external components, which is the main assumption of unit
    testing:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'The good news, especially within the context of microservices, is that we may
    easily mock Feign client communication. The following example test class verifies
    the endpoint from `order-service` used for withdrawing money by calling the endpoint
    exposed by `account-service`. As you have probably noticed, that endpoint has
    in turn been tested by the previously introduced test class. Here''s the class
    with unit test implementation for `order-service`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: Component tests
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: If you have provided the unit tests for all the key classes and interfaces in
    the application, you may proceed to the component tests. The main idea of component
    tests is to instantiate the full microservice in memory using in-memory test doubles
    and data stores. This allows us to skip the network connections. While for unit
    tests we were mocking all the database or HTTP clients, here we do not mock anything.
    We provide an in-memory data source for the database client and we simulate HTTP
    responses for the REST client.
  prefs: []
  type: TYPE_NORMAL
- en: Running tests with an in-memory database
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'One of the reasons I chose MongoDB is that it can be easily embedded with a
    Spring Boot application for testing purposes. To enable an embedded MongoDB for
    your project, include the following dependency in Maven `pom.xml`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'Spring Boot provides auto-configuration for an embedded MongoDB, so we don''t
    need to do anything else other than setting the local address and port in `application.yml`.
    Because, by default, we use Mongo running on Docker container, we should declare
    such a configuration in an additional Spring profile. This specific profile is
    activated during test case execution by annotating the test class with `@ActiveProfiles`.
    Here''s a fragment of `application.yml`, where we defined two profiles, `dev`
    and `test`, with different MongoDB connection settings:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: If you use databases other than MongoDB, for example, MySQL or Postgres, you
    may easily replace them with alternative, in-memory, embedded, relational databases,
    such as H2 or Derby. Spring Boot supports them and provides auto-configuration
    for the tests that may be activated with `@DataJpaTest`. Instead of using `@SpringBootTest`,
    you can also use the `@DataMongoTest` annotation for embedded MongoDB. As well
    as an in-memory, embedded MongoDB, this will configure a `MongoTemplate`, scan
    for `@Document` classes, and configure Spring Data MongoDB repositories.
  prefs: []
  type: TYPE_NORMAL
- en: Handling HTTP clients and service discovery
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The issue regarding testing persistence with an in-memory database is resolved.
    However, we still need to consider some other aspects of the test, such as simulating
    HTTP responses from other services or integration with a service discovery. When
    you implement some tests for microservices, you may choose between two typical
    approaches to a service discovery. The first of these is to embed the discovery
    server to the application during the test case execution, and the second is just
    to disable discovery on the client side. The second option is relatively easy
    to configure with Spring Cloud. For the Eureka Server, it can be disabled using
    the `eureka.client.enabled=false` property.
  prefs: []
  type: TYPE_NORMAL
- en: 'This is only the first part of the exercise. We should also disable discovery
    for the Ribbon client, which is responsible for load balancing in an interservice
    communication. If there is more than one target service, we have to label every
    client with the service name. The value of the last property in the following
    configuration, `listOfServers`, is strictly related to the framework used for
    automated test implementation. I''m going to show you the sample based on the
    Hoverfly Java library, which has already been introduced in [Chapter 7](2ddad83c-3c9c-414d-a4f3-2d3856c0c5ed.xhtml),
    *Advanced Load Balancing and Circuit Breakers*. It was used then for simulating
    delays in calling target services in order to present how the Ribbon client and
    Hystrix deal with network timeouts. Here, we will just use it to return prepared
    responses to make our component tests to touch the network communications. Here''s
    a fragment of the configuration file with the profile responsible for disabling
    Eureka''s discovery and setting the test properties of the Ribbon client. That
    profile should also be activated for the test class by annotating it with `@ActiveProfiles`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'I wouldn''t like to go into the details of Hoverfly usage because it has already
    been discussed in [Chapter 7](2ddad83c-3c9c-414d-a4f3-2d3856c0c5ed.xhtml), *Advanced
    Load Balancing and Circuit Breakers*. As you probably remember, Hoverfly can be
    activated for the JUnit test by declaring `@ClassRule` with `HoverflyRule`, defining
    the list of services and endpoints that should be simulated. The name of each
    service has to be the same as its address defined with the `listOfServers` property.
    Here''s a definition of the Hoverfly test rule that simulates responses from three
    different services:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: Implementing sample tests
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To conclude everything that has been said in the last two sections, we will
    now prepare component tests using an in-memory, embedded MongoDB, Hoverfly (to
    simulate HTTP responses), and disabled service discovery. The correct configuration
    settings prepared especially for our testing purposes are available under profiles
    `test` and `no-discovery`. Every component test is initialized by the `TestRestTemplate`,
    which calls `order-service` HTTP endpoints. The test result verification may be
    performed based on the HTTP response or data stored in the embedded MongoDB. Here''s
    a sample implementation of component tests for `order-service`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: Integration tests
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: After creating unit and component tests, we have verified all the functionalities
    inside the microservices. However, we still need to test the interaction with
    other services, external data stores, and caches. In microservices-based architecture
    integration, tests are treated differently than they are in monolithic applications.
    Because all the relationships between internal modules have been tested through
    the component tests, we have tested only those modules that interact with external
    components.
  prefs: []
  type: TYPE_NORMAL
- en: Categorizing tests
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'It also makes sense to separate integration tests in the CI pipeline so that
    external outages don''t block or break the build of the project. You should consider
    categorizing your tests by annotating them with `@Category`. You may create the
    interface especially for integration tests, for example, `IntegrationTest`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, you can mark your test with that interface using the `@Category` annotation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, you can configure Maven to run only the selected type of tests, for
    example, with `maven-failsafe-plugin`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: Capturing HTTP traffic
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Categorization is one of the ways of dealing with problems in communication
    with external microservices during automated tests. Another popular approach to
    that issue involves recording outgoing requests and incoming responses in order
    to use them in the future without establishing a connection to the external services.
  prefs: []
  type: TYPE_NORMAL
- en: In the previous examples, we have only used Hoverfly in simulation mode. However,
    it can also be run in capture mode, which means that requests will be made to
    the real service as normal, but they will be intercepted, recorded, and stored
    in the file by Hoverfly. The file that stores the captured traffic in JSON format
    may then be used in simulation mode. You can create a Hoverfly Rule in your JUnit
    test class, which is started in capture mode if the simulation file does not exist
    and in simulate mode if it does exist. It is always stored inside the `src/test/resources/hoverfly`
    directory.
  prefs: []
  type: TYPE_NORMAL
- en: This is a simple way of breaking dependencies to the external service. For example,
    if you know that there were no changes there, it is not necessary to interact
    with the real service. If such a service were to be modified, you can remove the
    JSON simulation file and thereby switch to capture mode. If your test fails, it
    means that the modification affected your service and you have to perform some
    fixes before moving back to capture mode.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here''s a sample integration test located inside `order-service`. It adds a
    new account and then calls a method for withdrawing money from that account. Thanks
    to using the `inCaptureOrSimulationMode` method, the real service is invoked only
    if the `account.json` file does not exist or you change the input data passed
    to the services in the test:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: Contract tests
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: There are some interesting tools especially dedicated to contract testing. We
    will discuss this concept by looking at two of the most popular tools—Pact and
    Spring Cloud Contract.
  prefs: []
  type: TYPE_NORMAL
- en: Using Pact
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'As we have already mentioned, the main concept around contract tests is to
    define a contract between the consumer and provider, and then verify it independently
    for each service. Since the responsibility for creating and maintaining a contract
    lies mainly on the consumer side, this type of test is usually referred to as
    a consumer-driven test. The division into a consumer and provider side is clearly
    visible in Pact JVM. It provides two separated libraries, the first prefixed by
    `pact-jvm-consumer` and the second prefixed by `pact-jvm-provider`. Of course,
    the contract is created by the consumer in agreement with the provider, which
    has been illustrated in the following diagram:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/f33b5f96-1fa5-40cf-a968-da07cb4ad39e.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Pact is, in fact, a collection of frameworks that provide support for consumer-driven
    contract testing. These implementations are available for different languages
    and frameworks. Fortunately, Pact may be used together with JUnit and Spring Boot.
    Let''s consider one of the integrations implemented in our sample system, namely
    the one between `customer-service` and `account-service`. The microservice named
    `customer-service` uses the Feign client for communication with `account-service`.
    The Feign client definition on the consumer side de facto represents our contract:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: Consumer side
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To enable Pact with JUnit support on the consumer side, include the following
    dependency to your project:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'Now the only thing we have to do is to create the JUnit test class. We may
    implement it as a standard Spring Boot test by annotating it with `@SpringBootTest`
    and running it using Spring Runner. To perform the created test successfully,
    we first need to disable the discovery client and ensure that the Ribbon client
    will communicate with the stub of the `account-service` represented by `@Rule`
    `PactProviderRuleMk2`. The key point of the test is the `callAccountClient` method,
    which is annotated with `@Pact` and returns a `RequestResponsePact`. It defines
    the format of the request and the content of the response. During the test case
    execution, Pact automatically generates the JSON representation of that definition,
    which is available in the `target/pacts/addressClient-customerServiceProvider.json`
    file. Finally, the method implemented in the Feign client is invoked and the response
    returned by Pact `@Rule` is verified in the test method annotated with `@PactVerification`.
    Here''s a sample implementation of a consumer-side contract test for `customer-service`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'The JSON test result file generated in the `target/pacts` directory has to
    be available on the provider side. The simplest possible solution assumes that
    it can just access the generated file using the `@PactFolder` annotation. Of course,
    it requires the provider to have access to the `target/pacts` directory. Although
    it would work for our sample since its source code is stored in the same Git repository,
    it is not our target solution. Fortunately, we may publish the Pact test result
    in the network using Pact Broker. Pact Broker is a repository server that provides
    an HTTP API for publication and consumption of Pact files. We may start Pact Broker
    locally using its Docker image. It requires a Postgres database as a backend store,
    so we also start the container with Postgres. Here are the required Docker commands:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'After running Pact Broker on Docker, we have to publish our test report there.
    We may easily perform this using the Maven plugin `pact-jvm-provider-maven_2.12`.
    If you run the `mvn clean install pack:publish` command, all the files placed
    in the `/target/pacts` directory will be sent to the broker''s HTTP API:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'The full list of published Pacts can be displayed using the web console available
    at `http://192.168.99.100:9080`. It also provides the information about the last
    verification date and the details of every Pact in the list, as shown in the following
    screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/55c94e0d-75da-45aa-a98f-2d8af546530e.png)'
  prefs: []
  type: TYPE_IMG
- en: Producer side
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Assuming the consumer has created a Pact and published it on the broker, we
    may proceed to implement a verification test on the provider side. To enable Pact
    with JUnit support on the provider side, include the `pact-jvm-provider-junit`
    dependency to your project. There is also another framework available, `pact-jvm-provider-spring`.
    This library allows you to run contract tests against a provider using Spring
    and JUnit. The list of required dependencies is visible on the following fragment
    of Maven `pom.xml`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'Thanks to the dedicated library for Spring, we may use `SpringRestPactRunner`
    instead of the default `PactRunner`. This, in turn, allows you to use the Spring
    test annotations, such as `@MockBean`. In the following JUnit test, we mock the
    `AccountRepository` bean. It returns three objects expected by the test on the
    consumer side. The test automatically starts the Spring Boot application and calls
    the `/customer/{customerId}` endpoint. There are also two other important things.
    By using the `@Provider` and `@State` annotations, we need to set the same names
    as were set for the test on the consumer side inside the `@Pact` annotation. Finally,
    by declaring `@PactBroker` on the test class, we provide the connection settings
    to the Pact''s repository. Here''s sample test using Pact, that verifies contract
    published by `customer-service`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: Using Spring Cloud Contract
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Spring Cloud Contract presents a slightly different approach to contract testing
    than Pack. While in Pack the consumer is responsible for publishing the contract,
    in Spring Cloud Contract the initiator of this action is the provider. The contracts
    are stored in a Maven repository as JARs, containing the stubs automatically generated
    based on the contract definition file. These definitions may be created using
    the Groovy DSL syntax. Each of them consists of two main parts: the request and
    the response specification. On the basis of these files, Spring Cloud Contract
    generates JSON stub definitions, which are used by WireMock for integration testing
    on the client side. In contrast to Pact, which is used as the tool supporting
    consumer-driven contracts testing for REST APIs, it has been designed especially
    for testing JVM-based microservices. It consists of three subprojects:'
  prefs: []
  type: TYPE_NORMAL
- en: Spring Cloud Contract Verifier
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Spring Cloud Contract Stub Runner
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Spring Cloud Contract WireMock
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Let's analyze how they should be used in our contract tests based on the same
    example that was previously described in the section about the Pact framework.
  prefs: []
  type: TYPE_NORMAL
- en: WireMock is a simulator for HTTP-based APIs. Some might consider it a service
    virtualization tool or a mock server. It is able to get up and running quickly
    by capturing traffic to and from an existing API.
  prefs: []
  type: TYPE_NORMAL
- en: Defining contracts and generating stubs
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'As I have already mentioned in contrast to Pact, in Spring Cloud Contract,
    the provider (server side) is responsible for publishing the contract specification.
    Therefore, we will begin the implementation from `account-service`, which serves
    the endpoint invoked by `customer-service`. But before proceeding to the implementation,
    take a look at the following diagram. It illustrates the main components taking
    part in our testing process. The source code of the sample application is available
    in the same GitHub repository as the previous samples, but on a different branch
    contract:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/03bc1e16-89eb-4c5a-bc68-a00382569392.png)'
  prefs: []
  type: TYPE_IMG
- en: 'To enable Spring Cloud Contract functionalities for the provider-side application,
    first you have to include Spring Cloud Contract Verifier to your project dependencies:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'The next step is to add the Spring Cloud Contract Verifier Maven plugin, which
    generates and runs your contract tests. It also produces and installs stubs in
    the local Maven repository. The only parameter you have to define for it is the
    package where the base classes extended by the generated test classes are located:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, we have to create a base class for the contract tests. It should be placed
    within the `pl.piomin.services.account` package. In the following base class,
    we set up a Spring Boot application with `@SpringBootTest` and then mock away
    the `AccountRepository`. We also use `RestAssured` to mock Spring MVC and send
    requests only to our controller. Thanks to all these mocks, the test does not
    interact with any external components, such as a database or an HTTP endpoint,
    and tests only the contract:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: We have provided all the configuration and base classes needed for running tests
    with Spring Cloud Contract. Therefore, we may proceed to the most important part,
    defining the contract using the Spring Cloud Contract Groovy DSL. All the specifications
    of the contracts should be located in the `/src/test/resources/contracts` directory.
    The specific location under this directory, which contains stub definitions, is
    treated as a base test class name. Each stub definition represents a single contract
    test. Based on this rule, `spring-cloud-contract-maven-plugin` automatically finds
    the contract and assigns it to the base test class. In the example we are currently
    discussing, I have placed my stub definition in the `/src/test/resources/contracts/accountService`
    directory. So the generated test class name is `AccountServiceTest`, and it also
    extends the `AccountServiceBase` class.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here''s the sample contract specification that returns a list of accounts belonging
    to the customer. This contract is not very trivial, so some things need to be
    explained. You can use regular expressions to write your requests in Contract
    DSL. You can also provide different values for every property depending on the
    communication side (consumer or producer). Contract DSL also gives you the ability
    to reference a request in your response by using the `fromRequest` method. The
    following contract returns a list of three accounts, taking the `customerId` field
    from the request path and the `id` field, consisting of five digits:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'Test classes are generated under the `target/generated-test-sources` directory
    during the test phase of the Maven build. Here''s the class generated from the
    contract specification described earlier:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: Verifying a contract on the consumer side
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Assuming we have successfully built and run tests on the provider side, the
    stubs will have been generated and then published in our local Maven repository.
    To be able to use them during the consumer application test, we should include
    Spring Cloud Contract Stub Runner to the project dependencies:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: Then we should annotate our test class with `@AutoConfigureStubRunner`. It takes
    two input parameters—`ids` and `workOffline`. The `Ids` field is a concatenation
    of the `artifactId`, `groupId`, version number, `stubs` qualifier, and port number,
    and generally points out to the JAR which stubs are published by the provider.
    The `workOffline` flag indicates where the repository with the stubs is located.
    By default, the consumer tries to download artifacts automatically from Nexus
    or Artifactory. If you would like to force Spring Cloud Contract Stub Runner to
    download stubs only from the local Maven repository, you can switch the value
    of the `workOffline` parameter to `true`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here''s a JUnit test class that uses the Feign client to invoke the endpoint
    from the stub published by the provider side. Spring Cloud Contract looks for
    the newest version of the `pl.piomin.services:account-service` artifact. It has
    been indicated by passing the `+` sign as a version of the stub inside the `@AutoConfigureStubRunner`
    annotation. If you would like to use the concrete version of that artifact, you
    may set the current version from your `pom.xml` file instead of `+`, for example,
    `@AutoConfigureStubRunner(ids = {"pl.piomin.services:account-service:1.0-SNAPSHOT:stubs:8091"})`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: The only thing left is to build the whole project using the `mvn clean install`
    command in order to verify that tests are running successfully. However, we should
    remember that the tests created before cover only integration between `customer-service`
    and `account-service`. In our sample system, there are some other integrations
    between microservices that should be verified. I'll show you one more example,
    which tests the whole system. It tests methods exposed `order-service`, which
    communicates with all the other microservices. For this, we are going to use another
    interesting feature of Spring Cloud Contract scenarios.
  prefs: []
  type: TYPE_NORMAL
- en: Scenarios
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Defining scenarios with Spring Cloud Contract is not difficult. The only thing
    you have to do is to provide the proper naming convention while creating a contract.
    This convention assumes that every contract''s name that is a part of the scenario
    is prefixed by an order number and an underscore. All the contracts included in
    a single scenario have to be located in the same directory. Spring Cloud Contract
    scenarios are based on WireMock''s scenarios. Here''s a directory structure with
    contracts defined for the needs of scenario that creates and accepts an order:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'The following is the test''s source code generated for this scenario:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, let''s imagine that we have a lot of microservices, and most of them communicate
    with one or more other microservices. So, even if you test a single contract,
    you can''t be sure that all other contracts during interservice communication
    work as expected. However, with Spring Cloud Contract, you may easily include
    all required stubs to your test class. That gives you the ability to verify all
    the contracts in the defined scenarios. This is required to include both `spring-cloud-starter-contract-verifier`
    and `spring-cloud-starter-contract-stub-runner` dependencies to the project. The
    following class definition acts as a base for the Spring Cloud Contract test class
    and includes stubs generated by other microservices. The stub generated for `order-service`
    endpoints may be used by any other external service that needs to verify the contract
    with `order-service`. A test such as the following code will verify not only the
    contract between this service and `order-service`, but also the contract between
    `order-service` and other services used by that service:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: Performance testing
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We still have one last type of automated test to discuss. It has already been
    mentioned at the beginning of the chapter. I am, of course, talking about performance
    tests. There are some really interesting tools and frameworks that help you to
    create and run this kind of test. There is a large choice of instruments, especially
    if we are talking about HTTP API tests. I wouldn't like to discuss all of them,
    but I will talk about one framework that might be helpful. It's Gatling. Let's
    take a closer look at it.
  prefs: []
  type: TYPE_NORMAL
- en: Gatling
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Gatling is an open source performance testing tool written in Scala. It allows
    you to develop the tests in an easily readable and writable **domain-specific
    language** (**DSL**). It stands out from the competition by generating comprehensive,
    graphical load reports illustrating all the metrics collected during a test case.
    There are plugins available for integrating Gatling with Gradle, Maven, and Jenkins.
  prefs: []
  type: TYPE_NORMAL
- en: Enabling Gatling
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: To enable the Gatling framework for a project, we should include the `io.gatling.highcharts:gatling-charts-highcharts`
    artifact in the dependencies.
  prefs: []
  type: TYPE_NORMAL
- en: Defining the test scenario
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Every Gatling test suite should extend the `Simulation` class. In every test
    class, we may declare a list of scenarios using the Gatling Scala DSL. We usually
    declare the number of simultaneous threads that can call HTTP endpoints and the
    whole number of requests sent per single thread. In the Gatling nomenclature,
    the number of threads is determined by the number of users set using the `atOnceUsers`
    method. The test class should be placed in the `src/test/scala` directory.
  prefs: []
  type: TYPE_NORMAL
- en: Assuming that we would like to test two endpoints that are exposed by `order-service`
    running 20 clients, where each of them sends 500 requests sequentially, we would
    have 20,000 requests sent in total. By sending them all in a short period of time,
    we would be able to test the performance of our application.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following test scenario is written in Scala. Let''s take a closer look
    at it. Before running this test, I created some accounts and products by calling
    the HTTP API, exposed by `account-service` and `product-service`. Because they
    are connected to an external database, IDs are automatically generated. In order
    to provide some test data, I have copied them into the test class. Both the lists
    with the account and product IDs are passed to the test scenario as feeds. Then,
    during every iteration, the required values are randomly picked from the lists.
    Our test scenario is named `AddAndConfirmOrder`. It consists of two `exec` methods.
    The first of them creates a new order by calling the `POST /order` HTTP method.
    The order''s ID is automatically generated by the service, so it should be saved
    as an attribute. Then it can be used in the next `exec` method, which confirms
    the order by calling the `PUT /order/{id}` endpoint. The only thing that is validated
    after the test is the HTTP status:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: Running a test scenario
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'There are a few different ways of running a Gatling performance test on your
    machine. One of them is through one of the available through Gradle plugins, which
    provide support for running tests during the building of a project. You may also
    use Maven plugins or just try to run it from your IDE. If you build your project
    with Gradle, you can also define simple tasks that just run tests by launching
    the `io.gatling.app.Gatling` main class. Here''s a definition of such a task in
    the `gradle.build` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'Now you can run that task just by calling the `gradle loadTest` command. Of
    course, you need to have all the sample microservices, MongoDB, and `discovery-service`
    started before running those tests. By default, Gatling will print all the requests
    sent, the received responses, and the final test result, with time statistics
    and the number of success and failure API calls. If you need more detailed information,
    you should refer to the files generated after the test, which are available under
    the `build/gatling-results` directory. You might find that the HTML files there
    provide visualization in the form of diagrams and graphs. The first of them (shown
    in the following diagram) shows a summary with the total number of generated requests
    and the maximum response time broken down by percentiles. For example, you may
    see that the maximum response time in 95% of responses for the `AddOrder` API
    is 835 ms:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/b0a26700-2d21-4154-a8c2-59a74a404800.png)'
  prefs: []
  type: TYPE_IMG
- en: 'There are also some other interesting statistics visualized. Let''s pay particular
    attention to the following two reports. The first of them shows a graph displaying
    the percentage of requests grouped by the average response time, while the second
    shows the timeline with the average response time by percentile:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/94bc93b4-1e8f-465f-9ff6-ba27c5f7f418.png)'
  prefs: []
  type: TYPE_IMG
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, I have introduced some frameworks that can help you effectively
    test your REST-based applications written in Java. Each of these solutions has
    been assigned to a particular type of test. I focused on tests strictly related
    to microservices, such as contract and component tests. The main goal of this
    chapter was to compare the two most popular frameworks used for contract testing,
    namely Pact and Spring Cloud Contract. Despite appearances, there are some significant
    differences between them. I tried to show you the most important similarities
    and differences based on the same sample applications that we looked at in previous
    chapters.
  prefs: []
  type: TYPE_NORMAL
- en: Microservices are strictly related to automation. Remember that migration from
    monolith to microservices gives you an opportunity to refactor your code, and,
    moreover, to improve the quality and code coverage of your automated tests. Frameworks
    such as Mockito, Spring Test, Spring Cloud Contract, and Pact, when used together,
    give you a really powerful solution to develop tests for REST-based Java microservices.
    Automated tests are a significant part of the CI/CD process, which will be discussed
    in the next chapter.
  prefs: []
  type: TYPE_NORMAL
