- en: Opening up to OAuth 2
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**OAuth 2** is a very popular form of trusted identity management that allows
    users to manage their identity through a single trusted provider. This convenient
    feature provides users with the security of storing their password and personal
    information with the trusted OAuth 2 provider, optionally disclosing personal
    information upon request. Additionally, the OAuth 2-enabled website offers the
    confidence that the users providing OAuth 2 credentials are who they say they
    are.'
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Learning to set up your own OAuth 2 application in less than 5 minutes
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Configuring the JBCP calendar application with a very rapid implementation of
    OAuth 2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Learning the conceptual architecture of OAuth 2 and how it provides your site
    with trustworthy user access
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Implementing OAuth 2-based user registration
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Experimenting with OAuth 2 attribute exchange for user profile functionality
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Demonstrating how we can trigger automatic authentication to the previous OAuth
    2 provider
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Examining the security offered by OAuth 2-based login
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The promising world of OAuth 2
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As an application developer, you may have heard the term OAuth 2 thrown around
    a lot. OAuth 2 has been widely adopted by web service and software companies around
    the world and is integral to the way these companies interact and share information.
    But what exactly is it? In a nutshell, OAuth 2 is a protocol that allows distinct
    parties to share information and resources in a secure and reliable manner.
  prefs: []
  type: TYPE_NORMAL
- en: What about OAuth 1.0?
  prefs: []
  type: TYPE_NORMAL
- en: Built with the same motivation, OAuth 1.0 was designed and ratified in 2007\.
    However, it was criticized for being overly complex and also had issues with imprecise
    specifications, which led to insecure implementation. All of these issues contributed
    to poor adoption for OAuth 1.0, and eventually led to the design and creation
    of OAuth 2\. OAuth 2 is the successor to OAuth 1.0.
  prefs: []
  type: TYPE_NORMAL
- en: It is also important to note that OAuth 2 is not backward compatible with OAuth
    1.0, and so OAuth 2 applications cannot integrate with OAuth 1.0 service providers.
  prefs: []
  type: TYPE_NORMAL
- en: This type of login-through a trusted third-party-has been in existence for a
    long time, in many different forms (for example, **Microsoft Passport** became
    one of the more notable central login services on the web for some time). The
    distinct advantage of OAuth 2 is that the OAuth 2 provider needs to implement
    only the public OAuth 2 protocol to be compatible with any site seeking to integrate
    login with OAuth 2.
  prefs: []
  type: TYPE_NORMAL
- en: You can refer to the OAuth 2.0 specification at [https://tools.ietf.org/html/rfc6749](https://tools.ietf.org/html/rfc6749).
  prefs: []
  type: TYPE_NORMAL
- en: 'The following diagram illustrates the high-level relationship between a site
    integrating OAuth 2 during the login process and the Facebook OAuth 2 provider,
    for example:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/9724fa6b-4a4a-48bd-81f4-2e23851bb241.png)'
  prefs: []
  type: TYPE_IMG
- en: We can see that submitting a form post will initiate a request to the OAuth
    provider, resulting in the provider displaying an authorization dialog asking
    the user to allow `jbcpcalendar` to gain permission to specific information from
    your OAuth provider account. This request contains a `uri` parameter called `code`.
    Once granted, the user is redirected back to `jbcpcalendar`, and the `code` parameter
    is included in the `uri` parameter. Then, the request is redirected to the OAuth
    provider again, to authorize `jbcpcalendar`. The OAuth provider then responds
    with an `access_token` that can be used to access the user's OAuth information
    that `jbcpcalendar` was granted access to.
  prefs: []
  type: TYPE_NORMAL
- en: Don't trust OAuth 2 unequivocally!
  prefs: []
  type: TYPE_NORMAL
- en: Here, you can see a fundamental assumption that can fool users of the system.
    It is possible for us to sign up for an OAuth 2 provider account, which would
    make it appear as though we were James Gosling, even though we obviously are not.
    Do not make the false assumption that just because a user has a convincing-sounding
    OAuth 2 (or OAuth 2 delegate provider), that he/she is the authentic person without
    requiring additional forms of identification. Thinking about it another way, if
    someone came to your door just claiming he was James Gosling, would you let him
    in without verifying his ID?
  prefs: []
  type: TYPE_NORMAL
- en: The OAuth 2-enabled application then redirects the user to the OAuth 2 provider,
    and the user presents his credentials to the provider, which is then responsible
    for making an access decision. Once the access decision has been made by the provider,
    the provider redirects the user to the originating site, which is now assured
    of the user's authenticity. OAuth 2 is much easier to understand once you have
    tried it. Let's add OAuth 2 to the JBCP calendar login screen now!
  prefs: []
  type: TYPE_NORMAL
- en: Signing up for an OAuth 2 application
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In order to get the full value out of the exercise in this section (and be able
    to test login), you will need to create an application with a service provider.
    Currently, Spring Social supports Twitter, Facebook, Google, LinkedIn, and GitHub,
    and the list is growing.
  prefs: []
  type: TYPE_NORMAL
- en: To get the full value out of the exercises in this chapter, we recommend you
    have accounts with at least Twitter and GitHub. We have set up accounts for the
    `jbcpcalendar` application, which we will be using for the remainder of this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Enabling OAuth authentication with Spring Security
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We can see a common theme among the external authentication providers examined
    over the next several chapters. Spring Security provides convenient wrappers around
    the provider integrations that are actually developed outside the Spring ecosystem.
  prefs: []
  type: TYPE_NORMAL
- en: In this vein, the Spring Social project ([http://projects.spring.io/spring-social/](http://projects.spring.io/spring-social/))
    provides the underlying OAuth 2 provider discovery and request/response negotiation
    for the Spring Security OAuth 2 functionality.
  prefs: []
  type: TYPE_NORMAL
- en: Additional required dependencies
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s take a look at the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'In order to utilize OAuth, we will need to include provider-specific dependencies
    and their transitive dependencies. This can be done in Gradle by updating the
    `build.gradle` file, as shown in the following code snippet:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'Using Spring Boot includes references to Facebook, Twitter, and LinkedIn starter
    dependencies, as shown in the preceding code snippet. To add other providers,
    we must include the provider dependency and include the version. This can be done
    in Gradle by updating the `build.gradle` file, as shown in the following code
    snippet:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: You should start with the source in `chapter09.00-calendar`.
  prefs: []
  type: TYPE_NORMAL
- en: 'When writing the OAuth login form, we will need to replace the `username` and
    `password` fields with OAuth fields. Go ahead and make the following updates to
    your `login.html` file:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'We can make similar edits to the signup form, as shown in the following code
    snippet:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: You will notice that we have added a scope field to define the OAuth 2 details
    we are interested in retrieving during authentication.
  prefs: []
  type: TYPE_NORMAL
- en: '**OAuth 2.0 API Scopes:** Scopes allow a provider to define the API data accessible
    to client applications. When an API is created by a provider, they define one
    scope for each API represented and action. Once an API is created and define the
    scopes, the client applications can request these defined permissions when they
    initiate an authorization flow and include them in the access token as part of
    the scope request parameter.'
  prefs: []
  type: TYPE_NORMAL
- en: Each provider might have slightly different API scopes, such as `r_basicprofile`
    and `r_emailaddress`, but the API scope is also limited to the application configuration.
    As such, an application might only request access to email or contacts, not the
    entire user profile or provider actions such as posting to a user's wall.
  prefs: []
  type: TYPE_NORMAL
- en: You'll notice that we don't offer the **remember me** option with OAuth 2 login.
    This is due to the fact that the redirection to and from the vendor causes the
    **remember me** checkbox value to be lost so that when the user is successfully
    authenticated, they no longer have the **remember me** option indicated. This
    is unfortunate, but ultimately increases the security of OAuth 2 as a login mechanism
    for our site, as OAuth 2 forces the user to establish a trusted relationship with
    the provider with each and every login.
  prefs: []
  type: TYPE_NORMAL
- en: Configuring OAuth 2 support in Spring Security
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Using **Spring Social**, we can enable OAuth 2-specific provider endpoints for
    intercepting provider form submissions.
  prefs: []
  type: TYPE_NORMAL
- en: Local UserConnectionRepository
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The `UsersConnectionRepository` interface is a data access interface for managing
    a global store of users'' connections to service providers. It provides data access
    operations that apply to multiple user records, as shown in the following code
    snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: Creating local database entries for provider details
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Spring Security provides support to save provider details in a separate set
    of database tables, in case we want to save the user in a local data store, but
    don''t want to include that data in an existing `User` table:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'This `InitializingBean` interface is executed at load time and will execute
    `JdbcUsersConnectionRepository.sql` which is located in the `spring-social-core-[VERSION].jar`
    file on the classpath, seeding the following schema into our local database:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: Now that we have a table to store provider details, we can configure `ConnectionRepository`
    to save provider details at runtime.
  prefs: []
  type: TYPE_NORMAL
- en: The custom UserConnectionRepository interface
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We need to create a `UserConnectionRepository` interface, and we can leverage
    `JdbcUsersConnectionRepository` as the implementation, which is based on the `JdbcUsersConnectionRepository.sql`
    schema we generated at load time, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: Now, every time a user connects to a registered provider, the connection details
    will be saved into our local database.
  prefs: []
  type: TYPE_NORMAL
- en: The ConnectionSignup flow
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In order to save the provider details into a local repository, we have created
    a `ConnectionSignup` object, which is a command that signs up a new user in the
    event that no `userid` can be mapped from `Connection` which allows for implicitly
    creating a local user profile from connection data during a provider sign-in attempt:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: Executing the OAuth 2 provider connection workflow
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In order to save the provider details, we need to fetch the available details
    from the provider, available via the OAuth 2 connection. Next, we create a `CalendarUser`
    table from the available details. Note that we need to create at least one `GrantedAuthority`
    role. Here, we have used `CalendarUserAuthorityUtils#createAuthorities` to create
    `ROLE_USER` `GrantedAuthority`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: Adding OAuth 2 users
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Now that we have created `CalendarUser` from our provider details, we need
    to save that `User` account into our database using `CalendarUserDao`. We then
    return the `CalendarUser` email, as that is what we have been using in the JBCP
    calendar for the username, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: Now, we have a local `User` account in our database based on the provider details.
  prefs: []
  type: TYPE_NORMAL
- en: This is an additional database entry, as we have already saved the provider
    details into the `UserConnection` table earlier.
  prefs: []
  type: TYPE_NORMAL
- en: OAuth 2 controller sign-in flow
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now, to complete the `SocialConfig.java` configuration, we need to construct
    `ProviderSignInController`, which is initialized with `ConnectionFactoryLocator`,
    `usersConnectionRepository`, and `SignInAdapter`. The `ProviderSignInController`
    interface is a Spring MVC controller for handling the provider user sign-in flow.
    An HTTP `POST` request to `/signin/{providerId}` initiates a user sign-in with
    `{providerId}`. Submitting an HTTP `GET` request to `/signin/{providerId}?oauth_token&amp;oauth_verifier||code`
    will receive the `{providerId}` authentication callback and establish the connection.
  prefs: []
  type: TYPE_NORMAL
- en: 'A `ServiceLocator` interface is used for creating the `ConnectionFactory` instances.
    This factory supports lookup by `providerId` and by `apiType`, based on the included
    service providers found within Spring Boot''s `AutoConfiguration`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: This will allow submissions to a specific provider `uri` to be intercepted,
    and will begin the OAuth 2 connection flow.
  prefs: []
  type: TYPE_NORMAL
- en: Automatic user authentication
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s take a look at the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'The `ProviderSignInController` controller is initialized with an authentication
    `SignInAdapter`, which is used to complete a provider sign-in attempt by signing
    in the local user account with the specified ID:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'In the `SingInAdapter` bean, from the preceding code snippet, we used a custom
    authentication utility method to create an `Authentication` object in the form
    of `UsernamePasswordAuthenticationToken`, and added it to `SecurityContext` based
    on the details returned from the OAuth 2 provider:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'The final details required to connect to a provider is the application ID and
    secret key obtained when creating the provider application are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: Now we have the required details to connect to the Twitter JBCP calendar, and
    we can start the JBCP calendar and log in with a Twitter provider.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Your code should now look like `chapter09.01-calendar`.
  prefs: []
  type: TYPE_NORMAL
- en: 'At this point, you should be able to complete a full login using Twitter''s
    OAuth 2 provider. The redirects that occur are as follows, first, we initiate
    the OAuth 2 provider login as shown in the following screenshot:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/0187934f-9625-4fe9-a1c3-e5ff87e30f25.png)'
  prefs: []
  type: TYPE_IMG
- en: 'We are then redirected to the provider authorization page, requesting the user
    to grant permission to the `jbcpcalendar` application as shown in the following
    screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/c837c1db-7c10-4400-9560-63441a2d743a.png)'
  prefs: []
  type: TYPE_IMG
- en: 'After authorizing the `jbcpcalendar` application, the user is redirected to
    the `jbcpcalendar` application and automatically logged in using the provider
    display name:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/f04b6a3f-70e6-4239-8e71-beecfd6af9de.png)'
  prefs: []
  type: TYPE_IMG
- en: 'At this point, the user exists in the application and is authenticated and
    authorized with a single `GrantedAuthority` of `ROLE_USER`, but if we navigate
    to My Events, the user will be allowed to view this page. However, no events exist
    for `CalendarUser`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/5aaa1cee-f870-4307-bdb5-a707d9a4475e.png)'
  prefs: []
  type: TYPE_IMG
- en: Try to create an event for this user to verify that the user credentials that
    were created correctly in the `CalendarUser` table.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'To verify that the provider details were created correctly, we can open the
    H2 admin console and query the `USERCONNECTION` table to verify that standard
    connection details were saved, as shown in the following screenshot:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/088cc488-6004-466e-9862-4412e0a538aa.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Additionally, we can verify the `CALENDAR_USERS` table, which has also been
    populated with the provider details:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/7442542f-e849-49b4-b10d-7985c7428b7d.png)'
  prefs: []
  type: TYPE_IMG
- en: Now we have the user registered in our local database, and we also have the
    ability to interact with the registered provider based on authorized access to
    specific provider details.
  prefs: []
  type: TYPE_NORMAL
- en: Additional OAuth 2 providers
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We have successfully integrated a single OAuth 2 provider using one of the three
    current support providers for Spring Social. There are several other providers
    available; we are going to add a few more providers so our users have more than
    one option. Spring Social currently supports Twitter, Facebook, and LinkedIn providers
    natively. Including additional providers will require additional libraries to
    gain this support, which will be covered later in this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s take a look at the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: In order to add Facebook or LinkedIn providers into the JBCP calendar application,
    additional application properties need to be set, and each configured provider
    will automatically be registered with the
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The OAuth 2 user registration problem
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: One issue that would need to be resolved if supporting multiple providers is
    username conflicts between the various provider details returned.
  prefs: []
  type: TYPE_NORMAL
- en: If you log in to the JBCP calendar application with each of the listed providers-which
    then query the data that was stored in H2-you will find the data could be similar,
    if not exactly the same, based on the user's account details.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the following `USERCONNECTION` table, we can see that the `USERID` column
    data from each provider, is similar:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/7f7a6efe-34ba-48c1-b81c-33d59e7eddb7.png)'
  prefs: []
  type: TYPE_IMG
- en: 'In the `CALENDARUSER` table, we have two possible issues. First, the user details
    used for `EMAIL`, which is the JBCP calendar user `ID` , is not an email for some
    of the providers. Second, it is still possible that the user identifier for two
    different providers will be the same:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/b72f5a6e-04aa-4585-977b-d8cda1c13d17.png)'
  prefs: []
  type: TYPE_IMG
- en: We are not going to dive into the various ways to detect and correct this possible
    issue, but it is worth noting for future reference.
  prefs: []
  type: TYPE_NORMAL
- en: Registering non-standard OAuth 2 providers
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In order to include additional providers, we need to perform a few extra steps
    to include custom providers into the login flow, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: 'For each provider, we need to include the provider dependencies in our `build.gradle`
    file, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, we will register the providers into the JBCP calendar application with
    the following additional application properties for the `appId` and `appSecret`
    key for each provider:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'Each new provider must be registered by adding the respective `ConnectionFactory`
    interface. We can add a new `ConnectionFactory` entry for each new Provider we
    intend to support, to the custom `DatabaseSocialConfigurer.java` file as seen
    in the following:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'We can now add the new login options to our `login.html` file and `form.html`
    sign up page to include one new `<form>` tag for each new provider:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, we have the required details to connect to the additional providers for
    the JBCP calendar. We can restart the JBCP calendar application and test logging
    in with the additional OAuth 2 providers. When logging in now, we should be presented
    with additional provider options, as shown in the following screenshot:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/8c68d305-cdd4-4a20-9c1e-bfde59e40702.png)'
  prefs: []
  type: TYPE_IMG
- en: Is OAuth 2 secure?
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As support for OAuth 2 relies on the trustworthiness of the OAuth 2 provider
    and the verifiability of the provider's response, security and authenticity are
    critical in order for the application to have confidence in the user's OAuth 2-based
    login.
  prefs: []
  type: TYPE_NORMAL
- en: 'Fortunately, the designers of the OAuth 2 specification were very aware of
    this concern, and implemented a series of verification steps to prevent response
    forgery, replay attacks, and other types of tampering, which are explained as
    follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Response forgery** is prevented due to a combination of a shared secret key
    (created by the OAuth 2-enabled site prior to the initial request), and a one-way
    hashed message signature on the response itself. A malicious user tampering with
    the data in any of the response fields without having access to the shared secret
    key-and signature algorithm-would generate an invalid response.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Replay attacks** are prevented due to the inclusion of a nonce, or a one-time
    use, random key, which should be recorded by the OAuth 2-enabled site so that
    it cannot ever be reused. In this way, even a user attempting to reissue the response
    URL would be foiled because the receiving site would determine that the nonce
    had been previously used, and would invalidate the request.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The most likely form of attack that could result in a compromised user interaction
    would be a man-in-the-middle attack, where a malicious user could intercept the
    user's interaction between their computer and the OAuth 2 provider. A hypothetical
    attacker in this situation could be in a position to record the conversation between
    the user's browser and the OAuth 2 provider, and record the secret key used when
    the request was initiated. The attacker, in this case, would need a very high
    level of sophistication and reasonably a complete implementation of the OAuth
    2 signature specification-in short, this is not likely to occur with any regularity.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we reviewed OAuth 2, a relatively recent technology for user
    authentication and credentials management. OAuth 2 has a very wide reach on the
    web and has made great strides in usability and acceptance within the past year
    or two. Most public-facing sites on the modern web should plan on having some
    form of OAuth 2 support, and the JBCP calendar application is no exception!
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we learned about the following topics the OAuth 2 authentication
    mechanism and its high-level architecture and key terminology. We also learned
    about the OAuth 2 login and automatic user registration with the JBCP calendar
    application.
  prefs: []
  type: TYPE_NORMAL
- en: We also covered automatic login with OAuth 2 and the security of OAuth 2's login
    responses.
  prefs: []
  type: TYPE_NORMAL
- en: We covered one of the simplest single sign-on mechanisms to implement with Spring
    Security. One of the downsides is that it does not support a standard mechanism
    for a single logout. In the next chapter, we will explore CAS, another standard,
    single sign-on protocol that also supports single logout.
  prefs: []
  type: TYPE_NORMAL
