- en: Session Management
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This chapter discusses Spring Security's session management functionality. It
    starts off with an example of how Spring Security defends against session fixation.
    We will then discuss how concurrency control can be leveraged to restrict access
    to software licensed on a per-user basis. We will also see how session management
    can be leveraged for administrative functions. Last, we will explore how `HttpSession`
    is used in Spring Security and how we can control its creation.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following is a list of topics that will be covered in this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: Session management/session fixation
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Concurrency control
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Managing logged in users
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How `HttpSession` is used in Spring Security and how to control creation
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to use the `DebugFilter` class to discover where `HttpSession` was created
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Configuring session fixation protection
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'As we are using the security namespace style of configuration, session fixation
    protection is already configured on our behalf. If we wanted to explicitly configure
    it to mirror the default settings, we would do the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: '**Session fixation protection** is a feature of the framework that you most
    likely won''t even notice unless you try to act as a malicious user. We''ll show
    you how to simulate a session-stealing attack; before we do, it''s important to
    understand what session fixation does and the type of attack it prevents.'
  prefs: []
  type: TYPE_NORMAL
- en: Understanding session fixation attacks
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Session fixation is a type of attack whereby a malicious user attempts to steal
    the session of an unauthenticated user of your system. This can be done by using
    a variety of techniques that result in the attacker obtaining the unique session
    identifier of the user (for example, `JSESSIONID`). If the attacker creates a
    cookie or a URL parameter with the user's `JSESSIONID` identifier in it, they
    can access the user's session.
  prefs: []
  type: TYPE_NORMAL
- en: Although this is obviously a problem, typically, if a user is unauthenticated,
    they haven't entered any sensitive information. This becomes a more critical problem
    if the same session identifier continues to be used after a user has been authenticated.
    If the same identifier is used after authentication, the attacker may now gain
    access to the authenticated user's session without even having to know their username
    or password!
  prefs: []
  type: TYPE_NORMAL
- en: At this point, you may scoff in disbelief and think this is extremely unlikely
    to happen in the real world. In fact, session-stealing attacks happen frequently.
    We would suggest that you spend some time reading the very informative articles
    and case studies on the subject, published by the **Open Web Application Security
    Project** (**OWASP**) organization ([http://www.owasp.org/](http://www.owasp.org/)).
    Specifically, you will want to read the OWASP top 10 lists. Attackers and malicious
    users are real, and they can do very real damage to your users, your application,
    or your company if you don't understand the techniques that they commonly use
    and know how to avoid them.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following diagram illustrates how a session fixation attack works:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/62110072-4014-450b-a589-12bea83aa974.png)'
  prefs: []
  type: TYPE_IMG
- en: Now that we have seen how an attack like this works, we'll see what Spring Security
    can do to prevent it.
  prefs: []
  type: TYPE_NORMAL
- en: Preventing session fixation attacks with Spring Security
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: If we can prevent the same session that the user had prior to authentication
    from being used after authentication, we can effectively render the attacker's
    knowledge of the session ID useless. Spring Security session fixation protection
    solves this problem by explicitly creating a new session when a user is authenticated
    and invalidating their old session.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s take a look at the following diagram:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/d3dc9885-dfc0-4b62-a3c8-433a59efde1e.png)'
  prefs: []
  type: TYPE_IMG
- en: We can see that a new filter, `o.s.s.web.session.SessionManagementFilter`, is
    responsible for evaluating if a particular user is newly authenticated. If the
    user is newly authenticated, a configured `o.s.s.web.authentication.session.SessionAuthenticationStrategy`
    interface determines what to do. `o.s.s.web.authentication.session.SessionFixationProtectionStrategy`
    will create a new session (if the user already had one), and copy the contents
    of the existing session to the new one. That's pretty much it-seems simple. However,
    as we can see in the preceding diagram, it effectively prevents the malicious
    user from reusing the session ID after the unknown user is authenticated.
  prefs: []
  type: TYPE_NORMAL
- en: Simulating a session fixation attack
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'At this point, you may want to see what''s involved in simulating a session
    fixation attack:'
  prefs: []
  type: TYPE_NORMAL
- en: You'll first need to disable session fixation protection in the `SecurityConfig.java`
    file by adding the `sessionManagement()` method as a child of the `http` element.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: You should start with the code from `chapter14.00-calendar`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s take a look at the following code snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: Your code should now look like `chapter14.01-calendar`.
  prefs: []
  type: TYPE_NORMAL
- en: Next, you'll need to open two browsers. We'll initiate the session in Google
    Chrome, steal it from there, and our attacker will log in using the stolen session
    in Firefox. We will use the Google Chrome and the Firefox web developer add-on
    in order to view and manipulate cookies. The Firefox web developer add-on can
    be downloaded from [https://addons.mozilla.org/en-US/firefox/addon/web-developer/](https://addons.mozilla.org/en-US/firefox/addon/web-developer/).
    Google Chrome's web developer tools are built-in.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Open the JBCP calendar home page in Google Chrome.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Next, from the main menu, navigate to Edit | Preferences | Under the Hood.
    In the Privacy category, press the Content Settings... button. Next, in Cookies
    Settings, press the All Cookies and Site Data... button. Finally, enter `localhost`
    into the Search field, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/ab82311f-9925-4cfb-a44e-9a37668d2ce5.png)'
  prefs: []
  type: TYPE_IMG
- en: Select the `JSESSIONID` cookie, copy the value of Content to the clipboard,
    and log in to the JBCP calendar application. If you repeat the View Cookie Information
    command, you'll see that `JSESSIONID` did not change after you logged in, making
    you vulnerable to a session fixation attack!
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In Firefox, open the JBCP calendar website. You will have been assigned a session
    cookie, which you can view by using *Ctrl* + *F2* to open the bottom Cookie console.
    Then type in `cookie list [enter]` to bring up cookies for the current page.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'To complete our hack, we''ll click on the Edit Cookie option and paste in the
    `JSESSIONID` cookie that we copied to the clipboard from Google Chrome, as shown
    in the following screenshot:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/f6a22fcb-2b58-4f24-803c-a0c306aae717.png)'
  prefs: []
  type: TYPE_IMG
- en: Keep in mind that newer versions of Firefox include web developer tools, too.
    However, you will need to ensure that you are using the extension and not the
    built-in one, as it provides additional capabilities.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Our session fixation hack is complete! If you now reload the page in Firefox,
    you will see that you are logged in as the same user who was logged in using Google
    Chrome, but without the knowledge of the username and password. Are you scared
    of malicious users yet?
  prefs: []
  type: TYPE_NORMAL
- en: Now, re-enable session fixation protection and try this exercise again. You'll
    see that, in this case, the `JSESSIONID` changes after the user logs in. Based
    on our understanding of how session fixation attacks occur, this means that we
    have reduced the likelihood of an unsuspecting user falling victim to this type
    of attack. Excellent job!
  prefs: []
  type: TYPE_NORMAL
- en: Cautious developers should note that there are many methods of stealing session
    cookies, some of which-such as XSS-may make even session fixation protected sites
    vulnerable. Please consult the OWASP site for additional resources on preventing
    these types of attacks.
  prefs: []
  type: TYPE_NORMAL
- en: Comparing the session-fixation-protection options
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The `session-fixation-protection` attribute has the following three options
    that allow you to alter its behavior, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Attribute value** | **Description** |'
  prefs: []
  type: TYPE_TB
- en: '| `none()` | This option disables session fixation protection and (unless other
    `sessionManagement()` attributes are non-default) does not configure `SessionManagementFilter`.
    |'
  prefs: []
  type: TYPE_TB
- en: '| `migrateSession()` | When the user is authenticated and a new session is
    allocated, it ensures that all attributes of the old session are moved to the
    new session. |'
  prefs: []
  type: TYPE_TB
- en: '| `newSession()` | When the user is authenticated, a new session is created
    and no attributes from the old (unauthenticated) session will be migrated. |'
  prefs: []
  type: TYPE_TB
- en: In most cases, the default behavior of `migrateSession()` will be appropriate
    for sites that wish to retain important attributes of the user's session (such
    as click interest and shopping carts) after the user has been authenticated.
  prefs: []
  type: TYPE_NORMAL
- en: Restricting the number of concurrent sessions per user
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the software industry, software is often sold on a per-user basis. This means
    that, as software developers, we have an interest in ensuring that only a single
    session per user exists, to combat the sharing of accounts. Spring Security's
    concurrent session control ensures that a single user cannot have more than a
    fixed number of active sessions simultaneously (typically one). Ensuring that
    this maximum limit is enforced involves several components working in tandem to
    accurately track changes in user session activity.
  prefs: []
  type: TYPE_NORMAL
- en: Let's configure the feature, review how it works, and then test it out!
  prefs: []
  type: TYPE_NORMAL
- en: Configuring concurrent session control
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Now that we have understood the different components involved in concurrent
    session control, setting it up should make much more sense. Let''s take a look
    at the following steps to configure concurrent session control:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Firstly, you update your `security.xml` file as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, we need to enable `o.s.s.web.session.HttpSessionEventPublisher` in the
    `SecurityConfig.java` deployment descriptor, so that the servlet container will
    notify Spring Security (through `HttpSessionEventPublisher`) of session life cycle
    events, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: With these two configuration bits in place, concurrent session control will
    now be activated. Let's see what it actually does, and then we'll demonstrate
    how it can be tested.
  prefs: []
  type: TYPE_NORMAL
- en: Understanding concurrent session control
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Concurrent session control uses `o.s.s.core.session.SessionRegistry` to maintain
    a list of active HTTP sessions and the authenticated users with which they are
    associated. As sessions are created and expired, the registry is updated in real
    time based on the session life cycle events published by `HttpSessionEventPublisher`
    to track the number of active sessions per authenticated user.
  prefs: []
  type: TYPE_NORMAL
- en: 'Refer to the following diagram:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/cd90434e-cc5a-4032-8764-fb2d1e4af99f.png)'
  prefs: []
  type: TYPE_IMG
- en: An extension of `SessionAuthenticationStrategy`, `o.s.s.web.authentication.session.ConcurrentSessionControlStrategy`
    is the method by which new sessions are tracked and the method by which concurrency
    control is actually enforced. Each time a user accesses the secured site, `SessionManagementFilter`
    is used to check the active session against `SessionRegistry`. If the user's active
    session isn't in the list of active sessions tracked in `SessionRegistry`, the
    least recently used session is immediately expired.
  prefs: []
  type: TYPE_NORMAL
- en: The secondary actor in the modified concurrent session control filter chain
    is `o.s.s.web.session.ConcurrentSessionFilter`. This filter will recognize expired
    sessions (typically, sessions that have been expired either by the servlet container
    or forcibly by the `ConcurrentSessionControlStrategy` interface) and notify the
    user that their session has expired.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have understood how concurrent session control works, it should
    be easy for us to reproduce a scenario in which it is enforced.
  prefs: []
  type: TYPE_NORMAL
- en: Your code should now look like `chapter14.02-calendar`.
  prefs: []
  type: TYPE_NORMAL
- en: Testing concurrent session control
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'As we did when verifying session fixation protection, we will need to access
    two web browsers by performing the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: In Google Chrome, log in to the site as `user1@example.com/user1`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Now, in Firefox, log in to the site as the same user.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Finally, go back to Google Chrome and take any action. You will see a message
    indicating that your session has expired, as shown in the following screenshot:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/f71d8539-cbd5-446c-802c-4ca17abcd3f2.png)'
  prefs: []
  type: TYPE_IMG
- en: If you were using this application and received this message, you'd probably
    be confused. This is because it's obviously not a friendly method of being notified
    that only a single user can access the application at a time. However, it does
    illustrate that the session has been forcibly expired by the software.
  prefs: []
  type: TYPE_NORMAL
- en: Concurrent session control tends to be a very difficult concept for new Spring
    Security users to grasp. Many users try to implement it without truly understanding
    how it works and what the benefits are. If you're trying to enable this powerful
    feature, and it doesn't seem to be working as you expect, make sure you have everything
    configured correctly and then review the theoretical explanations in this section-hopefully,
    they will help you understand what may be wrong!
  prefs: []
  type: TYPE_NORMAL
- en: When a session expiration event occurs, we should probably redirect the user
    to the login page and provide them with a message to indicate what went wrong.
  prefs: []
  type: TYPE_NORMAL
- en: Configuring expired session redirect
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Fortunately, there is a simple method for directing users to a friendly page
    (typically the login page) when they are flagged by concurrent session control-simply
    specify the `expired-url` attribute and set it to a valid page in your application.
    Update your `security.xml` file as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'In the case of our application, this will redirect the user to the standard
    login form. We will then use the query parameter to display a friendly message
    indicating that we determined that they had multiple active sessions, and should
    log in again. Update your `login.html` page to use this parameter to display our
    message:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: Go ahead and give it a try by logging in as the user `admin1@example.com`/`admin1`
    using both Google Chrome and Firefox. This time, you should see a login page with
    a custom error message.
  prefs: []
  type: TYPE_NORMAL
- en: Your code should now look like `chapter14.03-calendar`.
  prefs: []
  type: TYPE_NORMAL
- en: Common problems with concurrency control
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: There are a few common reasons that logging in with the same user does not trigger
    a logout event. The first occurs when using custom `UserDetails` (as we did in
    [Chapter 3](03.html), *Custom Authentication*) while the equals and `hashCode`
    methods are not properly implemented. This occurs because the default `SessionRegistry`
    implementation uses an in-memory map to store `UserDetails`. In order to resolve
    this, you must ensure that you have properly implemented the `hashCode` and equals
    methods.
  prefs: []
  type: TYPE_NORMAL
- en: The second problem occurs when restarting the application container while the
    user sessions are persisted to a disk. When the container has started back up,
    the users who were already logged in with a valid session are logged in. However,
    the in-memory map of `SessionRegistry` that is used to determine if the user is
    already logged in will be empty. This means that Spring Security will report that
    the user is not logged in, even though the user is. To solve this problem, either
    a custom `SessionRegistry` is required along with disabling session persistence
    within the container, or you must implement a container-specific way to ensure
    that the persisted sessions get populated into the in-memory map at startup.
  prefs: []
  type: TYPE_NORMAL
- en: 'Yet another reason is that at the time of writing, concurrency control is not
    implemented for the remember-me feature. If users are authenticated with remember-me,
    that concurrency control is not enforced. There is a JIRA to implement this feature,
    so refer to it for any updates if your application requires both remember-me and
    concurrency control: [https://jira.springsource.org/browse/SEC-2028](https://jira.springsource.org/browse/SEC-2028)'
  prefs: []
  type: TYPE_NORMAL
- en: The last common reason we will cover is that concurrency control will not work
    in a clustered environment with the default `SessionRegistry` implementation.
    As mentioned previously, the default implementation uses an in-memory map. This
    means that if `user1` logs in to application server A, the fact that they are
    logged in will be associated with that server. Thus, if `user1` then authenticates
    to Application Server B, the previously associated authentication will be unknown
    to application server B.
  prefs: []
  type: TYPE_NORMAL
- en: Preventing authentication instead of forcing logout
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Spring Security can also prevent a user from being able to log in to the application
    if the user already has a session. This means that instead of forcing the original
    user to be logged out, Spring Security will prevent the second user from being
    able to log in. The configuration changes can be seen as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: Make the updates and log in to the calendar application with Google Chrome.
    Now, attempt to log in to the calendar application with Firefox using the same
    user. You should see our custom error message from our `login.html` file.
  prefs: []
  type: TYPE_NORMAL
- en: Your code should now look like `chapter14.04-calendar`.
  prefs: []
  type: TYPE_NORMAL
- en: There is a disadvantage to this approach that may not be apparent without some
    thought. Try closing Google Chrome without logging out and then opening it up
    again. Now, attempt to log in to the application again. You will observe that
    you are unable to log in. This is because when the browser is closed, the `JSESSIONID`
    cookie is deleted. However, the application is not aware of this, so the user
    is still considered authenticated. You can think of this as a kind of memory leak,
    since `HttpSession` still exists but there is no pointer to it (the `JSESSIONID`
    cookie is gone). It is not until the session times out that our user will be able
    to authenticate again. Thankfully, once the session times out, our `SessionEventPublisher`
    interface will remove the user from our `SessionRegistry` interface. What we can
    take away from this is that if a user forgets to log out and closes the browser,
    they will not be able to log in to the application until the session times out.
  prefs: []
  type: TYPE_NORMAL
- en: Just as in [Chapter 7](08.html), *Remember-Me Services*, this experiment may
    not work if the browser decides to remember a session even after the browser is
    closed. Typically, this will happen if a plugin or the browser is configured to
    restore sessions. In this event, you might want to delete the `JSESSIONID` cookie
    manually to simulate the browser being closed.
  prefs: []
  type: TYPE_NORMAL
- en: Other benefits of concurrent session control
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Another benefit of concurrent session control is that `SessionRegistry` exists
    to track active (and, optionally, expired) sessions. This means that we can get
    runtime information about what user activity exists in our system (for authenticated
    users, at least) by performing the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'You can even do this if you don''t want to enable concurrent session control.
    Simply set `maximumSessions` to `-1`, and session tracking will remain enabled,
    even though no maximum will be enforced. Instead, we will use the explicit bean
    configuration provided in the `SessionConfig.java` file of this chapter, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'We have already added the import of the `SessionConfig.java` file to the `SecurityConfig.java`
    file. So, all that we need to do is reference the custom configuration in our
    `SecurityConfig.java` file. Go ahead and replace the current `sessionManagement`
    and `maximumSessions` configurations with the following code snippet:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: Your code should now look like `chapter14.05-calendar`.
  prefs: []
  type: TYPE_NORMAL
- en: Now, our application will allow an unlimited number of authentications for the
    same user. However, we can use `SessionRegistry` to forcibly log out the users.
    Let's see how we can use this information to enhance the security of our users.
  prefs: []
  type: TYPE_NORMAL
- en: Displaying active sessions for a user
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'You''ve probably seen how many websites allow a user to view and forcibly log
    out sessions for their account. We can easily use this forcible logout functionality
    to do the same. We have already provided `UserSessionController`, which obtains
    the active sessions for the currently logged in user. You can see the implementation
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'Our sessions method will use Spring MVC to automatically obtain the current
    Spring Security `Authentication`. If we were not using Spring MVC, we could also
    get the current `Authentication` from `SecurityContextHolder`, as discussed in
    [Chapter 3](03.html), *Custom Authentication*. The principal is then used to obtain
    all the `SessionInformation` objects for the current user. The information is
    easily displayed by iterating over the `SessionInformation` objects in our `sessions.html`
    file, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'You can now safely start the JBCP calendar application and log in to it using
    `user1@example.com`/`user1` in Google Chrome. Now, log in using Firefox and click
    on the `user1@example.com` link in the upper-right corner. You will then see both
    sessions listed on the display as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/95fdedc1-34b3-4227-904f-11c392939ffb.png)'
  prefs: []
  type: TYPE_IMG
- en: While in Firefox, click on the Delete button for the first session. This sends
    the request to our `deleteSession` method of `UserSessionsController`. This indicates
    that the session should be terminated. Now, navigate to any page within Google
    Chrome. You will see the custom message saying the session has been forcibly terminated.
    While the message could use updating, we see that this is a nice feature for users
    to terminate other active sessions.
  prefs: []
  type: TYPE_NORMAL
- en: Other possible uses include allowing an administrator to list and manage all
    active sessions, displaying the number of active users on the site, or even extending
    the information to include things like an IP address or location information.
  prefs: []
  type: TYPE_NORMAL
- en: How Spring Security uses the HttpSession method?
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We have already discussed how Spring Security uses `SecurityContextHolder`
    to determine the currently logged in user. However, we have not explained how
    `SecurityContextHolder` gets automatically populated by Spring Security. The secret
    to this lies in the `o.s.s.web.context.SecurityContextPersistenceFilter` filter
    and the `o.s.s.web.context.SecurityContextRepository` interface. Let''s take a
    look at the following diagram:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/f242c0b7-dcdd-425a-916b-59dc18d70a0d.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Here is an explanation for each step shown in the preceding diagram:'
  prefs: []
  type: TYPE_NORMAL
- en: At the beginning of each web request, `SecurityContextPersistenceFilter` is
    responsible for obtaining the current `SecurityContext` implementation using `SecurityContextRepository`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Immediately afterwards, it sets `SecurityContext` on `SecurityContextHolder`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: For the remainder of the web request, `SecurityContext` is available via `SecurityContextHolder`.
    For example, if a Spring MVC controller or `CalendarService` wanted to access
    `SecurityContext`, it could use `SecurityContextHolder` to access it.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Then, at the end of each request, `SecurityContextPersistenceFilter` gets the
    `SecurityContext` from `SecurityContextHolder`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Immediately afterwards, `SecurityContextPersistenceFilter` saves `SecurityContext`
    in `SecurityContextRepository`. This ensures that if `SecurityContext` is updated
    at any point during the web requests (that is, when a user creates a new account,
    as done in [Chapter 3](https://cdp.packtpub.com/spring_security__third_edition/wp-admin/post.php?post=42&action=edit),
    *Custom Authentication*) `SecurityContext` is saved.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Lastly, `SecurityContextPersistenceFilter` clears `SecurityContextHolder`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The question that now arises is how is this related to `HttpSession`? This is
    all tied together by the default `SecurityContextRepository` implementation, which
    uses `HttpSession`.
  prefs: []
  type: TYPE_NORMAL
- en: The HttpSessionSecurityContextRepository interface
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The default implementation of `SecurityContextRepository`, `o.s.s.web.context.HttpSessionSecurityContextRepository`,
    uses `HttpSession` to retrieve and store the current `SecurityContext` implementation.
    There are no other `SecurityContextRepository` implementations provided out of
    the box. However, since the usage of `HttpSession` is abstracted behind the `SecurityContextRepository`
    interface, we could easily write our own implementation if we desired.
  prefs: []
  type: TYPE_NORMAL
- en: Configuring how Spring Security uses HttpSession
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Spring Security has the ability to configure when the session is created by
    Spring Security. This can be done with the `http` element''s `create-session`
    attribute. A summary of the options can be seen in the following table:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Attribute value** | **Description** |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `ifRequired` | Spring Security will create a session only if one is required
    (default value). |'
  prefs: []
  type: TYPE_TB
- en: '| `always` | Spring Security will proactively create a session if one does
    not exist. |'
  prefs: []
  type: TYPE_TB
- en: '| `never` | Spring Security will never create a session, but will make use
    of one if the application does create it. This means if there is a `HttpSession`
    method, `SecurityContext` will be persisted or retrieve from it. |'
  prefs: []
  type: TYPE_TB
- en: '| `stateless` | Spring Security will not create a session and will ignore the
    session for obtaining a Spring `Authentication`. In such instances, `NullSecurityContextRepository`
    is used, which will always state that the current `SecurityContext` is `null`.
    |'
  prefs: []
  type: TYPE_TB
- en: In practice, controlling session creation can be more difficult than it first
    appears. This is because the attributes only control a subset of Spring Security's
    usage of `HttpSession`. It does not apply to any other components, such as JSPs,
    in the application. To help figure out when the `HttpSession` method was created,
    we can add Spring Security's `DebugFilter`.
  prefs: []
  type: TYPE_NORMAL
- en: Debugging with Spring Security's DebugFilter
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s take a look at the following steps and learn about how to debug with
    `DebugFilter` of Spring Security:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Update your `SecurityConfig.java` file to have a session policy of `NEVER`.
    Also, add the `debug` flag to `true` on the `@EnableWebSecurity` annotation, so
    that we can track when the session was created. The updates can be seen as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'When you start up the application, you should see something similar to the
    following code written to standard output. If you have not already, ensure that
    you have logging enabled across all levels of the Spring Security debugger category:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, clear out your cookies (this can be done in Firefox with *Shift* + *Ctrl*
    + *Delete*), start up the application, and navigate directly to `http://localhost:8080`.
    When we look at the cookies, as we did earlier in the chapter, we can see that
    `JSESSIONID` is created even though we stated that Spring Security should never
    create `HttpSession`. Look at the logs again, and you will see a call stack of
    the code that created `HttpSession` as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'In this instance, our JSP page is responsible for creating the new `HttpSession`
    method. In fact, all JSPs will create a new `HttpSession` method by default unless
    you include the following code at the top of each JSP:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: There are a number of other uses for `DebugFilter`, which we encourage you to
    explore on your own, for example, determining when a request will match a particular
    URL, which Spring Security filters are being invoked, and so on.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: After reading this chapter, you should be familiar with how Spring Security
    manages sessions and protects against session fixation attacks. We also know how
    to use Spring Security's concurrency control to prevent the same user from being
    authenticated multiple times.
  prefs: []
  type: TYPE_NORMAL
- en: We also explored the utilization of concurrency control to allow a user to terminate
    sessions associated with their account. Also, we saw how to configure Spring Security's
    creation of sessions. We also covered how to use Spring Security's `DebugFilter`
    filter to troubleshoot issues related to Spring.
  prefs: []
  type: TYPE_NORMAL
- en: We also learned about security, including determining when a `HttpSession` method
    was created and what caused it to be created.
  prefs: []
  type: TYPE_NORMAL
- en: This concludes our discussion about Spring Security's session management. In
    the next chapter, we will discuss some specifics about integrating Spring Security
    with other frameworks.
  prefs: []
  type: TYPE_NORMAL
