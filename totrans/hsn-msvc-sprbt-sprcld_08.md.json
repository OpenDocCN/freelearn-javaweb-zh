["```java\nexport BOOK_HOME=~/Documents/Hands-On-Microservices-with-Spring-Boot-and-Spring-Cloud\ngit clone https://github.com/PacktPublishing/Hands-On-Microservices-with-Spring-Boot-and-Spring-Cloud $BOOK_HOME\ncd $BOOK_HOME/Chapter07\n```", "```java\n@Test\npublic void TestFlux() {\n\n    List<Integer> list = new ArrayList<>();\n\n    Flux.just(1, 2, 3, 4)\n        .filter(n -> n % 2 == 0)\n        .map(n -> n * 2)\n        .log()\n        .subscribe(n -> list.add(n));\n\n    assertThat(list).containsExactly(4, 8);\n}\n```", "```java\n20:01:45.714 [main] INFO reactor.Flux.MapFuseable.1 - | onSubscribe([Fuseable] FluxMapFuseable.MapFuseableSubscriber)\n20:01:45.716 [main] INFO reactor.Flux.MapFuseable.1 - | request(unbounded)\n20:01:45.716 [main] INFO reactor.Flux.MapFuseable.1 - | onNext(4)\n20:01:45.717 [main] INFO reactor.Flux.MapFuseable.1 - | onNext(8)\n20:01:45.717 [main] INFO reactor.Flux.MapFuseable.1 - | onComplete()\n```", "```java\npublic interface ProductRepository extends ReactiveCrudRepository<ProductEntity, String> {\n    Mono<ProductEntity> findByProductId(int productId);\n}\n\npublic interface RecommendationRepository extends ReactiveCrudRepository<RecommendationEntity, String> {\n    Flux<RecommendationEntity> findByProductId(int productId);\n}\n```", "```java\nProductEntity foundEntity = repository.findById(newEntity.getId()).get();\nassertEqualsProduct(newEntity, foundEntity);\n```", "```java\nProductEntity foundEntity = repository.findById(newEntity.getId()).block();\nassertEqualsProduct(newEntity, foundEntity);\n```", "```java\nStepVerifier.create(repository.findById(newEntity.getId()))\n    .expectNextMatches(foundEntity -> areProductEqual(newEntity, \n     foundEntity))\n    .verifyComplete();\n```", "```java\nMono<Product> getProduct(@PathVariable int productId);\n```", "```java\npublic Mono<Product> getProduct(int productId) {\n\n    if (productId < 1) throw new InvalidInputException(\"Invalid \n        productId: \" + productId);\n\n    return repository.findByProductId(productId)\n        .switchIfEmpty(error(new NotFoundException(\"No product found \n         for productId: \" + productId)))\n        .log()\n        .map(e -> mapper.entityToApi(e))\n        .map(e -> {e.setServiceAddress(serviceUtil.getServiceAddress()); return e;});\n} \n```", "```java\n2019-02-06 10:09:47.006 INFO 62314 --- [ctor-http-nio-2] reactor.Mono.SwitchIfEmpty.1 : onSubscribe(FluxSwitchIfEmpty.SwitchIfEmptySubscriber)\n2019-02-06 10:09:47.007 INFO 62314 --- [ctor-http-nio-2] reactor.Mono.SwitchIfEmpty.1 : request(unbounded)\n2019-02-06 10:09:47.034 INFO 62314 --- [ntLoopGroup-2-2] reactor.Mono.SwitchIfEmpty.1 : onNext(ProductEntity: 1)\n2019-02-06 10:09:47.048 INFO 62314 --- [ntLoopGroup-2-2] reactor.Mono.SwitchIfEmpty.1 : onComplete()\n```", "```java\n2019-02-06 10:09:52.643 INFO 62314 --- [ctor-http-nio-3] reactor.Mono.SwitchIfEmpty.2 : onSubscribe(FluxSwitchIfEmpty.SwitchIfEmptySubscriber)\n2019-02-06 10:09:52.643 INFO 62314 --- [ctor-http-nio-3] reactor.Mono.SwitchIfEmpty.2 : request(unbounded)\n2019-02-06 10:09:52.648 ERROR 62314 --- [ntLoopGroup-2-2] reactor.Mono.SwitchIfEmpty.2 : onError(se.magnus.util.exceptions.NotFoundException: No product found for productId: 2)\n2019-02-06 10:09:52.654 ERROR 62314 --- [ntLoopGroup-2-2] reactor.Mono.SwitchIfEmpty.2 : \n\nse.magnus.util.exceptions.NotFoundException: No product found for productId: 2\n at se.magnus.microservices.core.product.services.ProductServiceImpl.getProduct(ProductServiceImpl.java:58) ~[classes/:na]\n ...\n```", "```java\n@Autowired\npublic ReviewServiceApplication (\n    @Value(\"${spring.datasource.maximum-pool-size:10}\") Integer \n    connectionPoolSize\n) {\n    this.connectionPoolSize = connectionPoolSize;\n}\n\n@Bean\npublic Scheduler jdbcScheduler() {\n    LOG.info(\"Creates a jdbcScheduler with connectionPoolSize = \" + \n    connectionPoolSize);\n    return Schedulers.fromExecutor(Executors.newFixedThreadPool\n    (connectionPoolSize));\n}\n```", "```java\n@RestController\npublic class ReviewServiceImpl implements ReviewService {\n\n    private final Scheduler scheduler;\n\n    @Autowired\n    public ReviewServiceImpl(Scheduler scheduler, ...) {\n        this.scheduler = scheduler;\n    }\n```", "```java\n@Override\npublic Flux<Review> getReviews(int productId) {\n\n    if (productId < 1) throw new InvalidInputException(\"Invalid \n        productId: \" + productId);\n\n    return asyncFlux(getByProductId(productId)).log();\n}\n\nprotected List<Review> getByProductId(int productId) {\n\n    List<ReviewEntity> entityList = \n    repository.findByProductId(productId);\n    List<Review> list = mapper.entityListToApiList(entityList);\n    list.forEach(e -> \n            e.setServiceAddress(serviceUtil.getServiceAddress()));\n\n    LOG.debug(\"getReviews: response size: {}\", list.size());\n\n    return list;\n}\n\nprivate <T> Flux<T> asyncFlux(Iterable<T> iterable) {\n    return Flux.fromIterable(iterable).publishOn(scheduler);\n}\n```", "```java\npublic class ProductCompositeIntegration implements ProductService, RecommendationService, ReviewService {\n\n    private final WebClient webClient;\n\n    @Autowired\n    public ProductCompositeIntegration(\n        WebClient.Builder webClient, ...\n    ) {\n        this.webClient = webClient.build();\n    }\n```", "```java\n@Override\npublic Mono<Product> getProduct(int productId) {\n    String url = productServiceUrl + \"/product/\" + productId;\n\n    return webClient.get().uri(url).retrieve().bodyToMono(Product.class).log().onErrorMap(WebClientResponseException.class, ex -> handleException(ex));\n}\n```", "```java\n@Override\npublic Flux<Recommendation> getRecommendations(int productId) {\n\n    String url = recommendationServiceUrl + \"/recommendation?\n    productId=\" + productId;\n\n    // Return an empty result if something goes wrong to make it \n    // possible for the composite service to return partial responses\n    return webClient.get().uri(url).retrieve().bodyToFlux(Recommendation.class).log().onErrorResume(error -> empty());\n}\n```", "```java\n@Override\npublic Mono<ProductAggregate> getCompositeProduct(int productId) {\n    return Mono.zip(\n        values -> createProductAggregate((Product) values[0], \n        (List<Recommendation>) values[1], (List<Review>) values[2], \n        serviceUtil.getServiceAddress()),\n        integration.getProduct(productId),\n        integration.getRecommendations(productId).collectList(),\n        integration.getReviews(productId).collectList())\n        .doOnError(ex -> LOG.warn(\"getCompositeProduct failed: {}\", \n         ex.toString()))\n        .log();\n}\n```", "```java\npublic class ProductCompositeServiceApplicationTests {\n\n    @Before\n    public void setUp() {\n\n        when(compositeIntegration.getProduct(PRODUCT_ID_OK)).\n            thenReturn(just(new Product(PRODUCT_ID_OK, \"name\", 1, \n             \"mock-address\")));\n\n        when(compositeIntegration.getRecommendations(PRODUCT_ID_OK)).\n            thenReturn(Flux.fromIterable(singletonList(new \n             Recommendation(PRODUCT_ID_OK, 1, \"author\", 1, \"content\", \n             \"mock address\"))));\n\n        when(compositeIntegration.getReviews(PRODUCT_ID_OK)).\n            thenReturn(Flux.fromIterable(singletonList(new \n             Review(PRODUCT_ID_OK, 1, \"author\", \"subject\", \"content\", \n             \"mock address\"))));\n```", "```java\nmysource.output().send(MessageBuilder.withPayload(message).build());\n```", "```java\n@StreamListener(target = Sink.INPUT)\n public void receive(MyMessage message) {\n   LOG.info(\"Received: {}\",message);\n```", "```java\nspring.cloud.stream:\n  bindings.input:\n    destination: products\n    group: productsGroup\n```", "```java\nspring.cloud.stream.bindings.input.consumer:\n  maxAttempts: 3\n  backOffInitialInterval: 500\n  backOffMaxInterval: 1000\n  backOffMultiplier: 2.0\n\nspring.cloud.stream.rabbit.bindings.input.consumer:\n  autoBindDlq: true\n  republishToDlq: true\n\nspring.cloud.stream.kafka.bindings.input.consumer:\n  enableDlq: true\n```", "```java\nspring.cloud.stream.bindings.output:\n  destination: products\n  producer:\n    partition-key-expression: payload.key\n    partition-count: 2\n```", "```java\nspring.cloud.stream.bindings.input:\n  destination: products\n  group:productsGroup\n  consumer:\n    partitioned: true\n    instance-index: 0\n```", "```java\npublic class Event<K, T> {\n\n    public enum Type {CREATE, DELETE}\n\n    private Event.Type eventType;\n    private K key;\n    private T data;\n    private LocalDateTime eventCreatedAt;\n\n    public Event() {\n        this.eventType = null;\n        this.key = null;\n        this.data = null;\n        this.eventCreatedAt = null;\n    }\n\n    public Event(Type eventType, K key, T data) {\n        this.eventType = eventType;\n        this.key = key;\n        this.data = data;\n        this.eventCreatedAt = now();\n    }\n\n    public Type getEventType() {\n        return eventType;\n    }\n\n    public K getKey() {\n        return key;\n    }\n\n    public T getData() {\n        return data;\n    }\n\n    public LocalDateTime getEventCreatedAt() {\n        return eventCreatedAt;\n    }\n}\n```", "```java\ndependencies {\n implementation('org.springframework.cloud:spring-cloud-starter-stream-rabbit')\n implementation('org.springframework.cloud:spring-cloud-starter-stream-kafka')\n testImplementation('org.springframework.cloud:spring-cloud-stream-test-support')\n}\n```", "```java\next {\n    springCloudVersion = \"Greenwich.RELEASE\"\n}\n```", "```java\ndependencyManagement {\n    imports {\n        mavenBom \"org.springframework.cloud:spring-cloud-\n        dependencies:${springCloudVersion}\"\n    }\n}\n```", "```java\n@EnableBinding(ProductCompositeIntegration.MessageSources.class)\n@Component\npublic class ProductCompositeIntegration implements ProductService, RecommendationService, ReviewService {\n\n    private MessageSources messageSources;\n\n    public interface MessageSources {\n\n        String OUTPUT_PRODUCTS = \"output-products\";\n        String OUTPUT_RECOMMENDATIONS = \"output-recommendations\";\n        String OUTPUT_REVIEWS = \"output-reviews\";\n\n        @Output(OUTPUT_PRODUCTS)\n        MessageChannel outputProducts();\n\n        @Output(OUTPUT_RECOMMENDATIONS)\n        MessageChannel outputRecommendations();\n\n        @Output(OUTPUT_REVIEWS)\n        MessageChannel outputReviews();\n    }\n\n    public ProductCompositeIntegration(\n        MessageSources messageSources,\n    ) {\n        this.messageSources = messageSources;\n    }\n```", "```java\n@Override\npublic void deleteProduct(int productId) {       \n    messageSources.outputProducts().send(MessageBuilder.\n    withPayload(new Event(DELETE, productId, null)).build());\n}\n```", "```java\nspring.cloud.stream:\n  defaultBinder: rabbit\n  default.contentType: application/json\n```", "```java\n  bindings:\n    output-products:\n      destination: products\n    output-recommendations:\n      destination: recommendations\n    output-reviews:\n      destination: reviews\n```", "```java\nspring.cloud.stream.kafka.binder:\n  brokers: 127.0.0.1\n  defaultBrokerPort: 9092\n\nspring.rabbitmq:\n  host: 127.0.0.1\n  port: 5672\n  username: guest\n  password: guest\n\n---\nspring.profiles: docker\n\nspring.rabbitmq.host: rabbitmq\nspring.cloud.stream.kafka.binder.brokers: kafka\n```", "```java\n  @Autowired\n  private MessageCollector collector;\n\n  BlockingQueue<Message<?>> queueProducts = null;\n  BlockingQueue<Message<?>> queueRecommendations = null;\n  BlockingQueue<Message<?>> queueReviews = null;\n\n  @Before\n  public void setUp() {\n      queueProducts = getQueue(channels.outputProducts());\n      queueRecommendations = \n      getQueue(channels.outputRecommendations());\n      queueReviews = getQueue(channels.outputReviews());\n  }\n\n  private BlockingQueue<Message<?>> getQueue(MessageChannel \n  messageChannel) {\n      return collector.forChannel(messageChannel);\n  } \n```", "```java\n@Test\npublic void createCompositeProduct1() {\n\n    ProductAggregate composite = new ProductAggregate(1, \"name\", 1, \n    null, null, null);\n    postAndVerifyProduct(composite, OK);\n\n    // Assert one expected new product events queued up\n    assertEquals(1, queueProducts.size());\n\n    Event<Integer, Product> expectedEvent = new Event(CREATE, \n    composite.getProductId(), new Product(composite.getProductId(), \n    composite.getName(), composite.getWeight(), null));\n    assertThat(queueProducts, \n    is(receivesPayloadThat (sameEventExceptCreatedAt \n    (expectedEvent))));\n\n    // Assert none recommendations and review events\n    assertEquals(0, queueRecommendations.size());\n    assertEquals(0, queueReviews.size());\n}\n```", "```java\n@EnableBinding(Sink.class)\npublic class MessageProcessor {\n```", "```java\n@StreamListener(target = Sink.INPUT)\npublic void process(Event<Integer, Product> event) {\n```", "```java\nswitch (event.getEventType()) {\n\ncase CREATE:\n    Product product = event.getData();\n    LOG.info(\"Create product with ID: {}\", product.getProductId());\n    productService.createProduct(product);\n    break;\n\ncase DELETE:\n    int productId = event.getKey();\n    LOG.info(\"Delete recommendations with ProductID: {}\", productId);\n    productService.deleteProduct(productId);\n    break;\n\ndefault:\n    String errorMessage = \"Incorrect event type: \" + \n    event.getEventType() + \", expected a CREATE or DELETE event\";\n    LOG.warn(errorMessage);\n throw new EventProcessingException(errorMessage);\n}\n```", "```java\nprivate final ProductService productService;\n\n@Autowired\npublic MessageProcessor(ProductService productService) {\n    this.productService = productService;\n}\n```", "```java\npublic class ProductServiceImpl implements ProductService {\n\n    @Override\n    public Product createProduct(Product body) {\n\n        if (body.getProductId() < 1) throw new \n        InvalidInputException(\"Invalid productId: \" + \n        body.getProductId());\n\n        ProductEntity entity = mapper.apiToEntity(body);\n        Mono<Product> newEntity = repository.save(entity)\n            .log()\n            .onErrorMap(\n                DuplicateKeyException.class,\n                ex -> new InvalidInputException(\"Duplicate key, Product \n                Id: \" + body.getProductId()))\n            .map(e -> mapper.entityToApi(e));\n\n        return newEntity.block();\n    }\n```", "```java\nprivate void sendCreateProductEvent(int productId) {\n    Product product = new Product(productId, \"Name \" + productId, \n    productId, \"SA\");\n    Event<Integer, Product> event = new Event(CREATE, productId, \n    product);\n    input.send(new GenericMessage<>(event));\n}\n\nprivate void sendDeleteProductEvent(int productId) {\n    Event<Integer, Product> event = new Event(DELETE, productId, null);\n    input.send(new GenericMessage<>(event));\n}\n```", "```java\n@Autowired\nprivate Sink channels;\n\nprivate AbstractMessageChannel input = null;\n\n@Before\npublic void setupDb() {\n   input = (AbstractMessageChannel) channels.input();\n   repository.deleteAll().block();\n}\n```", "```java\nspring.cloud.stream:\n  bindings:\n    output-products:\n      destination: products\n      producer:\n        required-groups: auditGroup\n```", "```java\npublic Mono<Health> getProductHealth() {\n    return getHealth(productServiceUrl);\n}\n\npublic Mono<Health> getRecommendationHealth() {\n    return getHealth(recommendationServiceUrl);\n}\n\npublic Mono<Health> getReviewHealth() {\n    return getHealth(reviewServiceUrl);\n}\n\nprivate Mono<Health> getHealth(String url) {\n    url += \"/actuator/health\";\n    LOG.debug(\"Will call the Health API on URL: {}\", url);\n    return webClient.get().uri(url).retrieve().bodyToMono(String.class)\n        .map(s -> new Health.Builder().up().build())\n        .onErrorResume(ex -> Mono.just(new \n         Health.Builder().down(ex).build()))\n        .log();\n}\n```", "```java\n@Autowired\nHealthAggregator healthAggregator;\n\n@Autowired\nProductCompositeIntegration integration;\n\n@Bean\nReactiveHealthIndicator coreServices() {\n\n    ReactiveHealthIndicatorRegistry registry = new \n    DefaultReactiveHealthIndicatorRegistry(new LinkedHashMap<>());\n\n    registry.register(\"product\", () -> integration.getProductHealth());\n    registry.register(\"recommendation\", () -> \n    integration.getRecommendationHealth());\n    registry.register(\"review\", () -> integration.getReviewHealth());\n\n    return new CompositeReactiveHealthIndicator(healthAggregator, \n    registry);\n}\n```", "```java\nmanagement.endpoint.health.show-details: \"ALWAYS\"\nmanagement.endpoints.web.exposure.include: \"*\"\n```", "```java\ncurl localhost:8080/actuator/health -s | jq .\n```", "```java\nrabbitmq:\n  image: rabbitmq:3.7.8-management\n  mem_limit: 350m\n  ports:\n    - 5672:5672\n    - 15672:15672\n  healthcheck:\n    test: [\"CMD\", \"rabbitmqctl\", \"status\"]\n    interval: 10s\n    timeout: 5s\n    retries: 10\n```", "```java\ndepends_on:\n  rabbitmq:\n    condition: service_healthy\n```", "```java\ncd $BOOK_HOME/Chapter07\n./gradlew build && docker-compose build && docker-compose up -d\n```", "```java\ncurl -s localhost:8080/actuator/health | jq -r .status\n```", "```java\nbody='{\"productId\":1,\"name\":\"product name C\",\"weight\":300, \"recommendations\":[\n {\"recommendationId\":1,\"author\":\"author 1\",\"rate\":1,\"content\":\"content 1\"},\n {\"recommendationId\":2,\"author\":\"author 2\",\"rate\":2,\"content\":\"content 2\"},\n {\"recommendationId\":3,\"author\":\"author 3\",\"rate\":3,\"content\":\"content 3\"}\n], \"reviews\":[\n {\"reviewId\":1,\"author\":\"author 1\",\"subject\":\"subject 1\",\"content\":\"content 1\"},\n {\"reviewId\":2,\"author\":\"author 2\",\"subject\":\"subject 2\",\"content\":\"content 2\"},\n {\"reviewId\":3,\"author\":\"author 3\",\"subject\":\"subject 3\",\"content\":\"content 3\"}\n]}'\n\ncurl -X POST localhost:8080/product-composite -H \"Content-Type: application/json\" --data \"$body\"\n```", "```java\ncurl localhost:8080/product-composite/1 | jq \n```", "```java\ncurl -X DELETE localhost:8080/product-composite/1\n```", "```java\ndocker-compose down\n```", "```java\nproduct-p1:\n  build: microservices/product-service\n  mem_limit: 350m\n  environment:\n    - SPRING_PROFILES_ACTIVE=docker\n    - SPRING_CLOUD_STREAM_BINDINGS_INPUT_CONSUMER_PARTITIONED=true\n    - SPRING_CLOUD_STREAM_BINDINGS_INPUT_CONSUMER_INSTANCECOUNT=2\n    - SPRING_CLOUD_STREAM_BINDINGS_INPUT_CONSUMER_INSTANCEINDEX=1\n  depends_on:\n    mongodb:\n      condition: service_healthy\n    rabbitmq:\n      condition: service_healthy\n```", "```java\nexport COMPOSE_FILE=docker-compose-partitions.yml\ndocker-compose build && docker-compose up -d\n```", "```java\ndocker-compose down\nunset COMPOSE_FILE\n```", "```java\nkafka:\n  image: wurstmeister/kafka:2.12-2.1.0\n  mem_limit: 350m\n  ports:\n    - \"9092:9092\"\n  environment:\n    - KAFKA_ADVERTISED_HOST_NAME=kafka\n    - KAFKA_ADVERTISED_PORT=9092\n    - KAFKA_ZOOKEEPER_CONNECT=zookeeper:2181\n  depends_on:\n    - zookeeper\n\nzookeeper:\n  image: wurstmeister/zookeeper:3.4.6\n  mem_limit: 350m\n  ports:\n    - \"2181:2181\"\n  environment:\n    - KAFKA_ADVERTISED_HOST_NAME=zookeeper\n```", "```java\nexport COMPOSE_FILE=docker-compose-kafka.yml\ndocker-compose build && docker-compose up -d\n```", "```java\ndocker-compose exec kafka /opt/kafka/bin/kafka-topics.sh --zookeeper zookeeper --list\n```", "```java\ndocker-compose exec kafka /opt/kafka/bin/kafka-topics.sh --describe --zookeeper zookeeper --topic products\n```", "```java\ndocker-compose exec kafka /opt/kafka/bin/kafka-console-consumer.sh --bootstrap-server localhost:9092 --topic products --from-beginning --timeout-ms 1000\n```", "```java\ndocker-compose exec kafka /opt/kafka/bin/kafka-console-consumer.sh --bootstrap-server localhost:9092 --topic products --from-beginning --timeout-ms 1000 --partition 1\n```", "```java\ndocker-compose down\nunset COMPOSE_FILE\n```", "```java\nwaitForService curl http://$HOST:$PORT/actuator/health\n```", "```java\nunset COMPOSE_FILE\n./test-em-all.bash start stop\n```", "```java\nexport COMPOSE_FILE=docker-compose-partitions.yml \n./test-em-all.bash start stop\nunset COMPOSE_FILE\n```", "```java\nexport COMPOSE_FILE=docker-compose-kafka.yml \n./test-em-all.bash start stop\nunset COMPOSE_FILE\n```", "```java\n    @Test\n    public void TestFlux() {\n\n        List<Integer> list = new ArrayList<>();\n\n        Flux.just(1, 2, 3, 4)\n            .filter(n -> n % 2 == 0)\n            .map(n -> n * 2)\n            .log();\n\n        assertThat(list).containsExactly(4, 8);\n```"]